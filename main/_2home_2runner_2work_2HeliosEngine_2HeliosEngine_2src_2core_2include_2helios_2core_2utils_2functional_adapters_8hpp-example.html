<!-- HTML header for doxygen 1.9.1+ with doxygen-awesome-css extensions -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
    <head>
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=11" />
        <meta name="generator" content="Doxygen 1.9.8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Helios Engine: /home/runner/work/HeliosEngine/HeliosEngine/src/core/include/helios/core/utils/functional_adapters.hpp</title>
        <!--BEGIN PROJECT_ICON-->
        <!--<link rel="icon" href="$projecticon" type="image/x-icon" />-->
        <link rel="icon" href="favicon.ico" type="image/x-icon" />
        <!--END PROJECT_ICON-->
        <link href="tabs.css" rel="stylesheet" type="text/css" />
        <script type="text/javascript" src="jquery.js"></script>
        <script type="text/javascript" src="dynsections.js"></script>
        <!--BEGIN COPY_CLIPBOARD-->
        <script type="text/javascript" src="clipboard.js"></script>
        <!--END COPY_CLIPBOARD-->
        <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
 <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>  
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
        <!-- doxygen-awesome-css extensions -->
        <script
            type="text/javascript"
            src="doxygen-awesome-fragment-copy-button.js"
        ></script>
        <script
            type="text/javascript"
            src="doxygen-awesome-paragraph-link.js"
        ></script>
        <script
            type="text/javascript"
            src="doxygen-awesome-interactive-toc.js"
        ></script>
        <script
            type="text/javascript"
            src="doxygen-awesome-tabs.js"
        ></script>
        <!-- Initialize doxygen-awesome-css extensions -->
        <script type="text/javascript">
            // Dark mode toggle customization
            //DoxygenAwesomeDarkModeToggle.title = "Toggle light/dark mode";
            //DoxygenAwesomeDarkModeToggle.lightModeIcon = "‚òÄÔ∏è";
            //DoxygenAwesomeDarkModeToggle.darkModeIcon = "üåô";
            //DoxygenAwesomeDarkModeToggle.init();
            // Fragment copy button customization
            DoxygenAwesomeFragmentCopyButton.title = "Copy to clipboard";
            DoxygenAwesomeFragmentCopyButton.init();
            // Paragraph link customization
            DoxygenAwesomeParagraphLink.title = "Copy link to this section";
            DoxygenAwesomeParagraphLink.icon = "¬∂";
            DoxygenAwesomeParagraphLink.init();
            // Interactive TOC customization
            DoxygenAwesomeInteractiveToc.topOffset = 45;
            DoxygenAwesomeInteractiveToc.hideMobileMenu = true;
            DoxygenAwesomeInteractiveToc.init();
            // Tabs extension
            DoxygenAwesomeTabs.init();
        </script>
    </head>
    <body>
            <div id="top">
                <!-- do not remove this div, it is closed by doxygen! -->
                <div id="titlearea">
                    <table cellspacing="0" cellpadding="0">
                        <tbody>
                            <tr id="projectrow">
                                <td id="projectlogo">
                                    <img
                                        alt="Logo"
                                        src="logo.png"
                                        $logosize
                                    />
                                </td>
                                <td id="projectalign">
                                    <div id="projectname">
                                        Helios Engine<span
                                            id="projectnumber"
                                            >&#160;0.1.0</span
                                        >
                                    </div>
                                    <div id="projectbrief">A modular ECS based data-oriented C++23 game engine</div>
                                </td>
                            </tr>
                            <tr>
                                <td colspan="2">        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                <!-- end header part -->
            </div>
        </div>
    </body>
</html>
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('_2home_2runner_2work_2HeliosEngine_2HeliosEngine_2src_2core_2include_2helios_2core_2utils_2functional_adapters_8hpp-example.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">/home/runner/work/HeliosEngine/HeliosEngine/src/core/include/helios/core/utils/functional_adapters.hpp</div></div>
</div><!--header-->
<div class="contents">
<p>Iterator adapter that filters elements based on a predicate function.</p>
<p>Iterator adapter that filters elements based on a predicate function. This adapter provides lazy filtering of iterator values. The filtering happens during iteration, not upfront, making it memory efficient for large sequences.</p>
<p>Supports chaining with other adapters for complex data transformations.</p>
<dl class="section note"><dt>Note</dt><dd>This adapter maintains forward iterator semantics. </dd>
<dd>
The adapter is constexpr-compatible for compile-time evaluation. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iter</td><td>Underlying iterator type that satisfies IteratorLike concept </td></tr>
    <tr><td class="paramname">Pred</td><td>Predicate function type</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="keyword">auto</span> enemies = query.Filter([](<span class="keyword">const</span> Health&amp; h) {</div>
<div class="line">  <span class="keywordflow">return</span> h.points &gt; 0;</div>
<div class="line">});</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="preprocessor">#pragma once</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="core__pch_8hpp.html">helios/core_pch.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;concepts&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cstddef&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iterator&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;optional&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;ranges&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;tuple&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;type_traits&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;unordered_map&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;utility&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span><a class="code hl_namespace" href="namespacehelios_1_1utils.html">helios::utils</a> {</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>details {</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * @brief Helper to extract tuple element types and check if a folder is invocable with accumulator + tuple elements</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Folder, <span class="keyword">typename</span> Accumulator, <span class="keyword">typename</span> Tuple&gt;</div>
<div class="line"><span class="keyword">struct </span>is_folder_applicable_impl : std::false_type {};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Folder, <span class="keyword">typename</span> Accumulator, <span class="keyword">typename</span>... TupleArgs&gt;</div>
<div class="line"><span class="keyword">struct </span>is_folder_applicable_impl&lt;Folder, Accumulator, std::tuple&lt;TupleArgs...&gt;&gt;</div>
<div class="line">    : std::bool_constant&lt;std::invocable&lt;Folder, Accumulator, TupleArgs...&gt;&gt; {};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Folder, <span class="keyword">typename</span> Accumulator, <span class="keyword">typename</span> Tuple&gt;</div>
<div class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keywordtype">bool</span> <a id="a0" name="a0"></a><a class="code hl_variable" href="namespacehelios_1_1utils_1_1details.html#a8382073153ee459213c49f4cc31f1883">is_folder_applicable_v</a> = is_folder_applicable_impl&lt;Folder, Accumulator, Tuple&gt;::value;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * @brief Helper to get the result type of folder applied with accumulator + tuple elements</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Folder, <span class="keyword">typename</span> Accumulator, <span class="keyword">typename</span> Tuple&gt;</div>
<div class="line"><span class="keyword">struct </span>folder_apply_result;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Folder, <span class="keyword">typename</span> Accumulator, <span class="keyword">typename</span>... TupleArgs&gt;</div>
<div class="line"><span class="keyword">struct </span>folder_apply_result&lt;Folder, Accumulator, std::tuple&lt;TupleArgs...&gt;&gt; {</div>
<div class="line">  <span class="keyword">using </span>type = std::invoke_result_t&lt;Folder, Accumulator, TupleArgs...&gt;;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Folder, <span class="keyword">typename</span> Accumulator, <span class="keyword">typename</span> Tuple&gt;</div>
<div class="line"><span class="keyword">using </span><a id="a1" name="a1"></a><a class="code hl_typedef" href="namespacehelios_1_1utils_1_1details.html#a783a48bbae4b9deac0e6086616ddef31">folder_apply_result_t</a> = <span class="keyword">typename</span> folder_apply_result&lt;Folder, Accumulator, Tuple&gt;::type;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * @brief Helper to get the result type of either invoke or apply</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Func, <span class="keyword">typename</span>... Args&gt;</div>
<div class="line"><span class="keyword">consteval</span> <span class="keyword">auto</span> <a id="a2" name="a2"></a><a class="code hl_function" href="namespacehelios_1_1utils_1_1details.html#a1bbd3cf95b591c66c67c6b8a5f3de936">get_call_or_apply_result_type</a>() <span class="keyword">noexcept</span> {</div>
<div class="line">  <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (std::invocable&lt;Func, Args...&gt;) {</div>
<div class="line">    <span class="keywordflow">return</span> std::type_identity&lt;std::invoke_result_t&lt;Func, Args...&gt;&gt;{};</div>
<div class="line">  } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class="keyword">sizeof</span>...(Args) == 1) {</div>
<div class="line">    <span class="keywordflow">return</span> std::type_identity&lt;decltype(std::apply(std::declval&lt;Func&gt;(), std::declval&lt;Args&gt;()...))&gt;{};</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="keyword">static_assert</span>(<span class="keyword">sizeof</span>...(Args) == 1,</div>
<div class="line">                  <span class="stringliteral">&quot;Callable must be invocable with Args or via std::apply with a single tuple argument&quot;</span>);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Func, <span class="keyword">typename</span>... Args&gt;</div>
<div class="line"><span class="keyword">using </span><a id="a3" name="a3"></a><a class="code hl_typedef" href="namespacehelios_1_1utils_1_1details.html#ab522c5f9db7a41104883d0d96f43f8da">call_or_apply_result_t</a> = <span class="keyword">typename</span> <span class="keyword">decltype</span>(<a class="code hl_function" href="namespacehelios_1_1utils_1_1details.html#a1bbd3cf95b591c66c67c6b8a5f3de936">get_call_or_apply_result_type</a>&lt;Func, Args...&gt;())::type;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Func, <span class="keyword">typename</span>... Args&gt;</div>
<div class="line"><span class="keyword">concept </span>CallableOrApplicable =</div>
<div class="line">    std::invocable&lt;Func, Args...&gt; ||</div>
<div class="line">    (<span class="keyword">sizeof</span>...(Args) == 1 &amp;&amp; <span class="keyword">requires</span>(Func func, Args&amp;&amp;... args) { std::apply(func, std::forward&lt;Args&gt;(args)...); });</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Func, <span class="keyword">typename</span> ReturnType, <span class="keyword">typename</span>... Args&gt;</div>
<div class="line"><span class="keyword">concept </span>CallableOrApplicableWithReturn =</div>
<div class="line">    CallableOrApplicable&lt;Func, Args...&gt; &amp;&amp; std::convertible_to&lt;<a class="code hl_typedef" href="namespacehelios_1_1utils_1_1details.html#ab522c5f9db7a41104883d0d96f43f8da">call_or_apply_result_t</a>&lt;Func, Args...&gt;, ReturnType&gt;;</div>
<div class="line"> </div>
<div class="line">}  <span class="comment">// namespace details</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * @brief Concept for types that can be used as base iterators in adapters.</span></div>
<div class="line"><span class="comment"> * @tparam T Type to check</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">concept </span>IteratorLike = <span class="keyword">requires</span>(T iter, <span class="keyword">const</span> T const_iter) {</div>
<div class="line">  <span class="keyword">typename</span> std::iter_value_t&lt;T&gt;;</div>
<div class="line">  { ++iter } -&gt; std::same_as&lt;std::add_lvalue_reference_t&lt;std::remove_cvref_t&lt;T&gt;&gt;&gt;;</div>
<div class="line">  { iter++ } -&gt; std::same_as&lt;std::remove_cvref_t&lt;T&gt;&gt;;</div>
<div class="line">  { *const_iter } -&gt; std::convertible_to&lt;std::iter_value_t&lt;T&gt;&gt;;</div>
<div class="line">  { const_iter == const_iter } -&gt; std::convertible_to&lt;bool&gt;;</div>
<div class="line">  { const_iter != const_iter } -&gt; std::convertible_to&lt;bool&gt;;</div>
<div class="line">};</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * @brief Concept for bidirectional iterators that support decrement operations.</span></div>
<div class="line"><span class="comment"> * @tparam T Type to check</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">concept </span>BidirectionalIteratorLike = IteratorLike&lt;T&gt; &amp;&amp; <span class="keyword">requires</span>(T iter) {</div>
<div class="line">  { --iter } -&gt; std::same_as&lt;std::add_lvalue_reference_t&lt;std::remove_cvref_t&lt;T&gt;&gt;&gt;;</div>
<div class="line">};</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * @brief Concept for predicate functions that can be applied to iterator values.</span></div>
<div class="line"><span class="comment"> * @details The predicate must be invocable with the value type and return a boolean-testable result.</span></div>
<div class="line"><span class="comment"> * Supports both direct invocation and std::apply for tuple unpacking.</span></div>
<div class="line"><span class="comment"> * The result must be usable in boolean contexts (if statements, etc.).</span></div>
<div class="line"><span class="comment"> * Allows const ref consumption even if the original type is just ref or value.</span></div>
<div class="line"><span class="comment"> * @tparam Pred Predicate type</span></div>
<div class="line"><span class="comment"> * @tparam ValueType Type of values to test</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Pred, <span class="keyword">typename</span> ValueType&gt;</div>
<div class="line"><span class="keyword">concept </span>PredicateFor = details::CallableOrApplicableWithReturn&lt;Pred, bool, ValueType&gt; ||</div>
<div class="line">                       details::CallableOrApplicableWithReturn&lt;</div>
<div class="line">                           Pred, bool, std::add_lvalue_reference_t&lt;std::add_const_t&lt;std::remove_cvref_t&lt;ValueType&gt;&gt;&gt;&gt; ||</div>
<div class="line">                       details::CallableOrApplicableWithReturn&lt;Pred, bool, std::remove_cvref_t&lt;ValueType&gt;&gt;;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * @brief Concept for transformation functions that can be applied to iterator values.</span></div>
<div class="line"><span class="comment"> * @details The function must be invocable with the value type and return a non-void result.</span></div>
<div class="line"><span class="comment"> * Supports both direct invocation and std::apply for tuple unpacking.</span></div>
<div class="line"><span class="comment"> * Allows const ref consumption even if the original type is just ref or value.</span></div>
<div class="line"><span class="comment"> * @tparam Func Function type</span></div>
<div class="line"><span class="comment"> * @tparam ValueType Type of values to transform</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Func, <span class="keyword">typename</span> ValueType&gt;</div>
<div class="line"><span class="keyword">concept </span>TransformFor =</div>
<div class="line">    (details::CallableOrApplicable&lt;Func, ValueType&gt; &amp;&amp;</div>
<div class="line">     !std::is_void_v&lt;details::call_or_apply_result_t&lt;Func, ValueType&gt;&gt;) ||</div>
<div class="line">    (details::CallableOrApplicable&lt;Func,</div>
<div class="line">                                   std::add_lvalue_reference_t&lt;std::add_const_t&lt;std::remove_cvref_t&lt;ValueType&gt;&gt;&gt;&gt; &amp;&amp;</div>
<div class="line">     !std::is_void_v&lt;<a class="code hl_typedef" href="namespacehelios_1_1utils_1_1details.html#ab522c5f9db7a41104883d0d96f43f8da">details::call_or_apply_result_t</a>&lt;</div>
<div class="line">         Func, std::add_lvalue_reference_t&lt;std::add_const_t&lt;std::remove_cvref_t&lt;ValueType&gt;&gt;&gt;&gt;&gt;) ||</div>
<div class="line">    (details::CallableOrApplicable&lt;Func, std::remove_cvref_t&lt;ValueType&gt;&gt; &amp;&amp;</div>
<div class="line">     !std::is_void_v&lt;details::call_or_apply_result_t&lt;Func, std::remove_cvref_t&lt;ValueType&gt;&gt;&gt;);</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * @brief Concept for inspection functions that observe but don&#39;t modify values.</span></div>
<div class="line"><span class="comment"> * @details The function must be invocable with the value type and return void.</span></div>
<div class="line"><span class="comment"> * Supports both direct invocation and std::apply for tuple unpacking.</span></div>
<div class="line"><span class="comment"> * Allows const ref consumption even if the original type is just ref or value.</span></div>
<div class="line"><span class="comment"> * @tparam Func Function type</span></div>
<div class="line"><span class="comment"> * @tparam ValueType Type of values to inspect</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Func, <span class="keyword">typename</span> ValueType&gt;</div>
<div class="line"><span class="keyword">concept </span>InspectorFor = details::CallableOrApplicableWithReturn&lt;Func, void, ValueType&gt; ||</div>
<div class="line">                       details::CallableOrApplicableWithReturn&lt;</div>
<div class="line">                           Func, void, std::add_lvalue_reference_t&lt;std::add_const_t&lt;std::remove_cvref_t&lt;ValueType&gt;&gt;&gt;&gt; ||</div>
<div class="line">                       details::CallableOrApplicableWithReturn&lt;Func, void, std::remove_cvref_t&lt;ValueType&gt;&gt;;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * @brief Concept for action functions that process values.</span></div>
<div class="line"><span class="comment"> * @details The function must be invocable with the value type.</span></div>
<div class="line"><span class="comment"> * Supports both direct invocation and std::apply for tuple unpacking.</span></div>
<div class="line"><span class="comment"> * Allows const ref consumption even if the original type is just ref or value.</span></div>
<div class="line"><span class="comment"> * @tparam Action Action function type</span></div>
<div class="line"><span class="comment"> * @tparam ValueType Type of values to process</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Action, <span class="keyword">typename</span> ValueType&gt;</div>
<div class="line"><span class="keyword">concept </span>ActionFor = details::CallableOrApplicableWithReturn&lt;Action, void, ValueType&gt; ||</div>
<div class="line">                    details::CallableOrApplicableWithReturn&lt;</div>
<div class="line">                        Action, void, std::add_lvalue_reference_t&lt;std::add_const_t&lt;std::remove_cvref_t&lt;ValueType&gt;&gt;&gt;&gt; ||</div>
<div class="line">                    details::CallableOrApplicableWithReturn&lt;Action, void, std::remove_cvref_t&lt;ValueType&gt;&gt;;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * @brief Concept for folder functions that accumulate values.</span></div>
<div class="line"><span class="comment"> * @details The function must be invocable with an accumulator and a value type.</span></div>
<div class="line"><span class="comment"> * Supports both direct invocation and std::apply for tuple unpacking.</span></div>
<div class="line"><span class="comment"> * @tparam Folder Folder function type</span></div>
<div class="line"><span class="comment"> * @tparam Accumulator Accumulator type</span></div>
<div class="line"><span class="comment"> * @tparam ValueType Type of values to fold</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Folder, <span class="keyword">typename</span> Accumulator, <span class="keyword">typename</span> ValueType&gt;</div>
<div class="line"><span class="keyword">concept </span>FolderFor =</div>
<div class="line">    (std::invocable&lt;Folder, Accumulator, ValueType&gt; &amp;&amp;</div>
<div class="line">     std::convertible_to&lt;std::invoke_result_t&lt;Folder, Accumulator, ValueType&gt;, Accumulator&gt;) ||</div>
<div class="line">    (<a class="code hl_variable" href="namespacehelios_1_1utils_1_1details.html#a8382073153ee459213c49f4cc31f1883">details::is_folder_applicable_v</a>&lt;Folder, Accumulator, std::remove_cvref_t&lt;ValueType&gt;&gt; &amp;&amp;</div>
<div class="line">     std::convertible_to&lt;<a class="code hl_typedef" href="namespacehelios_1_1utils_1_1details.html#a783a48bbae4b9deac0e6086616ddef31">details::folder_apply_result_t</a>&lt;Folder, Accumulator, std::remove_cvref_t&lt;ValueType&gt;&gt;,</div>
<div class="line">                         Accumulator&gt;);</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * @brief Concept to validate FilterAdapter requirements.</span></div>
<div class="line"><span class="comment"> * @tparam Iter Iterator type</span></div>
<div class="line"><span class="comment"> * @tparam Pred Predicate type</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter, <span class="keyword">typename</span> Pred&gt;</div>
<div class="line"><span class="keyword">concept </span>FilterAdapterRequirements = IteratorLike&lt;Iter&gt; &amp;&amp; PredicateFor&lt;Pred, std::iter_value_t&lt;Iter&gt;&gt;;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * @brief Concept to validate MapAdapter requirements.</span></div>
<div class="line"><span class="comment"> * @tparam Iter Iterator type</span></div>
<div class="line"><span class="comment"> * @tparam Func Transform function type</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter, <span class="keyword">typename</span> Func&gt;</div>
<div class="line"><span class="keyword">concept </span>MapAdapterRequirements = IteratorLike&lt;Iter&gt; &amp;&amp; TransformFor&lt;Func, std::iter_value_t&lt;Iter&gt;&gt;;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * @brief Concept to validate TakeAdapter requirements.</span></div>
<div class="line"><span class="comment"> * @tparam Iter Iterator type</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</div>
<div class="line"><span class="keyword">concept </span>TakeAdapterRequirements = IteratorLike&lt;Iter&gt;;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * @brief Concept to validate SkipAdapter requirements.</span></div>
<div class="line"><span class="comment"> * @tparam Iter Iterator type</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</div>
<div class="line"><span class="keyword">concept </span>SkipAdapterRequirements = IteratorLike&lt;Iter&gt;;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * @brief Concept to validate TakeWhileAdapter requirements.</span></div>
<div class="line"><span class="comment"> * @tparam Iter Iterator type</span></div>
<div class="line"><span class="comment"> * @tparam Pred Predicate type</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter, <span class="keyword">typename</span> Pred&gt;</div>
<div class="line"><span class="keyword">concept </span>TakeWhileAdapterRequirements = IteratorLike&lt;Iter&gt; &amp;&amp; PredicateFor&lt;Pred, std::iter_value_t&lt;Iter&gt;&gt;;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * @brief Concept to validate SkipWhileAdapter requirements.</span></div>
<div class="line"><span class="comment"> * @tparam Iter Iterator type</span></div>
<div class="line"><span class="comment"> * @tparam Pred Predicate type</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter, <span class="keyword">typename</span> Pred&gt;</div>
<div class="line"><span class="keyword">concept </span>SkipWhileAdapterRequirements = IteratorLike&lt;Iter&gt; &amp;&amp; PredicateFor&lt;Pred, std::iter_value_t&lt;Iter&gt;&gt;;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * @brief Concept to validate EnumerateAdapter requirements.</span></div>
<div class="line"><span class="comment"> * @tparam Iter Iterator type</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</div>
<div class="line"><span class="keyword">concept </span>EnumerateAdapterRequirements = IteratorLike&lt;Iter&gt;;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * @brief Concept to validate InspectAdapter requirements.</span></div>
<div class="line"><span class="comment"> * @tparam Iter Iterator type</span></div>
<div class="line"><span class="comment"> * @tparam Func Inspector function type</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter, <span class="keyword">typename</span> Func&gt;</div>
<div class="line"><span class="keyword">concept </span>InspectAdapterRequirements = IteratorLike&lt;Iter&gt; &amp;&amp; InspectorFor&lt;Func, std::iter_value_t&lt;Iter&gt;&gt;;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * @brief Concept to validate StepByAdapter requirements.</span></div>
<div class="line"><span class="comment"> * @tparam Iter Iterator type</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</div>
<div class="line"><span class="keyword">concept </span>StepByAdapterRequirements = IteratorLike&lt;Iter&gt;;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * @brief Concept to validate ChainAdapter requirements.</span></div>
<div class="line"><span class="comment"> * @tparam Iter1 First iterator type</span></div>
<div class="line"><span class="comment"> * @tparam Iter2 Second iterator type</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter1, <span class="keyword">typename</span> Iter2&gt;</div>
<div class="line"><span class="keyword">concept </span>ChainAdapterRequirements =</div>
<div class="line">    IteratorLike&lt;Iter1&gt; &amp;&amp; IteratorLike&lt;Iter2&gt; &amp;&amp; std::same_as&lt;std::iter_value_t&lt;Iter1&gt;, std::iter_value_t&lt;Iter2&gt;&gt;;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * @brief Concept to validate ReverseAdapter requirements.</span></div>
<div class="line"><span class="comment"> * @tparam Iter Iterator type</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</div>
<div class="line"><span class="keyword">concept </span>ReverseAdapterRequirements = BidirectionalIteratorLike&lt;Iter&gt;;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * @brief Concept to validate JoinAdapter requirements.</span></div>
<div class="line"><span class="comment"> * @tparam Iter Iterator type</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</div>
<div class="line"><span class="keyword">concept </span>JoinAdapterRequirements = IteratorLike&lt;Iter&gt; &amp;&amp; std::ranges::range&lt;std::iter_value_t&lt;Iter&gt;&gt;;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * @brief Concept to validate SlideAdapter requirements.</span></div>
<div class="line"><span class="comment"> * @tparam Iter Iterator type</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</div>
<div class="line"><span class="keyword">concept </span>SlideAdapterRequirements = IteratorLike&lt;Iter&gt;;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * @brief Concept to validate StrideAdapter requirements.</span></div>
<div class="line"><span class="comment"> * @tparam Iter Iterator type</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</div>
<div class="line"><span class="keyword">concept </span>StrideAdapterRequirements = IteratorLike&lt;Iter&gt;;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * @brief Concept to validate ZipAdapter requirements.</span></div>
<div class="line"><span class="comment"> * @tparam Iter1 First iterator type</span></div>
<div class="line"><span class="comment"> * @tparam Iter2 Second iterator type</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter1, <span class="keyword">typename</span> Iter2&gt;</div>
<div class="line"><span class="keyword">concept </span>ZipAdapterRequirements = IteratorLike&lt;Iter1&gt; &amp;&amp; IteratorLike&lt;Iter2&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Derived&gt;</div>
<div class="line"><span class="keyword">class </span>FunctionalAdapterBase;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter, <span class="keyword">typename</span> Pred&gt;</div>
<div class="line">  <span class="keyword">requires</span> FilterAdapterRequirements&lt;Iter, Pred&gt;</div>
<div class="line"><span class="keyword">class </span>FilterAdapter;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter, <span class="keyword">typename</span> Func&gt;</div>
<div class="line">  <span class="keyword">requires</span> MapAdapterRequirements&lt;Iter, Func&gt;</div>
<div class="line"><span class="keyword">class </span>MapAdapter;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</div>
<div class="line">  <span class="keyword">requires</span> TakeAdapterRequirements&lt;Iter&gt;</div>
<div class="line"><span class="keyword">class </span>TakeAdapter;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</div>
<div class="line">  <span class="keyword">requires</span> SkipAdapterRequirements&lt;Iter&gt;</div>
<div class="line"><span class="keyword">class </span>SkipAdapter;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter, <span class="keyword">typename</span> Pred&gt;</div>
<div class="line">  <span class="keyword">requires</span> TakeWhileAdapterRequirements&lt;Iter, Pred&gt;</div>
<div class="line"><span class="keyword">class </span>TakeWhileAdapter;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter, <span class="keyword">typename</span> Pred&gt;</div>
<div class="line">  <span class="keyword">requires</span> SkipWhileAdapterRequirements&lt;Iter, Pred&gt;</div>
<div class="line"><span class="keyword">class </span>SkipWhileAdapter;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</div>
<div class="line">  <span class="keyword">requires</span> EnumerateAdapterRequirements&lt;Iter&gt;</div>
<div class="line"><span class="keyword">class </span>EnumerateAdapter;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter, <span class="keyword">typename</span> Func&gt;</div>
<div class="line">  <span class="keyword">requires</span> InspectAdapterRequirements&lt;Iter, Func&gt;</div>
<div class="line"><span class="keyword">class </span>InspectAdapter;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</div>
<div class="line">  <span class="keyword">requires</span> StepByAdapterRequirements&lt;Iter&gt;</div>
<div class="line"><span class="keyword">class </span>StepByAdapter;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter1, <span class="keyword">typename</span> Iter2&gt;</div>
<div class="line">  <span class="keyword">requires</span> ChainAdapterRequirements&lt;Iter1, Iter2&gt;</div>
<div class="line"><span class="keyword">class </span>ChainAdapter;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</div>
<div class="line">  <span class="keyword">requires</span> ReverseAdapterRequirements&lt;Iter&gt;</div>
<div class="line"><span class="keyword">class </span>ReverseAdapter;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</div>
<div class="line">  <span class="keyword">requires</span> JoinAdapterRequirements&lt;Iter&gt;</div>
<div class="line"><span class="keyword">class </span>JoinAdapter;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</div>
<div class="line">  <span class="keyword">requires</span> SlideAdapterRequirements&lt;Iter&gt;</div>
<div class="line"><span class="keyword">class </span>SlideAdapter;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</div>
<div class="line">  <span class="keyword">requires</span> StrideAdapterRequirements&lt;Iter&gt;</div>
<div class="line"><span class="keyword">class </span>StrideAdapter;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter1, <span class="keyword">typename</span> Iter2&gt;</div>
<div class="line">  <span class="keyword">requires</span> ZipAdapterRequirements&lt;Iter1, Iter2&gt;</div>
<div class="line"><span class="keyword">class </span>ZipAdapter;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * @brief Iterator adapter that filters elements based on a predicate function.</span></div>
<div class="line"><span class="comment"> * @details This adapter provides lazy filtering of iterator values.</span></div>
<div class="line"><span class="comment"> * The filtering happens during iteration, not upfront, making it memory efficient for large sequences.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * Supports chaining with other adapters for complex data transformations.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * @note This adapter maintains forward iterator semantics.</span></div>
<div class="line"><span class="comment"> * @note The adapter is constexpr-compatible for compile-time evaluation.</span></div>
<div class="line"><span class="comment"> * @tparam Iter Underlying iterator type that satisfies IteratorLike concept</span></div>
<div class="line"><span class="comment"> * @tparam Pred Predicate function type</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * @example</span></div>
<div class="line"><span class="comment"> * @code</span></div>
<div class="line"><span class="comment"> * auto enemies = query.Filter([](const Health&amp; h) {</span></div>
<div class="line"><span class="comment"> *   return h.points &gt; 0;</span></div>
<div class="line"><span class="comment"> * });</span></div>
<div class="line"><span class="comment"> * @endcode</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter, <span class="keyword">typename</span> Pred&gt;</div>
<div class="line">  <span class="keyword">requires</span> FilterAdapterRequirements&lt;Iter, Pred&gt;</div>
<div class="line"><span class="keyword">class </span>FilterAdapter : <span class="keyword">public</span> FunctionalAdapterBase&lt;FilterAdapter&lt;Iter, Pred&gt;&gt; {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">using </span><a id="a4" name="a4"></a><a class="code hl_typedef" href="classhelios_1_1utils_1_1FilterAdapter.html#a4fa8bccdf13c4a0996f588e5116613ed">iterator_category</a> = std::forward_iterator_tag;</div>
<div class="line">  <span class="keyword">using </span><a id="a5" name="a5"></a><a class="code hl_typedef" href="classhelios_1_1utils_1_1FilterAdapter.html#a0990c4e2e7e4aefab7ca5c9efef8712c">value_type</a> = std::iter_value_t&lt;Iter&gt;;</div>
<div class="line">  <span class="keyword">using </span><a id="a6" name="a6"></a><a class="code hl_typedef" href="classhelios_1_1utils_1_1FilterAdapter.html#a3391a88e0643c85d299943070d6833d0">difference_type</a> = std::iter_difference_t&lt;Iter&gt;;</div>
<div class="line">  <span class="keyword">using </span><a id="a7" name="a7"></a><a class="code hl_typedef" href="classhelios_1_1utils_1_1FilterAdapter.html#a9387ce1238cd6a70f0e76f5ddeaf1e04">pointer</a> = <a class="code hl_typedef" href="classhelios_1_1utils_1_1FilterAdapter.html#a0990c4e2e7e4aefab7ca5c9efef8712c">value_type</a>*;</div>
<div class="line">  <span class="keyword">using </span><a id="a8" name="a8"></a><a class="code hl_typedef" href="classhelios_1_1utils_1_1FilterAdapter.html#a93d694a2db572479331fb1dbf46ea67c">reference</a> = <a class="code hl_typedef" href="classhelios_1_1utils_1_1FilterAdapter.html#a0990c4e2e7e4aefab7ca5c9efef8712c">value_type</a>;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /**</span></div>
<div class="line"><span class="comment">   * @brief Constructs a filter adapter with the given iterator range and predicate.</span></div>
<div class="line"><span class="comment">   * @param begin Start of the iterator range</span></div>
<div class="line"><span class="comment">   * @param end End of the iterator range</span></div>
<div class="line"><span class="comment">   * @param predicate Function to filter elements</span></div>
<div class="line"><span class="comment">   */</span></div>
<div class="line">  <span class="keyword">constexpr</span> FilterAdapter(Iter <a id="a9" name="a9"></a><a class="code hl_function" href="classhelios_1_1utils_1_1FilterAdapter.html#afe19b8fcd9acb515403302a1ecec4f78">begin</a>, Iter <a id="a10" name="a10"></a><a class="code hl_function" href="classhelios_1_1utils_1_1FilterAdapter.html#a2b6f115f430bc06636f918349ecafa26">end</a>, Pred predicate) <span class="keyword">noexcept</span>(std::is_nothrow_copy_constructible_v&lt;Iter&gt; &amp;&amp;</div>
<div class="line">                                                                         std::is_nothrow_move_constructible_v&lt;Iter&gt; &amp;&amp;</div>
<div class="line">                                                                         std::is_nothrow_move_constructible_v&lt;Pred&gt; &amp;&amp;</div>
<div class="line">                                                                         <span class="keyword">noexcept</span>(AdvanceToValid()))</div>
<div class="line">      : begin_(std::move(<a class="code hl_function" href="classhelios_1_1utils_1_1FilterAdapter.html#afe19b8fcd9acb515403302a1ecec4f78">begin</a>)), current_(begin_), end_(std::move(<a class="code hl_function" href="classhelios_1_1utils_1_1FilterAdapter.html#a2b6f115f430bc06636f918349ecafa26">end</a>)), predicate_(std::move(predicate)) {</div>
<div class="line">    AdvanceToValid();</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">constexpr</span> FilterAdapter(<span class="keyword">const</span> FilterAdapter&amp;) <span class="keyword">noexcept</span>(std::is_nothrow_copy_constructible_v&lt;Iter&gt; &amp;&amp;</div>
<div class="line">                                                         std::is_nothrow_copy_constructible_v&lt;Pred&gt;) = <span class="keywordflow">default</span>;</div>
<div class="line">  <span class="keyword">constexpr</span> FilterAdapter(FilterAdapter&amp;&amp;) <span class="keyword">noexcept</span>(std::is_nothrow_move_constructible_v&lt;Iter&gt; &amp;&amp;</div>
<div class="line">                                                    std::is_nothrow_move_constructible_v&lt;Pred&gt;) = <span class="keywordflow">default</span>;</div>
<div class="line">  <span class="keyword">constexpr</span> <a id="a11" name="a11"></a><a class="code hl_function" href="classhelios_1_1utils_1_1FilterAdapter.html#ae4f733ecc64b5130a71f8656803fb8f0">~FilterAdapter</a>() <span class="keyword">noexcept</span>(std::is_nothrow_destructible_v&lt;Iter&gt; &amp;&amp;</div>
<div class="line">                                      std::is_nothrow_destructible_v&lt;Pred&gt;) = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">constexpr</span> FilterAdapter&amp; <a id="a12" name="a12"></a><a class="code hl_function" href="classhelios_1_1utils_1_1FilterAdapter.html#ac8a734932c8789de85b5b09f11bb8c46">operator=</a>(<span class="keyword">const</span> FilterAdapter&amp;) <span class="keyword">noexcept</span>(std::is_nothrow_copy_assignable_v&lt;Iter&gt; &amp;&amp;</div>
<div class="line">                                                                    std::is_nothrow_copy_assignable_v&lt;Pred&gt;) = <span class="keywordflow">default</span>;</div>
<div class="line">  <span class="keyword">constexpr</span> FilterAdapter&amp; <a class="code hl_function" href="classhelios_1_1utils_1_1FilterAdapter.html#ac8a734932c8789de85b5b09f11bb8c46">operator=</a>(FilterAdapter&amp;&amp;) <span class="keyword">noexcept</span>(std::is_nothrow_move_assignable_v&lt;Iter&gt; &amp;&amp;</div>
<div class="line">                                                               std::is_nothrow_move_assignable_v&lt;Pred&gt;) = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">constexpr</span> FilterAdapter&amp; <a id="a13" name="a13"></a><a class="code hl_function" href="classhelios_1_1utils_1_1FilterAdapter.html#a84b0b5106aae4d1dea104598fbe0972f">operator++</a>() <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(++std::declval&lt;Iter&amp;&gt;()) &amp;&amp; <span class="keyword">noexcept</span>(AdvanceToValid()));</div>
<div class="line">  <span class="keyword">constexpr</span> FilterAdapter <a class="code hl_function" href="classhelios_1_1utils_1_1FilterAdapter.html#a84b0b5106aae4d1dea104598fbe0972f">operator++</a>(<span class="keywordtype">int</span>) <span class="keyword">noexcept</span>(std::is_nothrow_copy_constructible_v&lt;FilterAdapter&gt; &amp;&amp;</div>
<div class="line">                                                   <span class="keyword">noexcept</span>(++std::declval&lt;FilterAdapter&amp;&gt;()));</div>
<div class="line"> </div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> <a class="code hl_typedef" href="classhelios_1_1utils_1_1FilterAdapter.html#a0990c4e2e7e4aefab7ca5c9efef8712c">value_type</a> <a id="a14" name="a14"></a><a class="code hl_function" href="classhelios_1_1utils_1_1FilterAdapter.html#a3f546933049a8c8d7b550effcf6a9acc">operator*</a>() <span class="keyword">const</span> <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(*std::declval&lt;const Iter&amp;&gt;())) {</div>
<div class="line">    <span class="keywordflow">return</span> *current_;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> <span class="keywordtype">bool</span> <a id="a15" name="a15"></a><a class="code hl_function" href="classhelios_1_1utils_1_1FilterAdapter.html#a72d4d330718c70483b2d7e77ff8ad078">operator==</a>(<span class="keyword">const</span> FilterAdapter&amp; other) <span class="keyword">const</span></div>
<div class="line">      <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(std::declval&lt;const Iter&amp;&gt;() == std::declval&lt;const Iter&amp;&gt;())) {</div>
<div class="line">    <span class="keywordflow">return</span> current_ == other.current_;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> <span class="keywordtype">bool</span> <a id="a16" name="a16"></a><a class="code hl_function" href="classhelios_1_1utils_1_1FilterAdapter.html#a50c5b2344ebddb229f57e26502f4c14d">operator!=</a>(<span class="keyword">const</span> FilterAdapter&amp; other) <span class="keyword">const</span></div>
<div class="line">      <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(std::declval&lt;const FilterAdapter&amp;&gt;() == std::declval&lt;const FilterAdapter&amp;&gt;())) {</div>
<div class="line">    <span class="keywordflow">return</span> !(*<span class="keyword">this</span> == other);</div>
<div class="line">  }</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /**</span></div>
<div class="line"><span class="comment">   * @brief Checks if the iterator has reached the end.</span></div>
<div class="line"><span class="comment">   * @return True if at end, false otherwise</span></div>
<div class="line"><span class="comment">   */</span></div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> <span class="keywordtype">bool</span> <a id="a17" name="a17"></a><a class="code hl_function" href="classhelios_1_1utils_1_1FilterAdapter.html#af952a366fad4ddc65e2f7fa613b9bf6d">IsAtEnd</a>() <span class="keyword">const</span></div>
<div class="line">      <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(std::declval&lt;const Iter&amp;&gt;() == std::declval&lt;const Iter&amp;&gt;())) {</div>
<div class="line">    <span class="keywordflow">return</span> current_ == end_;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> FilterAdapter <a class="code hl_function" href="classhelios_1_1utils_1_1FilterAdapter.html#afe19b8fcd9acb515403302a1ecec4f78">begin</a>() <span class="keyword">const</span> <span class="keyword">noexcept</span>(std::is_nothrow_copy_constructible_v&lt;FilterAdapter&gt;) {</div>
<div class="line">    <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> FilterAdapter <a class="code hl_function" href="classhelios_1_1utils_1_1FilterAdapter.html#a2b6f115f430bc06636f918349ecafa26">end</a>() <span class="keyword">const</span></div>
<div class="line">      <span class="keyword">noexcept</span>(std::is_nothrow_constructible_v&lt;FilterAdapter, const Iter&amp;, const Iter&amp;, const Pred&amp;&gt;) {</div>
<div class="line">    <span class="keywordflow">return</span> {end_, end_, predicate_};</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keyword">constexpr</span> <span class="keywordtype">void</span> AdvanceToValid() <span class="keyword">noexcept</span>(std::is_nothrow_invocable_v&lt;Pred, std::iter_value_t&lt;Iter&gt;&gt; &amp;&amp;</div>
<div class="line">                                           <span class="keyword">noexcept</span>(*std::declval&lt;Iter&amp;&gt;()) &amp;&amp; <span class="keyword">noexcept</span>(++std::declval&lt;Iter&amp;&gt;()) &amp;&amp;</div>
<div class="line">                                           <span class="keyword">noexcept</span>(std::declval&lt;Iter&amp;&gt;() != std::declval&lt;Iter&amp;&gt;()));</div>
<div class="line"> </div>
<div class="line">  Iter begin_;      <span class="comment">///&lt; Start of the iterator range</span></div>
<div class="line">  Iter current_;    <span class="comment">///&lt; Current position in the iteration</span></div>
<div class="line">  Iter end_;        <span class="comment">///&lt; End of the iterator range</span></div>
<div class="line">  Pred predicate_;  <span class="comment">///&lt; Predicate function for filtering</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter, <span class="keyword">typename</span> Pred&gt;</div>
<div class="line">  <span class="keyword">requires</span> FilterAdapterRequirements&lt;Iter, Pred&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <a class="code hl_function" href="classhelios_1_1utils_1_1FilterAdapter.html#a84b0b5106aae4d1dea104598fbe0972f">FilterAdapter&lt;Iter, Pred&gt;::operator++</a>() <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(++std::declval&lt;Iter&amp;&gt;()) &amp;&amp;</div>
<div class="line">                                                                <span class="keyword">noexcept</span>(AdvanceToValid())) -&gt; FilterAdapter&amp; {</div>
<div class="line">  ++current_;</div>
<div class="line">  AdvanceToValid();</div>
<div class="line">  <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter, <span class="keyword">typename</span> Pred&gt;</div>
<div class="line">  <span class="keyword">requires</span> FilterAdapterRequirements&lt;Iter, Pred&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <a class="code hl_function" href="classhelios_1_1utils_1_1FilterAdapter.html#a84b0b5106aae4d1dea104598fbe0972f">FilterAdapter&lt;Iter, Pred&gt;::operator++</a>(<span class="keywordtype">int</span>) <span class="keyword">noexcept</span>(</div>
<div class="line">    std::is_nothrow_copy_constructible_v&lt;FilterAdapter&gt; &amp;&amp; <span class="keyword">noexcept</span>(++std::declval&lt;FilterAdapter&amp;&gt;()))</div>
<div class="line">    -&gt; FilterAdapter {</div>
<div class="line">  <span class="keyword">auto</span> temp = *<span class="keyword">this</span>;</div>
<div class="line">  ++(*this);</div>
<div class="line">  <span class="keywordflow">return</span> temp;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter, <span class="keyword">typename</span> Pred&gt;</div>
<div class="line">  <span class="keyword">requires</span> FilterAdapterRequirements&lt;Iter, Pred&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keywordtype">void</span> FilterAdapter&lt;Iter, Pred&gt;::AdvanceToValid() <span class="keyword">noexcept</span>(</div>
<div class="line">    std::is_nothrow_invocable_v&lt;Pred, std::iter_value_t&lt;Iter&gt;&gt; &amp;&amp; <span class="keyword">noexcept</span>(*std::declval&lt;Iter&amp;&gt;()) &amp;&amp;</div>
<div class="line">    <span class="keyword">noexcept</span>(++std::declval&lt;Iter&amp;&gt;()) &amp;&amp; <span class="keyword">noexcept</span>(std::declval&lt;Iter&amp;&gt;() != std::declval&lt;Iter&amp;&gt;())) {</div>
<div class="line">  <span class="keywordflow">while</span> (current_ != end_) {</div>
<div class="line">    <span class="keyword">auto</span> value = *current_;</div>
<div class="line">    <span class="keywordtype">bool</span> matches = <span class="keyword">false</span>;</div>
<div class="line">    <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (std::invocable&lt;Pred, <span class="keyword">decltype</span>(value)&gt;) {</div>
<div class="line">      matches = predicate_(value);</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      matches = std::apply(predicate_, value);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (matches) {</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line">    ++current_;</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * @brief Iterator adapter that transforms each element using a function.</span></div>
<div class="line"><span class="comment"> * @details This adapter applies a transformation function to each element during iteration.</span></div>
<div class="line"><span class="comment"> * The transformation is lazy - it happens when the element is accessed, not when the adapter is created.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * The transformation function can accept either the full value or individual tuple</span></div>
<div class="line"><span class="comment"> * components if the value is a tuple type.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * @note This adapter maintains forward iterator semantics.</span></div>
<div class="line"><span class="comment"> * The adapter is constexpr-compatible for compile-time evaluation.</span></div>
<div class="line"><span class="comment"> * @tparam Iter Underlying iterator type that satisfies IteratorLike concept</span></div>
<div class="line"><span class="comment"> * @tparam Func Transformation function type</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * @example</span></div>
<div class="line"><span class="comment"> * @code</span></div>
<div class="line"><span class="comment"> * auto positions = query.Map([](const Transform&amp; t) {</span></div>
<div class="line"><span class="comment"> *   return t.position;</span></div>
<div class="line"><span class="comment"> * });</span></div>
<div class="line"><span class="comment"> * @endcode</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter, <span class="keyword">typename</span> Func&gt;</div>
<div class="line">  <span class="keyword">requires</span> MapAdapterRequirements&lt;Iter, Func&gt;</div>
<div class="line"><span class="keyword">class </span>MapAdapter : <span class="keyword">public</span> FunctionalAdapterBase&lt;MapAdapter&lt;Iter, Func&gt;&gt; {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">  <span class="keyword">struct </span>DeduceValueType;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</div>
<div class="line">  <span class="keyword">struct </span>DeduceValueType&lt;std::tuple&lt;Args...&gt;&gt; {</div>
<div class="line">    <span class="keyword">using </span>Type = <span class="keyword">decltype</span>(std::apply(std::declval&lt;Func&gt;(), std::declval&lt;std::tuple&lt;Args...&gt;&gt;()));</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">    <span class="keyword">requires</span>(!<span class="keyword">requires</span> { <span class="keyword">typename</span> std::tuple_size&lt;T&gt;::type; })</div>
<div class="line">  <span class="keyword">struct</span> DeduceValueType&lt;T&gt; {</div>
<div class="line">    <span class="keyword">using </span>Type = std::invoke_result_t&lt;Func, T&gt;;</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">using </span><a id="a18" name="a18"></a><a class="code hl_typedef" href="classhelios_1_1utils_1_1MapAdapter.html#a902bc56c6b4352aaee4e9d5ff954b816">iterator_category</a> = std::forward_iterator_tag;</div>
<div class="line">  <span class="keyword">using </span><a id="a19" name="a19"></a><a class="code hl_typedef" href="classhelios_1_1utils_1_1MapAdapter.html#ac79ca7706b38dbd56f55820f630f1fef">value_type</a> = <span class="keyword">typename</span> DeduceValueType&lt;std::iter_value_t&lt;Iter&gt;&gt;::Type;</div>
<div class="line">  <span class="keyword">using </span><a id="a20" name="a20"></a><a class="code hl_typedef" href="classhelios_1_1utils_1_1MapAdapter.html#a8b6a697c96b90e78444f46417a64edaa">difference_type</a> = std::iter_difference_t&lt;Iter&gt;;</div>
<div class="line">  <span class="keyword">using </span><a id="a21" name="a21"></a><a class="code hl_typedef" href="classhelios_1_1utils_1_1MapAdapter.html#ab17cd7399d90ea2d3f551daf2b58faac">pointer</a> = <a class="code hl_typedef" href="classhelios_1_1utils_1_1MapAdapter.html#ac79ca7706b38dbd56f55820f630f1fef">value_type</a>*;</div>
<div class="line">  <span class="keyword">using </span><a id="a22" name="a22"></a><a class="code hl_typedef" href="classhelios_1_1utils_1_1MapAdapter.html#a138856a68fc6ad3fbcc4948498841033">reference</a> = <a class="code hl_typedef" href="classhelios_1_1utils_1_1MapAdapter.html#ac79ca7706b38dbd56f55820f630f1fef">value_type</a>;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /**</span></div>
<div class="line"><span class="comment">   * @brief Constructs a map adapter with the given iterator range and transform function.</span></div>
<div class="line"><span class="comment">   * @param begin Start of the iterator range</span></div>
<div class="line"><span class="comment">   * @param end End of the iterator range</span></div>
<div class="line"><span class="comment">   * @param transform Function to transform elements</span></div>
<div class="line"><span class="comment">   */</span></div>
<div class="line">  <span class="keyword">constexpr</span> MapAdapter(Iter <a id="a23" name="a23"></a><a class="code hl_function" href="classhelios_1_1utils_1_1MapAdapter.html#a626fe4c1b58cc2482e19a5a2d2b95911">begin</a>, Iter <a id="a24" name="a24"></a><a class="code hl_function" href="classhelios_1_1utils_1_1MapAdapter.html#a1f5443be56805c1bad325498f1652ca9">end</a>, Func transform) <span class="keyword">noexcept</span>(std::is_nothrow_move_constructible_v&lt;Iter&gt; &amp;&amp;</div>
<div class="line">                                                                      std::is_nothrow_move_constructible_v&lt;Func&gt;)</div>
<div class="line">      : begin_(std::move(<a class="code hl_function" href="classhelios_1_1utils_1_1MapAdapter.html#a626fe4c1b58cc2482e19a5a2d2b95911">begin</a>)), current_(begin_), end_(std::move(<a class="code hl_function" href="classhelios_1_1utils_1_1MapAdapter.html#a1f5443be56805c1bad325498f1652ca9">end</a>)), transform_(std::move(transform)) {}</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">constexpr</span> MapAdapter(<span class="keyword">const</span> MapAdapter&amp;) <span class="keyword">noexcept</span>(std::is_nothrow_copy_constructible_v&lt;Iter&gt; &amp;&amp;</div>
<div class="line">                                                   std::is_nothrow_copy_constructible_v&lt;Func&gt;) = <span class="keywordflow">default</span>;</div>
<div class="line">  <span class="keyword">constexpr</span> MapAdapter(MapAdapter&amp;&amp;) <span class="keyword">noexcept</span>(std::is_nothrow_move_constructible_v&lt;Iter&gt; &amp;&amp;</div>
<div class="line">                                              std::is_nothrow_move_constructible_v&lt;Func&gt;) = <span class="keywordflow">default</span>;</div>
<div class="line">  <span class="keyword">constexpr</span> <a id="a25" name="a25"></a><a class="code hl_function" href="classhelios_1_1utils_1_1MapAdapter.html#a3e1690022a688d934207a0621259882b">~MapAdapter</a>() <span class="keyword">noexcept</span>(std::is_nothrow_destructible_v&lt;Iter&gt; &amp;&amp;</div>
<div class="line">                                   std::is_nothrow_destructible_v&lt;Func&gt;) = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">constexpr</span> MapAdapter&amp; <a id="a26" name="a26"></a><a class="code hl_function" href="classhelios_1_1utils_1_1MapAdapter.html#a7cff97a9de96a084130ed24af4409319">operator=</a>(<span class="keyword">const</span> MapAdapter&amp;) <span class="keyword">noexcept</span>(std::is_nothrow_copy_assignable_v&lt;Iter&gt; &amp;&amp;</div>
<div class="line">                                                              std::is_nothrow_copy_assignable_v&lt;Func&gt;) = <span class="keywordflow">default</span>;</div>
<div class="line">  <span class="keyword">constexpr</span> MapAdapter&amp; <a class="code hl_function" href="classhelios_1_1utils_1_1MapAdapter.html#a7cff97a9de96a084130ed24af4409319">operator=</a>(MapAdapter&amp;&amp;) <span class="keyword">noexcept</span>(std::is_nothrow_move_assignable_v&lt;Iter&gt; &amp;&amp;</div>
<div class="line">                                                         std::is_nothrow_move_assignable_v&lt;Func&gt;) = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">constexpr</span> MapAdapter&amp; <a id="a27" name="a27"></a><a class="code hl_function" href="classhelios_1_1utils_1_1MapAdapter.html#a30fa6004e7156e76a480f1838a64b654">operator++</a>() <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(++std::declval&lt;Iter&amp;&gt;()));</div>
<div class="line">  <span class="keyword">constexpr</span> MapAdapter <a class="code hl_function" href="classhelios_1_1utils_1_1MapAdapter.html#a30fa6004e7156e76a480f1838a64b654">operator++</a>(<span class="keywordtype">int</span>) <span class="keyword">noexcept</span>(std::is_nothrow_copy_constructible_v&lt;MapAdapter&gt; &amp;&amp;</div>
<div class="line">                                                <span class="keyword">noexcept</span>(++std::declval&lt;MapAdapter&amp;&gt;()));</div>
<div class="line"> </div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> <a class="code hl_typedef" href="classhelios_1_1utils_1_1MapAdapter.html#ac79ca7706b38dbd56f55820f630f1fef">value_type</a> <a id="a28" name="a28"></a><a class="code hl_function" href="classhelios_1_1utils_1_1MapAdapter.html#a14e07d6291a03d265feed573a0e37195">operator*</a>() <span class="keyword">const</span></div>
<div class="line">      <span class="keyword">noexcept</span>(std::is_nothrow_invocable_v&lt;Func, std::iter_value_t&lt;Iter&gt;&gt; &amp;&amp; <span class="keyword">noexcept</span>(*std::declval&lt;const Iter&amp;&gt;()));</div>
<div class="line"> </div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> <span class="keywordtype">bool</span> <a id="a29" name="a29"></a><a class="code hl_function" href="classhelios_1_1utils_1_1MapAdapter.html#a732a2342d90afa1725e96224c0c30cbe">operator==</a>(<span class="keyword">const</span> MapAdapter&amp; other) <span class="keyword">const</span></div>
<div class="line">      <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(std::declval&lt;const Iter&amp;&gt;() == std::declval&lt;const Iter&amp;&gt;())) {</div>
<div class="line">    <span class="keywordflow">return</span> current_ == other.current_;</div>
<div class="line">  }</div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> <span class="keywordtype">bool</span> <a id="a30" name="a30"></a><a class="code hl_function" href="classhelios_1_1utils_1_1MapAdapter.html#a67a6df9cf2b25ec20e8001b103ef34e2">operator!=</a>(<span class="keyword">const</span> MapAdapter&amp; other) <span class="keyword">const</span></div>
<div class="line">      <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(std::declval&lt;const MapAdapter&amp;&gt;() == std::declval&lt;const MapAdapter&amp;&gt;())) {</div>
<div class="line">    <span class="keywordflow">return</span> !(*<span class="keyword">this</span> == other);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> MapAdapter <a class="code hl_function" href="classhelios_1_1utils_1_1MapAdapter.html#a626fe4c1b58cc2482e19a5a2d2b95911">begin</a>() <span class="keyword">const</span> <span class="keyword">noexcept</span>(std::is_nothrow_copy_constructible_v&lt;MapAdapter&gt;) {</div>
<div class="line">    <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> MapAdapter <a class="code hl_function" href="classhelios_1_1utils_1_1MapAdapter.html#a1f5443be56805c1bad325498f1652ca9">end</a>() <span class="keyword">const</span></div>
<div class="line">      <span class="keyword">noexcept</span>(std::is_nothrow_constructible_v&lt;MapAdapter, const Iter&amp;, const Iter&amp;, const Func&amp;&gt;) {</div>
<div class="line">    <span class="keywordflow">return</span> {end_, end_, transform_};</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  Iter begin_;      <span class="comment">///&lt; Start of the iterator range</span></div>
<div class="line">  Iter current_;    <span class="comment">///&lt; Current position in the iteration</span></div>
<div class="line">  Iter end_;        <span class="comment">///&lt; End of the iterator range</span></div>
<div class="line">  Func transform_;  <span class="comment">///&lt; Transformation function</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter, <span class="keyword">typename</span> Func&gt;</div>
<div class="line">  <span class="keyword">requires</span> MapAdapterRequirements&lt;Iter, Func&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <a class="code hl_function" href="classhelios_1_1utils_1_1MapAdapter.html#a30fa6004e7156e76a480f1838a64b654">MapAdapter&lt;Iter, Func&gt;::operator++</a>() <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(++std::declval&lt;Iter&amp;&gt;())) -&gt; MapAdapter&amp; {</div>
<div class="line">  ++current_;</div>
<div class="line">  <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter, <span class="keyword">typename</span> Func&gt;</div>
<div class="line">  <span class="keyword">requires</span> MapAdapterRequirements&lt;Iter, Func&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <a class="code hl_function" href="classhelios_1_1utils_1_1MapAdapter.html#a30fa6004e7156e76a480f1838a64b654">MapAdapter&lt;Iter, Func&gt;::operator++</a>(<span class="keywordtype">int</span>) <span class="keyword">noexcept</span>(std::is_nothrow_copy_constructible_v&lt;MapAdapter&gt; &amp;&amp;</div>
<div class="line">                                                                <span class="keyword">noexcept</span>(++std::declval&lt;MapAdapter&amp;&gt;())) -&gt; MapAdapter {</div>
<div class="line">  <span class="keyword">auto</span> temp = *<span class="keyword">this</span>;</div>
<div class="line">  ++(*this);</div>
<div class="line">  <span class="keywordflow">return</span> temp;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter, <span class="keyword">typename</span> Func&gt;</div>
<div class="line">  <span class="keyword">requires</span> MapAdapterRequirements&lt;Iter, Func&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <a class="code hl_function" href="classhelios_1_1utils_1_1MapAdapter.html#a14e07d6291a03d265feed573a0e37195">MapAdapter&lt;Iter, Func&gt;::operator*</a>() <span class="keyword">const</span></div>
<div class="line">    <span class="keyword">noexcept</span>(std::is_nothrow_invocable_v&lt;Func, std::iter_value_t&lt;Iter&gt;&gt; &amp;&amp; <span class="keyword">noexcept</span>(*std::declval&lt;const Iter&amp;&gt;()))</div>
<div class="line">        -&gt; value_type {</div>
<div class="line">  <span class="keyword">auto</span> value = *current_;</div>
<div class="line">  <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (std::invocable&lt;Func, <span class="keyword">decltype</span>(value)&gt;) {</div>
<div class="line">    <span class="keywordflow">return</span> transform_(value);</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="keywordflow">return</span> std::apply(transform_, value);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * @brief Iterator adapter that yields only the first N elements.</span></div>
<div class="line"><span class="comment"> * @details This adapter limits the number of elements yielded by the underlying iterator to at most the specified</span></div>
<div class="line"><span class="comment"> * count. Once the count is reached or the underlying iterator reaches its end, iteration stops.</span></div>
<div class="line"><span class="comment"> * @note This adapter maintains forward iterator semantics.</span></div>
<div class="line"><span class="comment"> * @note The adapter is constexpr-compatible for compile-time evaluation.</span></div>
<div class="line"><span class="comment"> * @tparam Iter Underlying iterator type that satisfies IteratorLike concept</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * @example</span></div>
<div class="line"><span class="comment"> * @code</span></div>
<div class="line"><span class="comment"> * // Get only the first 5 entities</span></div>
<div class="line"><span class="comment"> * auto first_five = query.Take(5);</span></div>
<div class="line"><span class="comment"> * @endcode</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</div>
<div class="line">  <span class="keyword">requires</span> TakeAdapterRequirements&lt;Iter&gt;</div>
<div class="line"><span class="keyword">class </span>TakeAdapter : <span class="keyword">public</span> FunctionalAdapterBase&lt;TakeAdapter&lt;Iter&gt;&gt; {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">using </span><a id="a31" name="a31"></a><a class="code hl_typedef" href="classhelios_1_1utils_1_1TakeAdapter.html#ad13c1668d279b33bd91ed5f2e97bc32e">iterator_category</a> = std::forward_iterator_tag;</div>
<div class="line">  <span class="keyword">using </span><a id="a32" name="a32"></a><a class="code hl_typedef" href="classhelios_1_1utils_1_1TakeAdapter.html#a2def5bf84c73cb4fe6ff910ef393f20f">value_type</a> = std::iter_value_t&lt;Iter&gt;;</div>
<div class="line">  <span class="keyword">using </span><a id="a33" name="a33"></a><a class="code hl_typedef" href="classhelios_1_1utils_1_1TakeAdapter.html#a259b7d121fa995c6a1ce54fadd39c488">difference_type</a> = std::iter_difference_t&lt;Iter&gt;;</div>
<div class="line">  <span class="keyword">using </span><a id="a34" name="a34"></a><a class="code hl_typedef" href="classhelios_1_1utils_1_1TakeAdapter.html#a98fd7e9836ede878cff095dc020868de">pointer</a> = <a class="code hl_typedef" href="classhelios_1_1utils_1_1TakeAdapter.html#a2def5bf84c73cb4fe6ff910ef393f20f">value_type</a>*;</div>
<div class="line">  <span class="keyword">using </span><a id="a35" name="a35"></a><a class="code hl_typedef" href="classhelios_1_1utils_1_1TakeAdapter.html#aae3e2882dea3f84a3763e6232e582798">reference</a> = <a class="code hl_typedef" href="classhelios_1_1utils_1_1TakeAdapter.html#a2def5bf84c73cb4fe6ff910ef393f20f">value_type</a>;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /**</span></div>
<div class="line"><span class="comment">   * @brief Constructs a take adapter with the given iterator range and count.</span></div>
<div class="line"><span class="comment">   * @param begin Start of the iterator range</span></div>
<div class="line"><span class="comment">   * @param end End of the iterator range</span></div>
<div class="line"><span class="comment">   * @param count Maximum number of elements to yield</span></div>
<div class="line"><span class="comment">   */</span></div>
<div class="line">  <span class="keyword">constexpr</span> TakeAdapter(Iter <a id="a36" name="a36"></a><a class="code hl_function" href="classhelios_1_1utils_1_1TakeAdapter.html#a7d8245219a622977cf77fac7923e3f2e">begin</a>, Iter <a id="a37" name="a37"></a><a class="code hl_function" href="classhelios_1_1utils_1_1TakeAdapter.html#a7536a20b6a91dfc45c4154f0b82c374b">end</a>, <span class="keywordtype">size_t</span> count) <span class="keyword">noexcept</span>(std::is_nothrow_move_constructible_v&lt;Iter&gt; &amp;&amp;</div>
<div class="line">                                                                     std::is_nothrow_copy_constructible_v&lt;Iter&gt;)</div>
<div class="line">      : begin_(std::move(<a class="code hl_function" href="classhelios_1_1utils_1_1TakeAdapter.html#a7d8245219a622977cf77fac7923e3f2e">begin</a>)), current_(begin_), end_(std::move(<a class="code hl_function" href="classhelios_1_1utils_1_1TakeAdapter.html#a7536a20b6a91dfc45c4154f0b82c374b">end</a>)), initial_count_(count), remaining_(count) {}</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">constexpr</span> TakeAdapter(<span class="keyword">const</span> TakeAdapter&amp;) <span class="keyword">noexcept</span>(std::is_nothrow_copy_constructible_v&lt;Iter&gt;) = <span class="keywordflow">default</span>;</div>
<div class="line">  <span class="keyword">constexpr</span> TakeAdapter(TakeAdapter&amp;&amp;) <span class="keyword">noexcept</span>(std::is_nothrow_move_constructible_v&lt;Iter&gt;) = <span class="keywordflow">default</span>;</div>
<div class="line">  <span class="keyword">constexpr</span> <a id="a38" name="a38"></a><a class="code hl_function" href="classhelios_1_1utils_1_1TakeAdapter.html#af2f8c99e1d8d2f95eccac0a87c583702">~TakeAdapter</a>() <span class="keyword">noexcept</span>(std::is_nothrow_destructible_v&lt;Iter&gt;) = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">constexpr</span> TakeAdapter&amp; <a id="a39" name="a39"></a><a class="code hl_function" href="classhelios_1_1utils_1_1TakeAdapter.html#acda8cc32780d47afc297d2200df065a1">operator=</a>(<span class="keyword">const</span> TakeAdapter&amp;) <span class="keyword">noexcept</span>(std::is_nothrow_copy_assignable_v&lt;Iter&gt;) = <span class="keywordflow">default</span>;</div>
<div class="line">  <span class="keyword">constexpr</span> TakeAdapter&amp; <a class="code hl_function" href="classhelios_1_1utils_1_1TakeAdapter.html#acda8cc32780d47afc297d2200df065a1">operator=</a>(TakeAdapter&amp;&amp;) <span class="keyword">noexcept</span>(std::is_nothrow_move_assignable_v&lt;Iter&gt;) = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">constexpr</span> TakeAdapter&amp; <a id="a40" name="a40"></a><a class="code hl_function" href="classhelios_1_1utils_1_1TakeAdapter.html#a21eb39cf813e5380baffc34d95a68f24">operator++</a>() <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(++std::declval&lt;Iter&amp;&gt;()));</div>
<div class="line">  <span class="keyword">constexpr</span> TakeAdapter <a class="code hl_function" href="classhelios_1_1utils_1_1TakeAdapter.html#a21eb39cf813e5380baffc34d95a68f24">operator++</a>(<span class="keywordtype">int</span>) <span class="keyword">noexcept</span>(std::is_nothrow_copy_constructible_v&lt;TakeAdapter&gt; &amp;&amp;</div>
<div class="line">                                                 <span class="keyword">noexcept</span>(++std::declval&lt;TakeAdapter&amp;&gt;()));</div>
<div class="line"> </div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> <a class="code hl_typedef" href="classhelios_1_1utils_1_1TakeAdapter.html#a2def5bf84c73cb4fe6ff910ef393f20f">value_type</a> <a id="a41" name="a41"></a><a class="code hl_function" href="classhelios_1_1utils_1_1TakeAdapter.html#a471e5397abd6fcb37fb1634475106152">operator*</a>() <span class="keyword">const</span> <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(*std::declval&lt;const Iter&amp;&gt;())) {</div>
<div class="line">    <span class="keywordflow">return</span> *current_;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> <span class="keywordtype">bool</span> <a id="a42" name="a42"></a><a class="code hl_function" href="classhelios_1_1utils_1_1TakeAdapter.html#ab9f032798cbd1b9eb939c0b9d30e2172">operator==</a>(<span class="keyword">const</span> TakeAdapter&amp; other) <span class="keyword">const</span></div>
<div class="line">      <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(std::declval&lt;const Iter&amp;&gt;() == std::declval&lt;const Iter&amp;&gt;()));</div>
<div class="line"> </div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> <span class="keywordtype">bool</span> <a id="a43" name="a43"></a><a class="code hl_function" href="classhelios_1_1utils_1_1TakeAdapter.html#a10bdc858f5fbed1bfdc6155e2ed5717d">operator!=</a>(<span class="keyword">const</span> TakeAdapter&amp; other) <span class="keyword">const</span></div>
<div class="line">      <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(std::declval&lt;const TakeAdapter&amp;&gt;() == std::declval&lt;const TakeAdapter&amp;&gt;())) {</div>
<div class="line">    <span class="keywordflow">return</span> !(*<span class="keyword">this</span> == other);</div>
<div class="line">  }</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /**</span></div>
<div class="line"><span class="comment">   * @brief Checks if the iterator has reached the end.</span></div>
<div class="line"><span class="comment">   * @return True if at end, false otherwise</span></div>
<div class="line"><span class="comment">   */</span></div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> <span class="keywordtype">bool</span> <a id="a44" name="a44"></a><a class="code hl_function" href="classhelios_1_1utils_1_1TakeAdapter.html#af5bca984b4a9d4380d6e9181b1e5ea39">IsAtEnd</a>() <span class="keyword">const</span></div>
<div class="line">      <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(std::declval&lt;const Iter&amp;&gt;() == std::declval&lt;const Iter&amp;&gt;())) {</div>
<div class="line">    <span class="keywordflow">return</span> remaining_ == 0 || current_ == end_;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> TakeAdapter <a class="code hl_function" href="classhelios_1_1utils_1_1TakeAdapter.html#a7d8245219a622977cf77fac7923e3f2e">begin</a>() <span class="keyword">const</span> <span class="keyword">noexcept</span>(std::is_nothrow_copy_constructible_v&lt;TakeAdapter&gt;) {</div>
<div class="line">    <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> TakeAdapter <a class="code hl_function" href="classhelios_1_1utils_1_1TakeAdapter.html#a7536a20b6a91dfc45c4154f0b82c374b">end</a>() <span class="keyword">const</span> <span class="keyword">noexcept</span>(std::is_nothrow_copy_constructible_v&lt;TakeAdapter&gt;);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  Iter begin_;                <span class="comment">///&lt; Start of the iterator range</span></div>
<div class="line">  Iter current_;              <span class="comment">///&lt; Current position in the iteration</span></div>
<div class="line">  Iter end_;                  <span class="comment">///&lt; End of the iterator range</span></div>
<div class="line">  <span class="keywordtype">size_t</span> initial_count_ = 0;  <span class="comment">///&lt; Initial count limit</span></div>
<div class="line">  <span class="keywordtype">size_t</span> remaining_ = 0;      <span class="comment">///&lt; Remaining elements to yield</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</div>
<div class="line">  <span class="keyword">requires</span> TakeAdapterRequirements&lt;Iter&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <a class="code hl_function" href="classhelios_1_1utils_1_1TakeAdapter.html#a21eb39cf813e5380baffc34d95a68f24">TakeAdapter&lt;Iter&gt;::operator++</a>() <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(++std::declval&lt;Iter&amp;&gt;())) -&gt; TakeAdapter&amp; {</div>
<div class="line">  <span class="keywordflow">if</span> (remaining_ &gt; 0 &amp;&amp; current_ != end_) {</div>
<div class="line">    ++current_;</div>
<div class="line">    --remaining_;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</div>
<div class="line">  <span class="keyword">requires</span> TakeAdapterRequirements&lt;Iter&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <a class="code hl_function" href="classhelios_1_1utils_1_1TakeAdapter.html#a21eb39cf813e5380baffc34d95a68f24">TakeAdapter&lt;Iter&gt;::operator++</a>(<span class="keywordtype">int</span>) <span class="keyword">noexcept</span>(std::is_nothrow_copy_constructible_v&lt;TakeAdapter&gt; &amp;&amp;</div>
<div class="line">                                                           <span class="keyword">noexcept</span>(++std::declval&lt;TakeAdapter&amp;&gt;())) -&gt; TakeAdapter {</div>
<div class="line">  <span class="keyword">auto</span> temp = *<span class="keyword">this</span>;</div>
<div class="line">  ++(*this);</div>
<div class="line">  <span class="keywordflow">return</span> temp;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</div>
<div class="line">  <span class="keyword">requires</span> TakeAdapterRequirements&lt;Iter&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keywordtype">bool</span> <a class="code hl_function" href="classhelios_1_1utils_1_1TakeAdapter.html#ab9f032798cbd1b9eb939c0b9d30e2172">TakeAdapter&lt;Iter&gt;::operator==</a>(<span class="keyword">const</span> TakeAdapter&amp; other) <span class="keyword">const</span></div>
<div class="line">    <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(std::declval&lt;const Iter&amp;&gt;() == std::declval&lt;const Iter&amp;&gt;())) {</div>
<div class="line">  <span class="comment">// Both are at end if either has no remaining elements or both iterators are at end</span></div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">bool</span> this_at_end = (remaining_ == 0) || (current_ == end_);</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">bool</span> other_at_end = (other.remaining_ == 0) || (other.current_ == other.end_);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (this_at_end &amp;&amp; other_at_end) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> (current_ == other.current_) &amp;&amp; (remaining_ == other.remaining_);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</div>
<div class="line">  <span class="keyword">requires</span> TakeAdapterRequirements&lt;Iter&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <a class="code hl_function" href="classhelios_1_1utils_1_1TakeAdapter.html#a7536a20b6a91dfc45c4154f0b82c374b">TakeAdapter&lt;Iter&gt;::end</a>() <span class="keyword">const</span> <span class="keyword">noexcept</span>(std::is_nothrow_copy_constructible_v&lt;TakeAdapter&gt;)</div>
<div class="line">    -&gt; TakeAdapter {</div>
<div class="line">  <span class="keyword">auto</span> end_iter = *<span class="keyword">this</span>;</div>
<div class="line">  end_iter.<a id="a45" name="a45"></a>remaining_ = 0;</div>
<div class="line">  <span class="keywordflow">return</span> end_iter;</div>
<div class="line">}</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * @brief Iterator adapter that skips the first N elements.</span></div>
<div class="line"><span class="comment"> * @details This adapter skips over the first N elements of the underlying iterator and yields all remaining elements.</span></div>
<div class="line"><span class="comment"> * If the iterator has fewer than N elements, the result will be empty.</span></div>
<div class="line"><span class="comment"> * @note This adapter maintains forward iterator semantics.</span></div>
<div class="line"><span class="comment"> * @note The adapter is constexpr-compatible for compile-time evaluation.</span></div>
<div class="line"><span class="comment"> * @tparam Iter Underlying iterator type that satisfies IteratorLike concept</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * @example</span></div>
<div class="line"><span class="comment"> * @code</span></div>
<div class="line"><span class="comment"> * // Skip the first 10 entities</span></div>
<div class="line"><span class="comment"> * auto remaining = query.Skip(10);</span></div>
<div class="line"><span class="comment"> * @endcode</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</div>
<div class="line">  <span class="keyword">requires</span> SkipAdapterRequirements&lt;Iter&gt;</div>
<div class="line"><span class="keyword">class </span>SkipAdapter : <span class="keyword">public</span> FunctionalAdapterBase&lt;SkipAdapter&lt;Iter&gt;&gt; {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">using </span><a id="a46" name="a46"></a><a class="code hl_typedef" href="classhelios_1_1utils_1_1SkipAdapter.html#ae172b0dd64fcd7d224d19de0d7cae77e">iterator_category</a> = std::forward_iterator_tag;</div>
<div class="line">  <span class="keyword">using </span><a id="a47" name="a47"></a><a class="code hl_typedef" href="classhelios_1_1utils_1_1SkipAdapter.html#a44f2f2d4f79d2bff8ddfb364e45389e9">value_type</a> = std::iter_value_t&lt;Iter&gt;;</div>
<div class="line">  <span class="keyword">using </span><a id="a48" name="a48"></a><a class="code hl_typedef" href="classhelios_1_1utils_1_1SkipAdapter.html#ac46529f22b76314fff13f085845d935f">difference_type</a> = std::iter_difference_t&lt;Iter&gt;;</div>
<div class="line">  <span class="keyword">using </span><a id="a49" name="a49"></a><a class="code hl_typedef" href="classhelios_1_1utils_1_1SkipAdapter.html#a138e1ea5882b9fba027351de4c636f05">pointer</a> = <a class="code hl_typedef" href="classhelios_1_1utils_1_1SkipAdapter.html#a44f2f2d4f79d2bff8ddfb364e45389e9">value_type</a>*;</div>
<div class="line">  <span class="keyword">using </span><a id="a50" name="a50"></a><a class="code hl_typedef" href="classhelios_1_1utils_1_1SkipAdapter.html#a2e87e6ceef39a694bbb2b85220a189b6">reference</a> = <a class="code hl_typedef" href="classhelios_1_1utils_1_1SkipAdapter.html#a44f2f2d4f79d2bff8ddfb364e45389e9">value_type</a>;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /**</span></div>
<div class="line"><span class="comment">   * @brief Constructs a skip adapter with the given iterator range and count.</span></div>
<div class="line"><span class="comment">   * @param begin Start of the iterator range</span></div>
<div class="line"><span class="comment">   * @param end End of the iterator range</span></div>
<div class="line"><span class="comment">   * @param count Number of elements to skip</span></div>
<div class="line"><span class="comment">   */</span></div>
<div class="line">  <span class="keyword">constexpr</span> SkipAdapter(Iter <a id="a51" name="a51"></a><a class="code hl_function" href="classhelios_1_1utils_1_1SkipAdapter.html#ab34f9f96cfbcc6a1e7ac8e5afb7c9c28">begin</a>, Iter <a id="a52" name="a52"></a><a class="code hl_function" href="classhelios_1_1utils_1_1SkipAdapter.html#a73fd6df2a9a8962ec26660faf30cffa5">end</a>, <span class="keywordtype">size_t</span> count) <span class="keyword">noexcept</span>(std::is_nothrow_move_constructible_v&lt;Iter&gt; &amp;&amp;</div>
<div class="line">                                                                     <span class="keyword">noexcept</span>(++std::declval&lt;Iter&amp;&gt;()));</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">constexpr</span> SkipAdapter(<span class="keyword">const</span> SkipAdapter&amp;) <span class="keyword">noexcept</span>(std::is_nothrow_copy_constructible_v&lt;Iter&gt;) = <span class="keywordflow">default</span>;</div>
<div class="line">  <span class="keyword">constexpr</span> SkipAdapter(SkipAdapter&amp;&amp;) <span class="keyword">noexcept</span>(std::is_nothrow_move_constructible_v&lt;Iter&gt;) = <span class="keywordflow">default</span>;</div>
<div class="line">  <span class="keyword">constexpr</span> <a id="a53" name="a53"></a><a class="code hl_function" href="classhelios_1_1utils_1_1SkipAdapter.html#a643008a71385ef5915f973fae16993db">~SkipAdapter</a>() <span class="keyword">noexcept</span>(std::is_nothrow_destructible_v&lt;Iter&gt;) = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">constexpr</span> SkipAdapter&amp; <a id="a54" name="a54"></a><a class="code hl_function" href="classhelios_1_1utils_1_1SkipAdapter.html#a8ed6a07d0fac605701381ad6bb17a015">operator=</a>(<span class="keyword">const</span> SkipAdapter&amp;) <span class="keyword">noexcept</span>(std::is_nothrow_copy_assignable_v&lt;Iter&gt;) = <span class="keywordflow">default</span>;</div>
<div class="line">  <span class="keyword">constexpr</span> SkipAdapter&amp; <a class="code hl_function" href="classhelios_1_1utils_1_1SkipAdapter.html#a8ed6a07d0fac605701381ad6bb17a015">operator=</a>(SkipAdapter&amp;&amp;) <span class="keyword">noexcept</span>(std::is_nothrow_move_assignable_v&lt;Iter&gt;) = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">constexpr</span> SkipAdapter&amp; <a id="a55" name="a55"></a><a class="code hl_function" href="classhelios_1_1utils_1_1SkipAdapter.html#a269254f65f371b48cf8d0b56d11624d3">operator++</a>() <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(++std::declval&lt;Iter&amp;&gt;()));</div>
<div class="line">  <span class="keyword">constexpr</span> SkipAdapter <a class="code hl_function" href="classhelios_1_1utils_1_1SkipAdapter.html#a269254f65f371b48cf8d0b56d11624d3">operator++</a>(<span class="keywordtype">int</span>) <span class="keyword">noexcept</span>(std::is_nothrow_copy_constructible_v&lt;SkipAdapter&gt; &amp;&amp;</div>
<div class="line">                                                 <span class="keyword">noexcept</span>(++std::declval&lt;SkipAdapter&amp;&gt;()));</div>
<div class="line"> </div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> <a class="code hl_typedef" href="classhelios_1_1utils_1_1SkipAdapter.html#a44f2f2d4f79d2bff8ddfb364e45389e9">value_type</a> <a id="a56" name="a56"></a><a class="code hl_function" href="classhelios_1_1utils_1_1SkipAdapter.html#a285c7658b49122aa7ef1aafa9e45c12f">operator*</a>() <span class="keyword">const</span> <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(*std::declval&lt;const Iter&amp;&gt;())) {</div>
<div class="line">    <span class="keywordflow">return</span> *current_;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> <span class="keywordtype">bool</span> <a id="a57" name="a57"></a><a class="code hl_function" href="classhelios_1_1utils_1_1SkipAdapter.html#ac87ad9b75c3ebb745664b4c4905ef948">operator==</a>(<span class="keyword">const</span> SkipAdapter&amp; other) <span class="keyword">const</span></div>
<div class="line">      <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(std::declval&lt;const Iter&amp;&gt;() == std::declval&lt;const Iter&amp;&gt;())) {</div>
<div class="line">    <span class="keywordflow">return</span> current_ == other.current_;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> <span class="keywordtype">bool</span> <a id="a58" name="a58"></a><a class="code hl_function" href="classhelios_1_1utils_1_1SkipAdapter.html#ae3ce733cca77446589bedd354036ec95">operator!=</a>(<span class="keyword">const</span> SkipAdapter&amp; other) <span class="keyword">const</span></div>
<div class="line">      <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(std::declval&lt;const SkipAdapter&amp;&gt;() == std::declval&lt;const SkipAdapter&amp;&gt;())) {</div>
<div class="line">    <span class="keywordflow">return</span> !(*<span class="keyword">this</span> == other);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> SkipAdapter <a class="code hl_function" href="classhelios_1_1utils_1_1SkipAdapter.html#ab34f9f96cfbcc6a1e7ac8e5afb7c9c28">begin</a>() <span class="keyword">const</span> <span class="keyword">noexcept</span>(std::is_nothrow_copy_constructible_v&lt;SkipAdapter&gt;) {</div>
<div class="line">    <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> SkipAdapter <a class="code hl_function" href="classhelios_1_1utils_1_1SkipAdapter.html#a73fd6df2a9a8962ec26660faf30cffa5">end</a>() <span class="keyword">const</span></div>
<div class="line">      <span class="keyword">noexcept</span>(std::is_nothrow_constructible_v&lt;SkipAdapter, const Iter&amp;, const Iter&amp;, size_t&gt;) {</div>
<div class="line">    <span class="keywordflow">return</span> {end_, end_, 0};</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  Iter current_;  <span class="comment">///&lt; Current position in the iteration</span></div>
<div class="line">  Iter end_;      <span class="comment">///&lt; End of the iterator range</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</div>
<div class="line">  <span class="keyword">requires</span> SkipAdapterRequirements&lt;Iter&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <a id="a59" name="a59"></a><a class="code hl_function" href="classhelios_1_1utils_1_1SkipAdapter.html#aa058c013be0f7859c9bd222069ff3822">SkipAdapter&lt;Iter&gt;::SkipAdapter</a>(Iter begin, Iter end,</div>
<div class="line">                                         <span class="keywordtype">size_t</span> count) <span class="keyword">noexcept</span>(std::is_nothrow_move_constructible_v&lt;Iter&gt; &amp;&amp;</div>
<div class="line">                                                                <span class="keyword">noexcept</span>(++std::declval&lt;Iter&amp;&gt;()))</div>
<div class="line">    : current_(std::move(begin)), end_(std::move(end)) {</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> idx = 0; idx &lt; count &amp;&amp; current_ != end_; ++idx) {</div>
<div class="line">    ++current_;</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</div>
<div class="line">  <span class="keyword">requires</span> SkipAdapterRequirements&lt;Iter&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <a class="code hl_function" href="classhelios_1_1utils_1_1SkipAdapter.html#a269254f65f371b48cf8d0b56d11624d3">SkipAdapter&lt;Iter&gt;::operator++</a>() <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(++std::declval&lt;Iter&amp;&gt;())) -&gt; SkipAdapter&amp; {</div>
<div class="line">  ++current_;</div>
<div class="line">  <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</div>
<div class="line">  <span class="keyword">requires</span> SkipAdapterRequirements&lt;Iter&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <a class="code hl_function" href="classhelios_1_1utils_1_1SkipAdapter.html#a269254f65f371b48cf8d0b56d11624d3">SkipAdapter&lt;Iter&gt;::operator++</a>(<span class="keywordtype">int</span>) <span class="keyword">noexcept</span>(std::is_nothrow_copy_constructible_v&lt;SkipAdapter&gt; &amp;&amp;</div>
<div class="line">                                                           <span class="keyword">noexcept</span>(++std::declval&lt;SkipAdapter&amp;&gt;())) -&gt; SkipAdapter {</div>
<div class="line">  <span class="keyword">auto</span> temp = *<span class="keyword">this</span>;</div>
<div class="line">  ++(*this);</div>
<div class="line">  <span class="keywordflow">return</span> temp;</div>
<div class="line">}</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * @brief Iterator adapter that takes elements while a predicate returns true.</span></div>
<div class="line"><span class="comment"> * @details This adapter yields elements as long as the predicate returns true.</span></div>
<div class="line"><span class="comment"> * Once the predicate returns false, no more elements are yielded.</span></div>
<div class="line"><span class="comment"> * @tparam Iter Underlying iterator type</span></div>
<div class="line"><span class="comment"> * @tparam Pred Predicate function type</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * @example</span></div>
<div class="line"><span class="comment"> * @code</span></div>
<div class="line"><span class="comment"> * // Take entities while their health is above zero</span></div>
<div class="line"><span class="comment"> * auto alive_entities = query.TakeWhile([](const Health&amp; h) { return h.points &gt; 0; });</span></div>
<div class="line"><span class="comment"> * @endcode</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter, <span class="keyword">typename</span> Pred&gt;</div>
<div class="line">  <span class="keyword">requires</span> TakeWhileAdapterRequirements&lt;Iter, Pred&gt;</div>
<div class="line"><span class="keyword">class </span>TakeWhileAdapter : <span class="keyword">public</span> FunctionalAdapterBase&lt;TakeWhileAdapter&lt;Iter, Pred&gt;&gt; {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">using </span><a id="a60" name="a60"></a><a class="code hl_typedef" href="classhelios_1_1utils_1_1TakeWhileAdapter.html#af15d177631313af48b105eda93a0a647">iterator_category</a> = std::forward_iterator_tag;</div>
<div class="line">  <span class="keyword">using </span><a id="a61" name="a61"></a><a class="code hl_typedef" href="classhelios_1_1utils_1_1TakeWhileAdapter.html#a9d828eb901cfaed8714aa12b49cdac0a">value_type</a> = std::iter_value_t&lt;Iter&gt;;</div>
<div class="line">  <span class="keyword">using </span><a id="a62" name="a62"></a><a class="code hl_typedef" href="classhelios_1_1utils_1_1TakeWhileAdapter.html#ab3a0402aa853b20b8487fef5fe29e03d">difference_type</a> = std::iter_difference_t&lt;Iter&gt;;</div>
<div class="line">  <span class="keyword">using </span><a id="a63" name="a63"></a><a class="code hl_typedef" href="classhelios_1_1utils_1_1TakeWhileAdapter.html#a4c3be5c86183e2f8a9261be882df4ab5">pointer</a> = <a class="code hl_typedef" href="classhelios_1_1utils_1_1TakeWhileAdapter.html#a9d828eb901cfaed8714aa12b49cdac0a">value_type</a>*;</div>
<div class="line">  <span class="keyword">using </span><a id="a64" name="a64"></a><a class="code hl_typedef" href="classhelios_1_1utils_1_1TakeWhileAdapter.html#aae90d9270614a1d71af71d248f4d017d">reference</a> = <a class="code hl_typedef" href="classhelios_1_1utils_1_1TakeWhileAdapter.html#a9d828eb901cfaed8714aa12b49cdac0a">value_type</a>;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /**</span></div>
<div class="line"><span class="comment">   * @brief Constructs a take-while adapter with the given iterator range and predicate.</span></div>
<div class="line"><span class="comment">   * @param begin Start of the iterator range</span></div>
<div class="line"><span class="comment">   * @param end End of the iterator range</span></div>
<div class="line"><span class="comment">   * @param predicate Function to test elements</span></div>
<div class="line"><span class="comment">   */</span></div>
<div class="line">  <span class="keyword">constexpr</span> TakeWhileAdapter(Iter <a id="a65" name="a65"></a><a class="code hl_function" href="classhelios_1_1utils_1_1TakeWhileAdapter.html#a72bb354d27dd31d4838667afb174b50c">begin</a>, Iter <a id="a66" name="a66"></a><a class="code hl_function" href="classhelios_1_1utils_1_1TakeWhileAdapter.html#a0c0a65ae9b0920654fa77cd4bc11418f">end</a>,</div>
<div class="line">                             Pred predicate) <span class="keyword">noexcept</span>(std::is_nothrow_move_constructible_v&lt;Iter&gt; &amp;&amp;</div>
<div class="line">                                                      std::is_nothrow_copy_constructible_v&lt;Iter&gt; &amp;&amp;</div>
<div class="line">                                                      std::is_nothrow_move_constructible_v&lt;Pred&gt; &amp;&amp;</div>
<div class="line">                                                      <span class="keyword">noexcept</span>(CheckPredicate()))</div>
<div class="line">      : begin_(std::move(<a class="code hl_function" href="classhelios_1_1utils_1_1TakeWhileAdapter.html#a72bb354d27dd31d4838667afb174b50c">begin</a>)), current_(begin_), end_(std::move(<a class="code hl_function" href="classhelios_1_1utils_1_1TakeWhileAdapter.html#a0c0a65ae9b0920654fa77cd4bc11418f">end</a>)), predicate_(std::move(predicate)) {</div>
<div class="line">    CheckPredicate();</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">constexpr</span> TakeWhileAdapter(<span class="keyword">const</span> TakeWhileAdapter&amp;) <span class="keyword">noexcept</span>(std::is_nothrow_copy_constructible_v&lt;Iter&gt; &amp;&amp;</div>
<div class="line">                                                               std::is_nothrow_copy_constructible_v&lt;Pred&gt;) = <span class="keywordflow">default</span>;</div>
<div class="line">  <span class="keyword">constexpr</span> TakeWhileAdapter(TakeWhileAdapter&amp;&amp;) <span class="keyword">noexcept</span>(std::is_nothrow_move_constructible_v&lt;Iter&gt; &amp;&amp;</div>
<div class="line">                                                          std::is_nothrow_move_constructible_v&lt;Pred&gt;) = <span class="keywordflow">default</span>;</div>
<div class="line">  <span class="keyword">constexpr</span> <a id="a67" name="a67"></a><a class="code hl_function" href="classhelios_1_1utils_1_1TakeWhileAdapter.html#a516a1779b05742927fa3071a7dad9a21">~TakeWhileAdapter</a>() <span class="keyword">noexcept</span>(std::is_nothrow_destructible_v&lt;Iter&gt; &amp;&amp;</div>
<div class="line">                                         std::is_nothrow_destructible_v&lt;Pred&gt;) = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">constexpr</span> TakeWhileAdapter&amp; <a id="a68" name="a68"></a><a class="code hl_function" href="classhelios_1_1utils_1_1TakeWhileAdapter.html#a836ca84d59c9078ce9b4fb770ea6b359">operator=</a>(<span class="keyword">const</span> TakeWhileAdapter&amp;) <span class="keyword">noexcept</span>(</div>
<div class="line">      std::is_nothrow_copy_assignable_v&lt;Iter&gt; &amp;&amp; std::is_nothrow_copy_assignable_v&lt;Pred&gt;) = <span class="keywordflow">default</span>;</div>
<div class="line">  <span class="keyword">constexpr</span> TakeWhileAdapter&amp; <a class="code hl_function" href="classhelios_1_1utils_1_1TakeWhileAdapter.html#a836ca84d59c9078ce9b4fb770ea6b359">operator=</a>(TakeWhileAdapter&amp;&amp;) <span class="keyword">noexcept</span>(std::is_nothrow_move_assignable_v&lt;Iter&gt; &amp;&amp;</div>
<div class="line">                                                                     std::is_nothrow_move_assignable_v&lt;Pred&gt;) = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">constexpr</span> TakeWhileAdapter&amp; <a id="a69" name="a69"></a><a class="code hl_function" href="classhelios_1_1utils_1_1TakeWhileAdapter.html#ade9c798e00b49ed10bccc9d3963912f3">operator++</a>() <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(++std::declval&lt;Iter&amp;&gt;()) &amp;&amp;</div>
<div class="line">                                                    <span class="keyword">noexcept</span>(std::declval&lt;Iter&amp;&gt;() != std::declval&lt;Iter&amp;&gt;()) &amp;&amp;</div>
<div class="line">                                                    <span class="keyword">noexcept</span>(CheckPredicate()));</div>
<div class="line">  <span class="keyword">constexpr</span> TakeWhileAdapter <a class="code hl_function" href="classhelios_1_1utils_1_1TakeWhileAdapter.html#ade9c798e00b49ed10bccc9d3963912f3">operator++</a>(<span class="keywordtype">int</span>) <span class="keyword">noexcept</span>(std::is_nothrow_copy_constructible_v&lt;TakeWhileAdapter&gt; &amp;&amp;</div>
<div class="line">                                                      <span class="keyword">noexcept</span>(++std::declval&lt;TakeWhileAdapter&amp;&gt;()));</div>
<div class="line"> </div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> <a class="code hl_typedef" href="classhelios_1_1utils_1_1TakeWhileAdapter.html#a9d828eb901cfaed8714aa12b49cdac0a">value_type</a> <a id="a70" name="a70"></a><a class="code hl_function" href="classhelios_1_1utils_1_1TakeWhileAdapter.html#a59749300ed13ca803c21b28ee8c10d57">operator*</a>() <span class="keyword">const</span> <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(*std::declval&lt;const Iter&amp;&gt;())) {</div>
<div class="line">    <span class="keywordflow">return</span> *current_;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> <span class="keywordtype">bool</span> <a id="a71" name="a71"></a><a class="code hl_function" href="classhelios_1_1utils_1_1TakeWhileAdapter.html#a4536d72a493b8274958a7133f61d0c50">operator==</a>(<span class="keyword">const</span> TakeWhileAdapter&amp; other) <span class="keyword">const</span></div>
<div class="line">      <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(std::declval&lt;const Iter&amp;&gt;() == std::declval&lt;const Iter&amp;&gt;())) {</div>
<div class="line">    <span class="keywordflow">return</span> (stopped_ &amp;&amp; other.stopped_) || (current_ == other.current_ &amp;&amp; stopped_ == other.stopped_);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> <span class="keywordtype">bool</span> <a id="a72" name="a72"></a><a class="code hl_function" href="classhelios_1_1utils_1_1TakeWhileAdapter.html#a8e1e8b1972638942a84eb4cdaa707f75">operator!=</a>(<span class="keyword">const</span> TakeWhileAdapter&amp; other) <span class="keyword">const</span></div>
<div class="line">      <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(std::declval&lt;const TakeWhileAdapter&amp;&gt;() == std::declval&lt;const TakeWhileAdapter&amp;&gt;())) {</div>
<div class="line">    <span class="keywordflow">return</span> !(*<span class="keyword">this</span> == other);</div>
<div class="line">  }</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /**</span></div>
<div class="line"><span class="comment">   * @brief Checks if the iterator has reached the end.</span></div>
<div class="line"><span class="comment">   * @return True if at end, false otherwise</span></div>
<div class="line"><span class="comment">   */</span></div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> <span class="keywordtype">bool</span> <a id="a73" name="a73"></a><a class="code hl_function" href="classhelios_1_1utils_1_1TakeWhileAdapter.html#a5e1923f3d0347b83fe115fe16f7098b0">IsAtEnd</a>() <span class="keyword">const</span></div>
<div class="line">      <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(std::declval&lt;const Iter&amp;&gt;() == std::declval&lt;const Iter&amp;&gt;())) {</div>
<div class="line">    <span class="keywordflow">return</span> stopped_ || current_ == end_;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> TakeWhileAdapter <a class="code hl_function" href="classhelios_1_1utils_1_1TakeWhileAdapter.html#a72bb354d27dd31d4838667afb174b50c">begin</a>() <span class="keyword">const</span></div>
<div class="line">      <span class="keyword">noexcept</span>(std::is_nothrow_copy_constructible_v&lt;TakeWhileAdapter&gt;) {</div>
<div class="line">    <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> TakeWhileAdapter <a class="code hl_function" href="classhelios_1_1utils_1_1TakeWhileAdapter.html#a0c0a65ae9b0920654fa77cd4bc11418f">end</a>() <span class="keyword">const</span> <span class="keyword">noexcept</span>(std::is_nothrow_copy_constructible_v&lt;TakeWhileAdapter&gt;);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keyword">constexpr</span> <span class="keywordtype">void</span> CheckPredicate() <span class="keyword">noexcept</span>(std::is_nothrow_invocable_v&lt;Pred, std::iter_value_t&lt;Iter&gt;&gt; &amp;&amp;</div>
<div class="line">                                           <span class="keyword">noexcept</span>(std::declval&lt;Iter&amp;&gt;() == std::declval&lt;Iter&amp;&gt;()) &amp;&amp;</div>
<div class="line">                                           <span class="keyword">noexcept</span>(*std::declval&lt;Iter&amp;&gt;()));</div>
<div class="line"> </div>
<div class="line">  Iter begin_;            <span class="comment">///&lt; Start of the iterator range</span></div>
<div class="line">  Iter current_;          <span class="comment">///&lt; Current position in the iteration</span></div>
<div class="line">  Iter end_;              <span class="comment">///&lt; End of the iterator range</span></div>
<div class="line">  Pred predicate_;        <span class="comment">///&lt; Predicate function</span></div>
<div class="line">  <span class="keywordtype">bool</span> stopped_ = <span class="keyword">false</span>;  <span class="comment">///&lt; Whether predicate has failed</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter, <span class="keyword">typename</span> Pred&gt;</div>
<div class="line">  <span class="keyword">requires</span> TakeWhileAdapterRequirements&lt;Iter, Pred&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <a class="code hl_function" href="classhelios_1_1utils_1_1TakeWhileAdapter.html#ade9c798e00b49ed10bccc9d3963912f3">TakeWhileAdapter&lt;Iter, Pred&gt;::operator++</a>() <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(++std::declval&lt;Iter&amp;&gt;()) &amp;&amp;</div>
<div class="line">                                                                   <span class="keyword">noexcept</span>(std::declval&lt;Iter&amp;&gt;() !=</div>
<div class="line">                                                                            std::declval&lt;Iter&amp;&gt;()) &amp;&amp;</div>
<div class="line">                                                                   <span class="keyword">noexcept</span>(CheckPredicate())) -&gt; TakeWhileAdapter&amp; {</div>
<div class="line">  <span class="keywordflow">if</span> (!stopped_ &amp;&amp; current_ != end_) {</div>
<div class="line">    ++current_;</div>
<div class="line">    CheckPredicate();</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter, <span class="keyword">typename</span> Pred&gt;</div>
<div class="line">  <span class="keyword">requires</span> TakeWhileAdapterRequirements&lt;Iter, Pred&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <a class="code hl_function" href="classhelios_1_1utils_1_1TakeWhileAdapter.html#ade9c798e00b49ed10bccc9d3963912f3">TakeWhileAdapter&lt;Iter, Pred&gt;::operator++</a>(<span class="keywordtype">int</span>) <span class="keyword">noexcept</span>(</div>
<div class="line">    std::is_nothrow_copy_constructible_v&lt;TakeWhileAdapter&gt; &amp;&amp; <span class="keyword">noexcept</span>(++std::declval&lt;TakeWhileAdapter&amp;&gt;()))</div>
<div class="line">    -&gt; TakeWhileAdapter {</div>
<div class="line">  <span class="keyword">auto</span> temp = *<span class="keyword">this</span>;</div>
<div class="line">  ++(*this);</div>
<div class="line">  <span class="keywordflow">return</span> temp;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter, <span class="keyword">typename</span> Pred&gt;</div>
<div class="line">  <span class="keyword">requires</span> TakeWhileAdapterRequirements&lt;Iter, Pred&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <a class="code hl_function" href="classhelios_1_1utils_1_1TakeWhileAdapter.html#a0c0a65ae9b0920654fa77cd4bc11418f">TakeWhileAdapter&lt;Iter, Pred&gt;::end</a>() <span class="keyword">const</span></div>
<div class="line">    <span class="keyword">noexcept</span>(std::is_nothrow_copy_constructible_v&lt;TakeWhileAdapter&gt;) -&gt; TakeWhileAdapter {</div>
<div class="line">  <span class="keyword">auto</span> end_iter = *<span class="keyword">this</span>;</div>
<div class="line">  end_iter.<a id="a74" name="a74"></a>stopped_ = <span class="keyword">true</span>;</div>
<div class="line">  <span class="keywordflow">return</span> end_iter;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter, <span class="keyword">typename</span> Pred&gt;</div>
<div class="line">  <span class="keyword">requires</span> TakeWhileAdapterRequirements&lt;Iter, Pred&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keywordtype">void</span> TakeWhileAdapter&lt;Iter, Pred&gt;::CheckPredicate() <span class="keyword">noexcept</span>(</div>
<div class="line">    std::is_nothrow_invocable_v&lt;Pred, std::iter_value_t&lt;Iter&gt;&gt; &amp;&amp;</div>
<div class="line">    <span class="keyword">noexcept</span>(std::declval&lt;Iter&amp;&gt;() == std::declval&lt;Iter&amp;&gt;()) &amp;&amp; <span class="keyword">noexcept</span>(*std::declval&lt;Iter&amp;&gt;())) {</div>
<div class="line">  <span class="keywordflow">if</span> (stopped_ || current_ == end_) {</div>
<div class="line">    stopped_ = <span class="keyword">true</span>;</div>
<div class="line">    <span class="keywordflow">return</span>;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> value = *current_;</div>
<div class="line">  <span class="keywordtype">bool</span> matches = <span class="keyword">false</span>;</div>
<div class="line">  <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (std::invocable&lt;Pred, <span class="keyword">decltype</span>(value)&gt;) {</div>
<div class="line">    matches = predicate_(value);</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    matches = std::apply(predicate_, value);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">if</span> (!matches) {</div>
<div class="line">    stopped_ = <span class="keyword">true</span>;</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * @brief Iterator adapter that skips elements while a predicate returns true.</span></div>
<div class="line"><span class="comment"> * @tparam Iter Underlying iterator type</span></div>
<div class="line"><span class="comment"> * @tparam Pred Predicate function type</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * @example</span></div>
<div class="line"><span class="comment"> * @code</span></div>
<div class="line"><span class="comment"> * // Skip entities while their health is zero</span></div>
<div class="line"><span class="comment"> * auto non_zero_health = query.SkipWhile([](const Health&amp; h) { return h.points == 0; });</span></div>
<div class="line"><span class="comment"> * @endcode</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter, <span class="keyword">typename</span> Pred&gt;</div>
<div class="line">  <span class="keyword">requires</span> SkipWhileAdapterRequirements&lt;Iter, Pred&gt;</div>
<div class="line"><span class="keyword">class </span>SkipWhileAdapter : <span class="keyword">public</span> FunctionalAdapterBase&lt;SkipWhileAdapter&lt;Iter, Pred&gt;&gt; {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">using </span><a id="a75" name="a75"></a><a class="code hl_typedef" href="classhelios_1_1utils_1_1SkipWhileAdapter.html#ac9075f0e4679f71f7619b6fa0c198b8b">iterator_category</a> = std::forward_iterator_tag;</div>
<div class="line">  <span class="keyword">using </span><a id="a76" name="a76"></a><a class="code hl_typedef" href="classhelios_1_1utils_1_1SkipWhileAdapter.html#a9c2e3071137f7aa9e7d066bcf137b5b1">value_type</a> = std::iter_value_t&lt;Iter&gt;;</div>
<div class="line">  <span class="keyword">using </span><a id="a77" name="a77"></a><a class="code hl_typedef" href="classhelios_1_1utils_1_1SkipWhileAdapter.html#a557f57bff7409e2b4415975b6a42d879">difference_type</a> = std::iter_difference_t&lt;Iter&gt;;</div>
<div class="line">  <span class="keyword">using </span><a id="a78" name="a78"></a><a class="code hl_typedef" href="classhelios_1_1utils_1_1SkipWhileAdapter.html#a91021023f5ee3478bd677178b96da470">pointer</a> = <a class="code hl_typedef" href="classhelios_1_1utils_1_1SkipWhileAdapter.html#a9c2e3071137f7aa9e7d066bcf137b5b1">value_type</a>*;</div>
<div class="line">  <span class="keyword">using </span><a id="a79" name="a79"></a><a class="code hl_typedef" href="classhelios_1_1utils_1_1SkipWhileAdapter.html#a96d7d4196af334af0cdbf1f5796b72fa">reference</a> = <a class="code hl_typedef" href="classhelios_1_1utils_1_1SkipWhileAdapter.html#a9c2e3071137f7aa9e7d066bcf137b5b1">value_type</a>;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /**</span></div>
<div class="line"><span class="comment">   * @brief Constructs a skip-while adapter with the given iterator range and predicate.</span></div>
<div class="line"><span class="comment">   * @param begin Start of the iterator range</span></div>
<div class="line"><span class="comment">   * @param end End of the iterator range</span></div>
<div class="line"><span class="comment">   * @param predicate Function to test elements</span></div>
<div class="line"><span class="comment">   */</span></div>
<div class="line">  <span class="keyword">constexpr</span> SkipWhileAdapter(Iter <a id="a80" name="a80"></a><a class="code hl_function" href="classhelios_1_1utils_1_1SkipWhileAdapter.html#ad72117049eb13a741ff009deebf677bc">begin</a>, Iter <a id="a81" name="a81"></a><a class="code hl_function" href="classhelios_1_1utils_1_1SkipWhileAdapter.html#a06a7bafb13a0156164401cae005c4277">end</a>,</div>
<div class="line">                             Pred predicate) <span class="keyword">noexcept</span>(std::is_nothrow_move_constructible_v&lt;Iter&gt; &amp;&amp;</div>
<div class="line">                                                      std::is_nothrow_move_constructible_v&lt;Pred&gt; &amp;&amp;</div>
<div class="line">                                                      <span class="keyword">noexcept</span>(AdvancePastSkipped()))</div>
<div class="line">      : current_(std::move(<a class="code hl_function" href="classhelios_1_1utils_1_1SkipWhileAdapter.html#ad72117049eb13a741ff009deebf677bc">begin</a>)), end_(std::move(<a class="code hl_function" href="classhelios_1_1utils_1_1SkipWhileAdapter.html#a06a7bafb13a0156164401cae005c4277">end</a>)), predicate_(std::move(predicate)) {</div>
<div class="line">    AdvancePastSkipped();</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">constexpr</span> SkipWhileAdapter(<span class="keyword">const</span> SkipWhileAdapter&amp;) <span class="keyword">noexcept</span>(std::is_nothrow_copy_constructible_v&lt;Iter&gt; &amp;&amp;</div>
<div class="line">                                                               std::is_nothrow_copy_constructible_v&lt;Pred&gt;) = <span class="keywordflow">default</span>;</div>
<div class="line">  <span class="keyword">constexpr</span> SkipWhileAdapter(SkipWhileAdapter&amp;&amp;) <span class="keyword">noexcept</span>(std::is_nothrow_move_constructible_v&lt;Iter&gt; &amp;&amp;</div>
<div class="line">                                                          std::is_nothrow_move_constructible_v&lt;Pred&gt;) = <span class="keywordflow">default</span>;</div>
<div class="line">  <span class="keyword">constexpr</span> <a id="a82" name="a82"></a><a class="code hl_function" href="classhelios_1_1utils_1_1SkipWhileAdapter.html#aa7af918bc5a68eabb94bb11abe3417d7">~SkipWhileAdapter</a>() <span class="keyword">noexcept</span>(std::is_nothrow_destructible_v&lt;Iter&gt; &amp;&amp;</div>
<div class="line">                                         std::is_nothrow_destructible_v&lt;Pred&gt;) = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">constexpr</span> SkipWhileAdapter&amp; <a id="a83" name="a83"></a><a class="code hl_function" href="classhelios_1_1utils_1_1SkipWhileAdapter.html#a7884b85eef41352e00f6a42425dfd103">operator=</a>(<span class="keyword">const</span> SkipWhileAdapter&amp;) <span class="keyword">noexcept</span>(</div>
<div class="line">      std::is_nothrow_copy_assignable_v&lt;Iter&gt; &amp;&amp; std::is_nothrow_copy_assignable_v&lt;Pred&gt;) = <span class="keywordflow">default</span>;</div>
<div class="line">  <span class="keyword">constexpr</span> SkipWhileAdapter&amp; <a class="code hl_function" href="classhelios_1_1utils_1_1SkipWhileAdapter.html#a7884b85eef41352e00f6a42425dfd103">operator=</a>(SkipWhileAdapter&amp;&amp;) <span class="keyword">noexcept</span>(std::is_nothrow_move_assignable_v&lt;Iter&gt; &amp;&amp;</div>
<div class="line">                                                                     std::is_nothrow_move_assignable_v&lt;Pred&gt;) = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">constexpr</span> SkipWhileAdapter&amp; <a id="a84" name="a84"></a><a class="code hl_function" href="classhelios_1_1utils_1_1SkipWhileAdapter.html#afe975de8f99b2c83faa882204baaa284">operator++</a>() <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(++std::declval&lt;Iter&amp;&gt;()));</div>
<div class="line">  <span class="keyword">constexpr</span> SkipWhileAdapter <a class="code hl_function" href="classhelios_1_1utils_1_1SkipWhileAdapter.html#afe975de8f99b2c83faa882204baaa284">operator++</a>(<span class="keywordtype">int</span>) <span class="keyword">noexcept</span>(std::is_nothrow_copy_constructible_v&lt;SkipWhileAdapter&gt; &amp;&amp;</div>
<div class="line">                                                      <span class="keyword">noexcept</span>(++std::declval&lt;SkipWhileAdapter&amp;&gt;()));</div>
<div class="line"> </div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> <a class="code hl_typedef" href="classhelios_1_1utils_1_1SkipWhileAdapter.html#a9c2e3071137f7aa9e7d066bcf137b5b1">value_type</a> <a id="a85" name="a85"></a><a class="code hl_function" href="classhelios_1_1utils_1_1SkipWhileAdapter.html#a42aa7d421a494ea414f8d922cee89568">operator*</a>() <span class="keyword">const</span> <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(*std::declval&lt;const Iter&amp;&gt;())) {</div>
<div class="line">    <span class="keywordflow">return</span> *current_;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> <span class="keywordtype">bool</span> <a id="a86" name="a86"></a><a class="code hl_function" href="classhelios_1_1utils_1_1SkipWhileAdapter.html#aa9575367326e9995ad8301848ed94393">operator==</a>(<span class="keyword">const</span> SkipWhileAdapter&amp; other) <span class="keyword">const</span></div>
<div class="line">      <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(std::declval&lt;const Iter&amp;&gt;() == std::declval&lt;const Iter&amp;&gt;())) {</div>
<div class="line">    <span class="keywordflow">return</span> current_ == other.current_;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> <span class="keywordtype">bool</span> <a id="a87" name="a87"></a><a class="code hl_function" href="classhelios_1_1utils_1_1SkipWhileAdapter.html#a445c0e1caab67bab56ef610887480c3e">operator!=</a>(<span class="keyword">const</span> SkipWhileAdapter&amp; other) <span class="keyword">const</span></div>
<div class="line">      <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(std::declval&lt;const SkipWhileAdapter&amp;&gt;() == std::declval&lt;const SkipWhileAdapter&amp;&gt;())) {</div>
<div class="line">    <span class="keywordflow">return</span> !(*<span class="keyword">this</span> == other);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> SkipWhileAdapter <a class="code hl_function" href="classhelios_1_1utils_1_1SkipWhileAdapter.html#ad72117049eb13a741ff009deebf677bc">begin</a>() <span class="keyword">const</span></div>
<div class="line">      <span class="keyword">noexcept</span>(std::is_nothrow_copy_constructible_v&lt;SkipWhileAdapter&gt;) {</div>
<div class="line">    <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> SkipWhileAdapter <a class="code hl_function" href="classhelios_1_1utils_1_1SkipWhileAdapter.html#a06a7bafb13a0156164401cae005c4277">end</a>() <span class="keyword">const</span></div>
<div class="line">      <span class="keyword">noexcept</span>(std::is_nothrow_constructible_v&lt;SkipWhileAdapter, const Iter&amp;, const Iter&amp;, const Pred&amp;&gt;) {</div>
<div class="line">    <span class="keywordflow">return</span> {end_, end_, predicate_};</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keyword">constexpr</span> <span class="keywordtype">void</span> AdvancePastSkipped() <span class="keyword">noexcept</span>(std::is_nothrow_invocable_v&lt;Pred, std::iter_value_t&lt;Iter&gt;&gt; &amp;&amp;</div>
<div class="line">                                               <span class="keyword">noexcept</span>(std::declval&lt;Iter&amp;&gt;() != std::declval&lt;Iter&amp;&gt;()) &amp;&amp;</div>
<div class="line">                                               <span class="keyword">noexcept</span>(*std::declval&lt;Iter&amp;&gt;()) &amp;&amp; <span class="keyword">noexcept</span>(++std::declval&lt;Iter&amp;&gt;()));</div>
<div class="line"> </div>
<div class="line">  Iter current_;    <span class="comment">///&lt; Current position in the iteration</span></div>
<div class="line">  Iter end_;        <span class="comment">///&lt; End of the iterator range</span></div>
<div class="line">  Pred predicate_;  <span class="comment">///&lt; Predicate function</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter, <span class="keyword">typename</span> Pred&gt;</div>
<div class="line">  <span class="keyword">requires</span> SkipWhileAdapterRequirements&lt;Iter, Pred&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <a class="code hl_function" href="classhelios_1_1utils_1_1SkipWhileAdapter.html#afe975de8f99b2c83faa882204baaa284">SkipWhileAdapter&lt;Iter, Pred&gt;::operator++</a>() <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(++std::declval&lt;Iter&amp;&gt;()))</div>
<div class="line">    -&gt; SkipWhileAdapter&amp; {</div>
<div class="line">  ++current_;</div>
<div class="line">  <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter, <span class="keyword">typename</span> Pred&gt;</div>
<div class="line">  <span class="keyword">requires</span> SkipWhileAdapterRequirements&lt;Iter, Pred&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <a class="code hl_function" href="classhelios_1_1utils_1_1SkipWhileAdapter.html#afe975de8f99b2c83faa882204baaa284">SkipWhileAdapter&lt;Iter, Pred&gt;::operator++</a>(<span class="keywordtype">int</span>) <span class="keyword">noexcept</span>(</div>
<div class="line">    std::is_nothrow_copy_constructible_v&lt;SkipWhileAdapter&gt; &amp;&amp; <span class="keyword">noexcept</span>(++std::declval&lt;SkipWhileAdapter&amp;&gt;()))</div>
<div class="line">    -&gt; SkipWhileAdapter {</div>
<div class="line">  <span class="keyword">auto</span> temp = *<span class="keyword">this</span>;</div>
<div class="line">  ++(*this);</div>
<div class="line">  <span class="keywordflow">return</span> temp;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter, <span class="keyword">typename</span> Pred&gt;</div>
<div class="line">  <span class="keyword">requires</span> SkipWhileAdapterRequirements&lt;Iter, Pred&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keywordtype">void</span> SkipWhileAdapter&lt;Iter, Pred&gt;::AdvancePastSkipped() <span class="keyword">noexcept</span>(</div>
<div class="line">    std::is_nothrow_invocable_v&lt;Pred, std::iter_value_t&lt;Iter&gt;&gt; &amp;&amp;</div>
<div class="line">    <span class="keyword">noexcept</span>(std::declval&lt;Iter&amp;&gt;() != std::declval&lt;Iter&amp;&gt;()) &amp;&amp; <span class="keyword">noexcept</span>(*std::declval&lt;Iter&amp;&gt;()) &amp;&amp;</div>
<div class="line">    <span class="keyword">noexcept</span>(++std::declval&lt;Iter&amp;&gt;())) {</div>
<div class="line">  <span class="keywordflow">while</span> (current_ != end_) {</div>
<div class="line">    <span class="keyword">auto</span> value = *current_;</div>
<div class="line">    <span class="keywordtype">bool</span> matches = <span class="keyword">false</span>;</div>
<div class="line">    <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (std::invocable&lt;Pred, <span class="keyword">decltype</span>(value)&gt;) {</div>
<div class="line">      matches = predicate_(value);</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      matches = std::apply(predicate_, value);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (!matches) {</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line">    ++current_;</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * @brief Iterator adapter that adds index information to each element.</span></div>
<div class="line"><span class="comment"> * @details This adapter yields tuples of (index, value) where index starts at 0 and increments for each element.</span></div>
<div class="line"><span class="comment"> * @tparam Iter Underlying iterator type</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * @example</span></div>
<div class="line"><span class="comment"> * @code</span></div>
<div class="line"><span class="comment"> * // Enumerate entities with their indices</span></div>
<div class="line"><span class="comment"> * auto enumerated = query.Enumerate();</span></div>
<div class="line"><span class="comment"> * for (const auto&amp; [index, _] : enumerated) {</span></div>
<div class="line"><span class="comment"> *   // Use index and components</span></div>
<div class="line"><span class="comment"> * }</span></div>
<div class="line"><span class="comment"> * @endcode</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</div>
<div class="line">  <span class="keyword">requires</span> EnumerateAdapterRequirements&lt;Iter&gt;</div>
<div class="line"><span class="keyword">class </span>EnumerateAdapter : <span class="keyword">public</span> FunctionalAdapterBase&lt;EnumerateAdapter&lt;Iter&gt;&gt; {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">  <span class="keyword">struct </span>MakeEnumeratedValue {</div>
<div class="line">    <span class="keyword">using </span>type = std::tuple&lt;size_t, T&gt;;</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</div>
<div class="line">  <span class="keyword">struct </span>MakeEnumeratedValue&lt;std::tuple&lt;Args...&gt;&gt; {</div>
<div class="line">    <span class="keyword">using </span>type = std::tuple&lt;size_t, Args...&gt;;</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">using </span><a id="a88" name="a88"></a><a class="code hl_typedef" href="classhelios_1_1utils_1_1EnumerateAdapter.html#a76558608db80bc080dc109c6f791f7e7">iterator_category</a> = std::forward_iterator_tag;</div>
<div class="line">  <span class="keyword">using </span><a id="a89" name="a89"></a><a class="code hl_typedef" href="classhelios_1_1utils_1_1EnumerateAdapter.html#adeef92fda10757c956047fc39133c739">value_type</a> = <span class="keyword">typename</span> MakeEnumeratedValue&lt;std::iter_value_t&lt;Iter&gt;&gt;::type;</div>
<div class="line">  <span class="keyword">using </span><a id="a90" name="a90"></a><a class="code hl_typedef" href="classhelios_1_1utils_1_1EnumerateAdapter.html#a0839f20fab71eb6fbfb49aac02d0d7f5">difference_type</a> = std::iter_difference_t&lt;Iter&gt;;</div>
<div class="line">  <span class="keyword">using </span><a id="a91" name="a91"></a><a class="code hl_typedef" href="classhelios_1_1utils_1_1EnumerateAdapter.html#aea933b38b742f334f70c8c4c489ed555">pointer</a> = <a class="code hl_typedef" href="classhelios_1_1utils_1_1EnumerateAdapter.html#adeef92fda10757c956047fc39133c739">value_type</a>*;</div>
<div class="line">  <span class="keyword">using </span><a id="a92" name="a92"></a><a class="code hl_typedef" href="classhelios_1_1utils_1_1EnumerateAdapter.html#a2ab6bbf6492bc8f2aaced81830c2f37b">reference</a> = <a class="code hl_typedef" href="classhelios_1_1utils_1_1EnumerateAdapter.html#adeef92fda10757c956047fc39133c739">value_type</a>;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /**</span></div>
<div class="line"><span class="comment">   * @brief Constructs an enumerate adapter with the given iterator range.</span></div>
<div class="line"><span class="comment">   * @param begin Start of the iterator range</span></div>
<div class="line"><span class="comment">   * @param end End of the iterator range</span></div>
<div class="line"><span class="comment">   */</span></div>
<div class="line">  <span class="keyword">constexpr</span> EnumerateAdapter(Iter <a id="a93" name="a93"></a><a class="code hl_function" href="classhelios_1_1utils_1_1EnumerateAdapter.html#a0395dfc987c94bd9f17afc9c538b7d4c">begin</a>, Iter <a id="a94" name="a94"></a><a class="code hl_function" href="classhelios_1_1utils_1_1EnumerateAdapter.html#a61abeeef6e4377a14b6589fac9035b7d">end</a>) <span class="keyword">noexcept</span>(std::is_nothrow_move_constructible_v&lt;Iter&gt; &amp;&amp;</div>
<div class="line">                                                            std::is_nothrow_copy_constructible_v&lt;Iter&gt;)</div>
<div class="line">      : begin_(std::move(<a class="code hl_function" href="classhelios_1_1utils_1_1EnumerateAdapter.html#a0395dfc987c94bd9f17afc9c538b7d4c">begin</a>)), current_(begin_), end_(std::move(<a class="code hl_function" href="classhelios_1_1utils_1_1EnumerateAdapter.html#a61abeeef6e4377a14b6589fac9035b7d">end</a>)) {}</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">constexpr</span> EnumerateAdapter(<span class="keyword">const</span> EnumerateAdapter&amp;) = <span class="keywordflow">default</span>;</div>
<div class="line">  <span class="keyword">constexpr</span> EnumerateAdapter(EnumerateAdapter&amp;&amp;) = <span class="keywordflow">default</span>;</div>
<div class="line">  <span class="keyword">constexpr</span> <a id="a95" name="a95"></a><a class="code hl_function" href="classhelios_1_1utils_1_1EnumerateAdapter.html#a543beca8e1f344204da6278557b3fb86">~EnumerateAdapter</a>() = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">constexpr</span> EnumerateAdapter&amp; <a id="a96" name="a96"></a><a class="code hl_function" href="classhelios_1_1utils_1_1EnumerateAdapter.html#a188212a2c22f25e5d91c1f62b81c42d8">operator=</a>(<span class="keyword">const</span> EnumerateAdapter&amp;) = <span class="keywordflow">default</span>;</div>
<div class="line">  <span class="keyword">constexpr</span> EnumerateAdapter&amp; <a class="code hl_function" href="classhelios_1_1utils_1_1EnumerateAdapter.html#a188212a2c22f25e5d91c1f62b81c42d8">operator=</a>(EnumerateAdapter&amp;&amp;) = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">constexpr</span> EnumerateAdapter&amp; <a id="a97" name="a97"></a><a class="code hl_function" href="classhelios_1_1utils_1_1EnumerateAdapter.html#a2d2d637cf9d201de327a275f67def5c8">operator++</a>() <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(++std::declval&lt;Iter&amp;&gt;()));</div>
<div class="line">  <span class="keyword">constexpr</span> EnumerateAdapter <a class="code hl_function" href="classhelios_1_1utils_1_1EnumerateAdapter.html#a2d2d637cf9d201de327a275f67def5c8">operator++</a>(<span class="keywordtype">int</span>) <span class="keyword">noexcept</span>(std::is_nothrow_copy_constructible_v&lt;EnumerateAdapter&gt; &amp;&amp;</div>
<div class="line">                                                      <span class="keyword">noexcept</span>(++std::declval&lt;EnumerateAdapter&amp;&gt;()));</div>
<div class="line"> </div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> <a class="code hl_typedef" href="classhelios_1_1utils_1_1EnumerateAdapter.html#adeef92fda10757c956047fc39133c739">value_type</a> <a id="a98" name="a98"></a><a class="code hl_function" href="classhelios_1_1utils_1_1EnumerateAdapter.html#a829b88dcccc7f10af66f7bb6628d88f3">operator*</a>() <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> <span class="keywordtype">bool</span> <a id="a99" name="a99"></a><a class="code hl_function" href="classhelios_1_1utils_1_1EnumerateAdapter.html#a70c790b447d8547eeb7e7d7b0aa36726">operator==</a>(<span class="keyword">const</span> EnumerateAdapter&amp; other) <span class="keyword">const</span></div>
<div class="line">      <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(std::declval&lt;const Iter&amp;&gt;() == std::declval&lt;const Iter&amp;&gt;())) {</div>
<div class="line">    <span class="keywordflow">return</span> current_ == other.current_;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> <span class="keywordtype">bool</span> <a id="a100" name="a100"></a><a class="code hl_function" href="classhelios_1_1utils_1_1EnumerateAdapter.html#a6ec8cfe9e477fedc4ad0d2eb121030eb">operator!=</a>(<span class="keyword">const</span> EnumerateAdapter&amp; other) <span class="keyword">const</span></div>
<div class="line">      <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(std::declval&lt;const EnumerateAdapter&amp;&gt;() == std::declval&lt;const EnumerateAdapter&amp;&gt;())) {</div>
<div class="line">    <span class="keywordflow">return</span> !(*<span class="keyword">this</span> == other);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> EnumerateAdapter <a class="code hl_function" href="classhelios_1_1utils_1_1EnumerateAdapter.html#a0395dfc987c94bd9f17afc9c538b7d4c">begin</a>() <span class="keyword">const</span></div>
<div class="line">      <span class="keyword">noexcept</span>(std::is_nothrow_copy_constructible_v&lt;EnumerateAdapter&gt;) {</div>
<div class="line">    <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> EnumerateAdapter <a class="code hl_function" href="classhelios_1_1utils_1_1EnumerateAdapter.html#a61abeeef6e4377a14b6589fac9035b7d">end</a>() <span class="keyword">const</span></div>
<div class="line">      <span class="keyword">noexcept</span>(std::is_nothrow_constructible_v&lt;EnumerateAdapter, const Iter&amp;, const Iter&amp;&gt;) {</div>
<div class="line">    <span class="keywordflow">return</span> {end_, end_};</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  Iter begin_;        <span class="comment">///&lt; Start of the iterator range</span></div>
<div class="line">  Iter current_;      <span class="comment">///&lt; Current position in the iteration</span></div>
<div class="line">  Iter end_;          <span class="comment">///&lt; End of the iterator range</span></div>
<div class="line">  <span class="keywordtype">size_t</span> index_ = 0;  <span class="comment">///&lt; Current index in the enumeration</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</div>
<div class="line">  <span class="keyword">requires</span> EnumerateAdapterRequirements&lt;Iter&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <a class="code hl_function" href="classhelios_1_1utils_1_1EnumerateAdapter.html#a2d2d637cf9d201de327a275f67def5c8">EnumerateAdapter&lt;Iter&gt;::operator++</a>() <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(++std::declval&lt;Iter&amp;&gt;())) -&gt; EnumerateAdapter&amp; {</div>
<div class="line">  ++current_;</div>
<div class="line">  ++index_;</div>
<div class="line">  <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</div>
<div class="line">  <span class="keyword">requires</span> EnumerateAdapterRequirements&lt;Iter&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <a class="code hl_function" href="classhelios_1_1utils_1_1EnumerateAdapter.html#a2d2d637cf9d201de327a275f67def5c8">EnumerateAdapter&lt;Iter&gt;::operator++</a>(<span class="keywordtype">int</span>) <span class="keyword">noexcept</span>(</div>
<div class="line">    std::is_nothrow_copy_constructible_v&lt;EnumerateAdapter&gt; &amp;&amp; <span class="keyword">noexcept</span>(++std::declval&lt;EnumerateAdapter&amp;&gt;()))</div>
<div class="line">    -&gt; EnumerateAdapter {</div>
<div class="line">  <span class="keyword">auto</span> temp = *<span class="keyword">this</span>;</div>
<div class="line">  ++(*this);</div>
<div class="line">  <span class="keywordflow">return</span> temp;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</div>
<div class="line">  <span class="keyword">requires</span> EnumerateAdapterRequirements&lt;Iter&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <a class="code hl_function" href="classhelios_1_1utils_1_1EnumerateAdapter.html#a829b88dcccc7f10af66f7bb6628d88f3">EnumerateAdapter&lt;Iter&gt;::operator*</a>() <span class="keyword">const</span> -&gt; value_type {</div>
<div class="line">  <span class="keyword">auto</span> value = *current_;</div>
<div class="line">  <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (<span class="keyword">requires</span> { std::tuple_cat(std::tuple{index_}, value); }) {</div>
<div class="line">    <span class="keywordflow">return</span> std::tuple_cat(std::tuple{index_}, value);</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="keywordflow">return</span> std::tuple{index_, value};</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * @brief Iterator adapter that applies a function to each element for observation.</span></div>
<div class="line"><span class="comment"> * @details This adapter allows observing elements without modifying them.</span></div>
<div class="line"><span class="comment"> * The inspector function is called for side effects only.</span></div>
<div class="line"><span class="comment"> * @tparam Iter Underlying iterator type</span></div>
<div class="line"><span class="comment"> * @tparam Func Inspector function type</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * @example</span></div>
<div class="line"><span class="comment"> * @code</span></div>
<div class="line"><span class="comment"> * // Inspect entities to log their IDs</span></div>
<div class="line"><span class="comment"> * auto inspected = query.Inspect([](const Entity&amp; e) { HELIOS_INFO(&quot;{}&quot;, e.id); });</span></div>
<div class="line"><span class="comment"> * @endcode</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter, <span class="keyword">typename</span> Func&gt;</div>
<div class="line">  <span class="keyword">requires</span> InspectAdapterRequirements&lt;Iter, Func&gt;</div>
<div class="line"><span class="keyword">class </span>InspectAdapter : <span class="keyword">public</span> FunctionalAdapterBase&lt;InspectAdapter&lt;Iter, Func&gt;&gt; {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">using </span><a id="a101" name="a101"></a><a class="code hl_typedef" href="classhelios_1_1utils_1_1InspectAdapter.html#afb60b0c286c6374aeeb58c6370984909">iterator_category</a> = std::forward_iterator_tag;</div>
<div class="line">  <span class="keyword">using </span><a id="a102" name="a102"></a><a class="code hl_typedef" href="classhelios_1_1utils_1_1InspectAdapter.html#ac2e8c5cf50b4402995f52e533e7ccdde">value_type</a> = std::iter_value_t&lt;Iter&gt;;</div>
<div class="line">  <span class="keyword">using </span><a id="a103" name="a103"></a><a class="code hl_typedef" href="classhelios_1_1utils_1_1InspectAdapter.html#ab9a7262706dad466c518f090440aebc0">difference_type</a> = std::iter_difference_t&lt;Iter&gt;;</div>
<div class="line">  <span class="keyword">using </span><a id="a104" name="a104"></a><a class="code hl_typedef" href="classhelios_1_1utils_1_1InspectAdapter.html#a77d3e6165593316f165552f4f74354d8">pointer</a> = <a class="code hl_typedef" href="classhelios_1_1utils_1_1InspectAdapter.html#ac2e8c5cf50b4402995f52e533e7ccdde">value_type</a>*;</div>
<div class="line">  <span class="keyword">using </span><a id="a105" name="a105"></a><a class="code hl_typedef" href="classhelios_1_1utils_1_1InspectAdapter.html#a31aa483c616ef40dd72d4d9d814f0af9">reference</a> = <a class="code hl_typedef" href="classhelios_1_1utils_1_1InspectAdapter.html#ac2e8c5cf50b4402995f52e533e7ccdde">value_type</a>;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /**</span></div>
<div class="line"><span class="comment">   * @brief Constructs an inspect adapter with the given iterator range and inspector function.</span></div>
<div class="line"><span class="comment">   * @param begin Start of the iterator range</span></div>
<div class="line"><span class="comment">   * @param end End of the iterator range</span></div>
<div class="line"><span class="comment">   * @param inspector Function to call for each element</span></div>
<div class="line"><span class="comment">   */</span></div>
<div class="line">  <span class="keyword">constexpr</span> InspectAdapter(Iter <a id="a106" name="a106"></a><a class="code hl_function" href="classhelios_1_1utils_1_1InspectAdapter.html#a48eb41137995a02221e73c672e4035e1">begin</a>, Iter <a id="a107" name="a107"></a><a class="code hl_function" href="classhelios_1_1utils_1_1InspectAdapter.html#a7087a02ef4b60a11f90b31a1ce92767c">end</a>, Func inspector) <span class="keyword">noexcept</span>(std::is_nothrow_move_constructible_v&lt;Iter&gt; &amp;&amp;</div>
<div class="line">                                                                          std::is_nothrow_copy_constructible_v&lt;Iter&gt; &amp;&amp;</div>
<div class="line">                                                                          std::is_nothrow_move_constructible_v&lt;Func&gt;)</div>
<div class="line">      : begin_(std::move(<a class="code hl_function" href="classhelios_1_1utils_1_1InspectAdapter.html#a48eb41137995a02221e73c672e4035e1">begin</a>)), current_(begin_), end_(std::move(<a class="code hl_function" href="classhelios_1_1utils_1_1InspectAdapter.html#a7087a02ef4b60a11f90b31a1ce92767c">end</a>)), inspector_(std::move(inspector)) {}</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">constexpr</span> InspectAdapter(<span class="keyword">const</span> InspectAdapter&amp;) <span class="keyword">noexcept</span>(std::is_nothrow_copy_constructible_v&lt;Iter&gt; &amp;&amp;</div>
<div class="line">                                                           std::is_nothrow_copy_constructible_v&lt;Func&gt;) = <span class="keywordflow">default</span>;</div>
<div class="line">  <span class="keyword">constexpr</span> InspectAdapter(InspectAdapter&amp;&amp;) <span class="keyword">noexcept</span>(std::is_nothrow_move_constructible_v&lt;Iter&gt; &amp;&amp;</div>
<div class="line">                                                      std::is_nothrow_move_constructible_v&lt;Func&gt;) = <span class="keywordflow">default</span>;</div>
<div class="line">  <span class="keyword">constexpr</span> <a id="a108" name="a108"></a><a class="code hl_function" href="classhelios_1_1utils_1_1InspectAdapter.html#a945525276e52e672cdfc85ee98014f6c">~InspectAdapter</a>() <span class="keyword">noexcept</span>(std::is_nothrow_destructible_v&lt;Iter&gt; &amp;&amp;</div>
<div class="line">                                       std::is_nothrow_destructible_v&lt;Func&gt;) = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">constexpr</span> InspectAdapter&amp; <a id="a109" name="a109"></a><a class="code hl_function" href="classhelios_1_1utils_1_1InspectAdapter.html#a581d9ae2a40ba2b60d0a3ae658683f88">operator=</a>(<span class="keyword">const</span> InspectAdapter&amp;) <span class="keyword">noexcept</span>(</div>
<div class="line">      std::is_nothrow_copy_assignable_v&lt;Iter&gt; &amp;&amp; std::is_nothrow_copy_assignable_v&lt;Func&gt;) = <span class="keywordflow">default</span>;</div>
<div class="line">  <span class="keyword">constexpr</span> InspectAdapter&amp; <a class="code hl_function" href="classhelios_1_1utils_1_1InspectAdapter.html#a581d9ae2a40ba2b60d0a3ae658683f88">operator=</a>(InspectAdapter&amp;&amp;) <span class="keyword">noexcept</span>(std::is_nothrow_move_assignable_v&lt;Iter&gt; &amp;&amp;</div>
<div class="line">                                                                 std::is_nothrow_move_assignable_v&lt;Func&gt;) = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">constexpr</span> InspectAdapter&amp; <a id="a110" name="a110"></a><a class="code hl_function" href="classhelios_1_1utils_1_1InspectAdapter.html#a2f3e93dbbcd76e475a22adfcdea89bc6">operator++</a>() <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(++std::declval&lt;Iter&amp;&gt;()));</div>
<div class="line">  <span class="keyword">constexpr</span> InspectAdapter <a class="code hl_function" href="classhelios_1_1utils_1_1InspectAdapter.html#a2f3e93dbbcd76e475a22adfcdea89bc6">operator++</a>(<span class="keywordtype">int</span>) <span class="keyword">noexcept</span>(std::is_nothrow_copy_constructible_v&lt;InspectAdapter&gt; &amp;&amp;</div>
<div class="line">                                                    <span class="keyword">noexcept</span>(++std::declval&lt;InspectAdapter&amp;&gt;()));</div>
<div class="line"> </div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> <a class="code hl_typedef" href="classhelios_1_1utils_1_1InspectAdapter.html#ac2e8c5cf50b4402995f52e533e7ccdde">value_type</a> <a id="a111" name="a111"></a><a class="code hl_function" href="classhelios_1_1utils_1_1InspectAdapter.html#a33c8ff3a44410abe45118d5c57172c26">operator*</a>() <span class="keyword">const</span></div>
<div class="line">      <span class="keyword">noexcept</span>(std::is_nothrow_invocable_v&lt;Func, std::iter_value_t&lt;Iter&gt;&gt; &amp;&amp; <span class="keyword">noexcept</span>(*std::declval&lt;const Iter&amp;&gt;()));</div>
<div class="line"> </div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> <span class="keywordtype">bool</span> <a id="a112" name="a112"></a><a class="code hl_function" href="classhelios_1_1utils_1_1InspectAdapter.html#a68ecfdb71f244f33b23dfb9bc9f67068">operator==</a>(<span class="keyword">const</span> InspectAdapter&amp; other) <span class="keyword">const</span></div>
<div class="line">      <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(std::declval&lt;const Iter&amp;&gt;() == std::declval&lt;const Iter&amp;&gt;())) {</div>
<div class="line">    <span class="keywordflow">return</span> current_ == other.current_;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> <span class="keywordtype">bool</span> <a id="a113" name="a113"></a><a class="code hl_function" href="classhelios_1_1utils_1_1InspectAdapter.html#a90f64f4bfd762eb8bdaf94b7a2658a27">operator!=</a>(<span class="keyword">const</span> InspectAdapter&amp; other) <span class="keyword">const</span></div>
<div class="line">      <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(std::declval&lt;const InspectAdapter&amp;&gt;() == std::declval&lt;const InspectAdapter&amp;&gt;())) {</div>
<div class="line">    <span class="keywordflow">return</span> !(*<span class="keyword">this</span> == other);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> InspectAdapter <a class="code hl_function" href="classhelios_1_1utils_1_1InspectAdapter.html#a48eb41137995a02221e73c672e4035e1">begin</a>() <span class="keyword">const</span> <span class="keyword">noexcept</span>(std::is_nothrow_copy_constructible_v&lt;InspectAdapter&gt;) {</div>
<div class="line">    <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> InspectAdapter <a class="code hl_function" href="classhelios_1_1utils_1_1InspectAdapter.html#a7087a02ef4b60a11f90b31a1ce92767c">end</a>() <span class="keyword">const</span></div>
<div class="line">      <span class="keyword">noexcept</span>(std::is_nothrow_constructible_v&lt;InspectAdapter, const Iter&amp;, const Iter&amp;, const Func&amp;&gt;) {</div>
<div class="line">    <span class="keywordflow">return</span> {end_, end_, inspector_};</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  Iter begin_;      <span class="comment">///&lt; Start of the iterator range</span></div>
<div class="line">  Iter current_;    <span class="comment">///&lt; Current position in the iteration</span></div>
<div class="line">  Iter end_;        <span class="comment">///&lt; End of the iterator range</span></div>
<div class="line">  Func inspector_;  <span class="comment">///&lt; Inspector function</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter, <span class="keyword">typename</span> Func&gt;</div>
<div class="line">  <span class="keyword">requires</span> InspectAdapterRequirements&lt;Iter, Func&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <a class="code hl_function" href="classhelios_1_1utils_1_1InspectAdapter.html#a2f3e93dbbcd76e475a22adfcdea89bc6">InspectAdapter&lt;Iter, Func&gt;::operator++</a>() <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(++std::declval&lt;Iter&amp;&gt;())) -&gt; InspectAdapter&amp; {</div>
<div class="line">  ++current_;</div>
<div class="line">  <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter, <span class="keyword">typename</span> Func&gt;</div>
<div class="line">  <span class="keyword">requires</span> InspectAdapterRequirements&lt;Iter, Func&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <a class="code hl_function" href="classhelios_1_1utils_1_1InspectAdapter.html#a2f3e93dbbcd76e475a22adfcdea89bc6">InspectAdapter&lt;Iter, Func&gt;::operator++</a>(<span class="keywordtype">int</span>) <span class="keyword">noexcept</span>(</div>
<div class="line">    std::is_nothrow_copy_constructible_v&lt;InspectAdapter&gt; &amp;&amp; <span class="keyword">noexcept</span>(++std::declval&lt;InspectAdapter&amp;&gt;()))</div>
<div class="line">    -&gt; InspectAdapter {</div>
<div class="line">  <span class="keyword">auto</span> temp = *<span class="keyword">this</span>;</div>
<div class="line">  ++(*this);</div>
<div class="line">  <span class="keywordflow">return</span> temp;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter, <span class="keyword">typename</span> Func&gt;</div>
<div class="line">  <span class="keyword">requires</span> InspectAdapterRequirements&lt;Iter, Func&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <a class="code hl_function" href="classhelios_1_1utils_1_1InspectAdapter.html#a33c8ff3a44410abe45118d5c57172c26">InspectAdapter&lt;Iter, Func&gt;::operator*</a>() <span class="keyword">const</span></div>
<div class="line">    <span class="keyword">noexcept</span>(std::is_nothrow_invocable_v&lt;Func, std::iter_value_t&lt;Iter&gt;&gt; &amp;&amp; <span class="keyword">noexcept</span>(*std::declval&lt;const Iter&amp;&gt;()))</div>
<div class="line">        -&gt; std::iter_value_t&lt;Iter&gt; {</div>
<div class="line">  <span class="keyword">auto</span> value = *current_;</div>
<div class="line">  <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (std::invocable&lt;Func, <span class="keyword">decltype</span>(value)&gt;) {</div>
<div class="line">    inspector_(value);</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    std::apply(inspector_, value);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> value;</div>
<div class="line">}</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * @brief Iterator adapter that steps through elements by a specified stride.</span></div>
<div class="line"><span class="comment"> * @details This adapter yields every step-th element from the underlying iterator.</span></div>
<div class="line"><span class="comment"> * @tparam Iter Underlying iterator type</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * @example</span></div>
<div class="line"><span class="comment"> * @code</span></div>
<div class="line"><span class="comment"> * // Step through entities by 3</span></div>
<div class="line"><span class="comment"> * auto stepped = query.StepBy(3);</span></div>
<div class="line"><span class="comment"> * @endcode</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</div>
<div class="line">  <span class="keyword">requires</span> StepByAdapterRequirements&lt;Iter&gt;</div>
<div class="line"><span class="keyword">class </span>StepByAdapter : <span class="keyword">public</span> FunctionalAdapterBase&lt;StepByAdapter&lt;Iter&gt;&gt; {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">using </span><a id="a114" name="a114"></a><a class="code hl_typedef" href="classhelios_1_1utils_1_1StepByAdapter.html#a2c57a44b9580db53d8781e80b29cf140">iterator_category</a> = std::forward_iterator_tag;</div>
<div class="line">  <span class="keyword">using </span><a id="a115" name="a115"></a><a class="code hl_typedef" href="classhelios_1_1utils_1_1StepByAdapter.html#a0c35edb3fca6216c08eeb99b1a068876">value_type</a> = std::iter_value_t&lt;Iter&gt;;</div>
<div class="line">  <span class="keyword">using </span><a id="a116" name="a116"></a><a class="code hl_typedef" href="classhelios_1_1utils_1_1StepByAdapter.html#a7ad930037fb9e06f61f0d11a61f55af2">difference_type</a> = std::iter_difference_t&lt;Iter&gt;;</div>
<div class="line">  <span class="keyword">using </span><a id="a117" name="a117"></a><a class="code hl_typedef" href="classhelios_1_1utils_1_1StepByAdapter.html#afe462dbe164cb85bfcb7181b31c2b3f1">pointer</a> = <a class="code hl_typedef" href="classhelios_1_1utils_1_1StepByAdapter.html#a0c35edb3fca6216c08eeb99b1a068876">value_type</a>*;</div>
<div class="line">  <span class="keyword">using </span><a id="a118" name="a118"></a><a class="code hl_typedef" href="classhelios_1_1utils_1_1StepByAdapter.html#a7584283d36578b8585e43185952022e8">reference</a> = <a class="code hl_typedef" href="classhelios_1_1utils_1_1StepByAdapter.html#a0c35edb3fca6216c08eeb99b1a068876">value_type</a>;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /**</span></div>
<div class="line"><span class="comment">   * @brief Constructs a step-by adapter with the given iterator range and step size.</span></div>
<div class="line"><span class="comment">   * @param begin Start of the iterator range</span></div>
<div class="line"><span class="comment">   * @param end End of the iterator range</span></div>
<div class="line"><span class="comment">   * @param step Number of elements to step by</span></div>
<div class="line"><span class="comment">   */</span></div>
<div class="line">  <span class="keyword">constexpr</span> StepByAdapter(Iter <a id="a119" name="a119"></a><a class="code hl_function" href="classhelios_1_1utils_1_1StepByAdapter.html#a5d1e1da59bbbe151d45583014a8a5daf">begin</a>, Iter <a id="a120" name="a120"></a><a class="code hl_function" href="classhelios_1_1utils_1_1StepByAdapter.html#a280022b7a9f029976141cc621e631e09">end</a>, <span class="keywordtype">size_t</span> step) <span class="keyword">noexcept</span>(std::is_nothrow_move_constructible_v&lt;Iter&gt; &amp;&amp;</div>
<div class="line">                                                                      std::is_nothrow_copy_constructible_v&lt;Iter&gt;)</div>
<div class="line">      : begin_(std::move(<a class="code hl_function" href="classhelios_1_1utils_1_1StepByAdapter.html#a5d1e1da59bbbe151d45583014a8a5daf">begin</a>)), current_(begin_), end_(std::move(<a class="code hl_function" href="classhelios_1_1utils_1_1StepByAdapter.html#a280022b7a9f029976141cc621e631e09">end</a>)), step_(step &gt; 0 ? step : 1) {}</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">constexpr</span> StepByAdapter(<span class="keyword">const</span> StepByAdapter&amp;) = <span class="keywordflow">default</span>;</div>
<div class="line">  <span class="keyword">constexpr</span> StepByAdapter(StepByAdapter&amp;&amp;) = <span class="keywordflow">default</span>;</div>
<div class="line">  <span class="keyword">constexpr</span> <a id="a121" name="a121"></a><a class="code hl_function" href="classhelios_1_1utils_1_1StepByAdapter.html#af85d16a5d072663b7942c9c3337abbfd">~StepByAdapter</a>() = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">constexpr</span> StepByAdapter&amp; <a id="a122" name="a122"></a><a class="code hl_function" href="classhelios_1_1utils_1_1StepByAdapter.html#a0d5260abeef230695f5c6a5f7a8f2523">operator=</a>(<span class="keyword">const</span> StepByAdapter&amp;) = <span class="keywordflow">default</span>;</div>
<div class="line">  <span class="keyword">constexpr</span> StepByAdapter&amp; <a class="code hl_function" href="classhelios_1_1utils_1_1StepByAdapter.html#a0d5260abeef230695f5c6a5f7a8f2523">operator=</a>(StepByAdapter&amp;&amp;) = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">constexpr</span> StepByAdapter&amp; <a id="a123" name="a123"></a><a class="code hl_function" href="classhelios_1_1utils_1_1StepByAdapter.html#ab460ec5dbf307afa7eb3e852d0875c07">operator++</a>() <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(++std::declval&lt;Iter&amp;&gt;()) &amp;&amp;</div>
<div class="line">                                                 <span class="keyword">noexcept</span>(std::declval&lt;Iter&amp;&gt;() != std::declval&lt;Iter&amp;&gt;()));</div>
<div class="line">  <span class="keyword">constexpr</span> StepByAdapter <a class="code hl_function" href="classhelios_1_1utils_1_1StepByAdapter.html#ab460ec5dbf307afa7eb3e852d0875c07">operator++</a>(<span class="keywordtype">int</span>) <span class="keyword">noexcept</span>(std::is_copy_constructible_v&lt;StepByAdapter&gt; &amp;&amp;</div>
<div class="line">                                                   <span class="keyword">noexcept</span>(++std::declval&lt;StepByAdapter&amp;&gt;()));</div>
<div class="line"> </div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> <a class="code hl_typedef" href="classhelios_1_1utils_1_1StepByAdapter.html#a0c35edb3fca6216c08eeb99b1a068876">value_type</a> <a id="a124" name="a124"></a><a class="code hl_function" href="classhelios_1_1utils_1_1StepByAdapter.html#a94f07ac09560a41f3a02be114656dc7d">operator*</a>() <span class="keyword">const</span> <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(*std::declval&lt;const Iter&amp;&gt;())) {</div>
<div class="line">    <span class="keywordflow">return</span> *current_;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> <span class="keywordtype">bool</span> <a id="a125" name="a125"></a><a class="code hl_function" href="classhelios_1_1utils_1_1StepByAdapter.html#afa99cb6da3a1af2bd1dd5781ced00553">operator==</a>(<span class="keyword">const</span> StepByAdapter&amp; other) <span class="keyword">const</span></div>
<div class="line">      <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(std::declval&lt;const Iter&amp;&gt;() == std::declval&lt;const Iter&amp;&gt;())) {</div>
<div class="line">    <span class="keywordflow">return</span> current_ == other.current_;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> <span class="keywordtype">bool</span> <a id="a126" name="a126"></a><a class="code hl_function" href="classhelios_1_1utils_1_1StepByAdapter.html#aca44769bb25741b6315391b752ec3fb7">operator!=</a>(<span class="keyword">const</span> StepByAdapter&amp; other) <span class="keyword">const</span></div>
<div class="line">      <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(std::declval&lt;const StepByAdapter&amp;&gt;() == std::declval&lt;const StepByAdapter&amp;&gt;())) {</div>
<div class="line">    <span class="keywordflow">return</span> !(*<span class="keyword">this</span> == other);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> StepByAdapter <a class="code hl_function" href="classhelios_1_1utils_1_1StepByAdapter.html#a5d1e1da59bbbe151d45583014a8a5daf">begin</a>() <span class="keyword">const</span> <span class="keyword">noexcept</span>(std::is_nothrow_copy_constructible_v&lt;StepByAdapter&gt;) {</div>
<div class="line">    <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> StepByAdapter <a class="code hl_function" href="classhelios_1_1utils_1_1StepByAdapter.html#a280022b7a9f029976141cc621e631e09">end</a>() <span class="keyword">const</span></div>
<div class="line">      <span class="keyword">noexcept</span>(std::is_nothrow_constructible_v&lt;StepByAdapter, const Iter&amp;, const Iter&amp;, size_t&gt;) {</div>
<div class="line">    <span class="keywordflow">return</span> {end_, end_, step_};</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  Iter begin_;       <span class="comment">///&lt; Start of the iterator range</span></div>
<div class="line">  Iter current_;     <span class="comment">///&lt; Current position in the iteration</span></div>
<div class="line">  Iter end_;         <span class="comment">///&lt; End of the iterator range</span></div>
<div class="line">  <span class="keywordtype">size_t</span> step_ = 0;  <span class="comment">///&lt; Step size between elements</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</div>
<div class="line">  <span class="keyword">requires</span> StepByAdapterRequirements&lt;Iter&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <a class="code hl_function" href="classhelios_1_1utils_1_1StepByAdapter.html#ab460ec5dbf307afa7eb3e852d0875c07">StepByAdapter&lt;Iter&gt;::operator++</a>() <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(++std::declval&lt;Iter&amp;&gt;()) &amp;&amp;</div>
<div class="line">                                                          <span class="keyword">noexcept</span>(std::declval&lt;Iter&amp;&gt;() != std::declval&lt;Iter&amp;&gt;()))</div>
<div class="line">    -&gt; StepByAdapter&amp; {</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; step_ &amp;&amp; current_ != end_; ++i) {</div>
<div class="line">    ++current_;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</div>
<div class="line">  <span class="keyword">requires</span> StepByAdapterRequirements&lt;Iter&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <a class="code hl_function" href="classhelios_1_1utils_1_1StepByAdapter.html#ab460ec5dbf307afa7eb3e852d0875c07">StepByAdapter&lt;Iter&gt;::operator++</a>(<span class="keywordtype">int</span>) <span class="keyword">noexcept</span>(std::is_copy_constructible_v&lt;StepByAdapter&gt; &amp;&amp;</div>
<div class="line">                                                             <span class="keyword">noexcept</span>(++std::declval&lt;StepByAdapter&amp;&gt;()))</div>
<div class="line">    -&gt; StepByAdapter {</div>
<div class="line">  <span class="keyword">auto</span> temp = *<span class="keyword">this</span>;</div>
<div class="line">  ++(*this);</div>
<div class="line">  <span class="keywordflow">return</span> temp;</div>
<div class="line">}</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * @brief Iterator adapter that chains two sequences together.</span></div>
<div class="line"><span class="comment"> * @details This adapter yields all elements from the first iterator, then all elements from the second iterator.</span></div>
<div class="line"><span class="comment"> * @tparam Iter1 First iterator type</span></div>
<div class="line"><span class="comment"> * @tparam Iter2 Second iterator type</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * @example</span></div>
<div class="line"><span class="comment"> * @code</span></div>
<div class="line"><span class="comment"> * // Chain two `Health` queries together</span></div>
<div class="line"><span class="comment"> * auto chained = query1.Chain(query2);</span></div>
<div class="line"><span class="comment"> * chained.ForEach([](const Health&amp; h) {</span></div>
<div class="line"><span class="comment"> *   // Process health components from both queries</span></div>
<div class="line"><span class="comment"> * });</span></div>
<div class="line"><span class="comment"> * @endcode</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter1, <span class="keyword">typename</span> Iter2&gt;</div>
<div class="line">  <span class="keyword">requires</span> ChainAdapterRequirements&lt;Iter1, Iter2&gt;</div>
<div class="line"><span class="keyword">class </span>ChainAdapter : <span class="keyword">public</span> FunctionalAdapterBase&lt;ChainAdapter&lt;Iter1, Iter2&gt;&gt; {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">using </span><a id="a127" name="a127"></a><a class="code hl_typedef" href="classhelios_1_1utils_1_1ChainAdapter.html#a1aa1883fd20402a6cd7651d6c00b8a0d">iterator_category</a> = std::forward_iterator_tag;</div>
<div class="line">  <span class="keyword">using </span><a id="a128" name="a128"></a><a class="code hl_typedef" href="classhelios_1_1utils_1_1ChainAdapter.html#a8e2b8edb8500a1b0c3514185ff6463ec">value_type</a> = std::iter_value_t&lt;Iter1&gt;;</div>
<div class="line">  <span class="keyword">using </span><a id="a129" name="a129"></a><a class="code hl_typedef" href="classhelios_1_1utils_1_1ChainAdapter.html#ae0da89bb79dfcf55034ec241014f393f">difference_type</a> = std::common_type_t&lt;std::iter_difference_t&lt;Iter1&gt;, std::iter_difference_t&lt;Iter2&gt;&gt;;</div>
<div class="line">  <span class="keyword">using </span><a id="a130" name="a130"></a><a class="code hl_typedef" href="classhelios_1_1utils_1_1ChainAdapter.html#a0deb22c1e54bfed5b4d8852a31a500c6">pointer</a> = <a class="code hl_typedef" href="classhelios_1_1utils_1_1ChainAdapter.html#a8e2b8edb8500a1b0c3514185ff6463ec">value_type</a>*;</div>
<div class="line">  <span class="keyword">using </span><a id="a131" name="a131"></a><a class="code hl_typedef" href="classhelios_1_1utils_1_1ChainAdapter.html#aadd5ad34997e979db16c23a3b852d4e2">reference</a> = <a class="code hl_typedef" href="classhelios_1_1utils_1_1ChainAdapter.html#a8e2b8edb8500a1b0c3514185ff6463ec">value_type</a>;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /**</span></div>
<div class="line"><span class="comment">   * @brief Constructs a chain adapter with two iterator ranges.</span></div>
<div class="line"><span class="comment">   * @param first_begin Start of the first iterator range</span></div>
<div class="line"><span class="comment">   * @param first_end End of the first iterator range</span></div>
<div class="line"><span class="comment">   * @param second_begin Start of the second iterator range</span></div>
<div class="line"><span class="comment">   * @param second_end End of the second iterator range</span></div>
<div class="line"><span class="comment">   */</span></div>
<div class="line">  <span class="keyword">constexpr</span> ChainAdapter(Iter1 first_begin, Iter1 first_end, Iter2 second_begin,</div>
<div class="line">                         Iter2 second_end) <span class="keyword">noexcept</span>(std::is_nothrow_move_constructible_v&lt;Iter1&gt; &amp;&amp;</div>
<div class="line">                                                    std::is_nothrow_move_constructible_v&lt;Iter2&gt; &amp;&amp;</div>
<div class="line">                                                    <span class="keyword">noexcept</span>(std::declval&lt;Iter1&amp;&gt;() != std::declval&lt;Iter1&amp;&gt;()))</div>
<div class="line">      : first_current_(std::move(first_begin)),</div>
<div class="line">        first_end_(std::move(first_end)),</div>
<div class="line">        second_current_(std::move(second_begin)),</div>
<div class="line">        second_end_(std::move(second_end)),</div>
<div class="line">        in_first_(first_current_ != first_end_) {}</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">constexpr</span> ChainAdapter(<span class="keyword">const</span> ChainAdapter&amp;) <span class="keyword">noexcept</span>(std::is_nothrow_copy_constructible_v&lt;Iter1&gt; &amp;&amp;</div>
<div class="line">                                                       std::is_nothrow_copy_constructible_v&lt;Iter2&gt;) = <span class="keywordflow">default</span>;</div>
<div class="line">  <span class="keyword">constexpr</span> ChainAdapter(ChainAdapter&amp;&amp;) <span class="keyword">noexcept</span>(std::is_nothrow_move_constructible_v&lt;Iter1&gt; &amp;&amp;</div>
<div class="line">                                                  std::is_nothrow_move_constructible_v&lt;Iter2&gt;) = <span class="keywordflow">default</span>;</div>
<div class="line">  <span class="keyword">constexpr</span> <a id="a132" name="a132"></a><a class="code hl_function" href="classhelios_1_1utils_1_1ChainAdapter.html#a721626a9ee24136fac8453764cf94699">~ChainAdapter</a>() <span class="keyword">noexcept</span>(std::is_nothrow_destructible_v&lt;Iter1&gt; &amp;&amp;</div>
<div class="line">                                     std::is_nothrow_destructible_v&lt;Iter2&gt;) = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">constexpr</span> ChainAdapter&amp; <a id="a133" name="a133"></a><a class="code hl_function" href="classhelios_1_1utils_1_1ChainAdapter.html#a32c2c7be3b12012fede6081d3de0d917">operator=</a>(<span class="keyword">const</span> ChainAdapter&amp;) <span class="keyword">noexcept</span>(std::is_nothrow_copy_assignable_v&lt;Iter1&gt; &amp;&amp;</div>
<div class="line">                                                                  std::is_nothrow_copy_assignable_v&lt;Iter2&gt;) = <span class="keywordflow">default</span>;</div>
<div class="line">  <span class="keyword">constexpr</span> ChainAdapter&amp; <a class="code hl_function" href="classhelios_1_1utils_1_1ChainAdapter.html#a32c2c7be3b12012fede6081d3de0d917">operator=</a>(ChainAdapter&amp;&amp;) <span class="keyword">noexcept</span>(std::is_nothrow_move_assignable_v&lt;Iter1&gt; &amp;&amp;</div>
<div class="line">                                                             std::is_nothrow_move_assignable_v&lt;Iter2&gt;) = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">constexpr</span> ChainAdapter&amp; <a id="a134" name="a134"></a><a class="code hl_function" href="classhelios_1_1utils_1_1ChainAdapter.html#a3a8275d11f139d46ccc715db0bb3dcbe">operator++</a>() <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(++std::declval&lt;Iter1&amp;&gt;()) &amp;&amp;</div>
<div class="line">                                                <span class="keyword">noexcept</span>(++std::declval&lt;Iter2&amp;&gt;()) &amp;&amp;</div>
<div class="line">                                                <span class="keyword">noexcept</span>(std::declval&lt;Iter1&amp;&gt;() == std::declval&lt;Iter1&amp;&gt;()) &amp;&amp;</div>
<div class="line">                                                <span class="keyword">noexcept</span>(std::declval&lt;Iter2&amp;&gt;() != std::declval&lt;Iter2&amp;&gt;()));</div>
<div class="line">  <span class="keyword">constexpr</span> ChainAdapter <a class="code hl_function" href="classhelios_1_1utils_1_1ChainAdapter.html#a3a8275d11f139d46ccc715db0bb3dcbe">operator++</a>(<span class="keywordtype">int</span>) <span class="keyword">noexcept</span>(std::is_nothrow_copy_constructible_v&lt;ChainAdapter&gt; &amp;&amp;</div>
<div class="line">                                                  <span class="keyword">noexcept</span>(++std::declval&lt;ChainAdapter&amp;&gt;()));</div>
<div class="line"> </div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> <a class="code hl_typedef" href="classhelios_1_1utils_1_1ChainAdapter.html#a8e2b8edb8500a1b0c3514185ff6463ec">value_type</a> <a id="a135" name="a135"></a><a class="code hl_function" href="classhelios_1_1utils_1_1ChainAdapter.html#a450b3956aaefa50deb0bf40d06ca1c23">operator*</a>() <span class="keyword">const</span></div>
<div class="line">      <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(*std::declval&lt;const Iter1&amp;&gt;()) &amp;&amp; <span class="keyword">noexcept</span>(*std::declval&lt;const Iter2&amp;&gt;())) {</div>
<div class="line">    <span class="keywordflow">return</span> in_first_ ? *first_current_ : *second_current_;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> <span class="keywordtype">bool</span> <a id="a136" name="a136"></a><a class="code hl_function" href="classhelios_1_1utils_1_1ChainAdapter.html#a24d079ad5a4b289c447a207a9d7e5f9f">operator==</a>(<span class="keyword">const</span> ChainAdapter&amp; other) <span class="keyword">const</span></div>
<div class="line">      <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(std::declval&lt;const Iter1&amp;&gt;() == std::declval&lt;const Iter1&amp;&gt;()) &amp;&amp;</div>
<div class="line">               <span class="keyword">noexcept</span>(std::declval&lt;const Iter2&amp;&gt;() == std::declval&lt;const Iter2&amp;&gt;()));</div>
<div class="line"> </div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> <span class="keywordtype">bool</span> <a id="a137" name="a137"></a><a class="code hl_function" href="classhelios_1_1utils_1_1ChainAdapter.html#a7d78c23fb348e6a613685e3f74d157ae">operator!=</a>(<span class="keyword">const</span> ChainAdapter&amp; other) <span class="keyword">const</span></div>
<div class="line">      <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(std::declval&lt;const ChainAdapter&amp;&gt;() == std::declval&lt;const ChainAdapter&amp;&gt;())) {</div>
<div class="line">    <span class="keywordflow">return</span> !(*<span class="keyword">this</span> == other);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> ChainAdapter <a id="a138" name="a138"></a><a class="code hl_function" href="classhelios_1_1utils_1_1ChainAdapter.html#ab6d6d5adc3b94d6604c1b90da9978223">begin</a>() <span class="keyword">const</span> <span class="keyword">noexcept</span>(std::is_nothrow_copy_constructible_v&lt;ChainAdapter&gt;) {</div>
<div class="line">    <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> ChainAdapter <a id="a139" name="a139"></a><a class="code hl_function" href="classhelios_1_1utils_1_1ChainAdapter.html#a02e09c72c1f7579cf1aebd23e952a9f3">end</a>() <span class="keyword">const</span></div>
<div class="line">      <span class="keyword">noexcept</span>(std::is_nothrow_copy_constructible_v&lt;ChainAdapter&gt; &amp;&amp; std::is_nothrow_copy_constructible_v&lt;Iter1&gt; &amp;&amp;</div>
<div class="line">               std::is_nothrow_copy_constructible_v&lt;Iter2&gt;);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  Iter1 first_current_;   <span class="comment">///&lt; Current position in first iterator</span></div>
<div class="line">  Iter1 first_end_;       <span class="comment">///&lt; End of first iterator range</span></div>
<div class="line">  Iter2 second_current_;  <span class="comment">///&lt; Current position in second iterator</span></div>
<div class="line">  Iter2 second_end_;      <span class="comment">///&lt; End of second iterator range</span></div>
<div class="line">  <span class="keywordtype">bool</span> in_first_ = <span class="keyword">true</span>;  <span class="comment">///&lt; Whether iterating through first range</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter1, <span class="keyword">typename</span> Iter2&gt;</div>
<div class="line">  <span class="keyword">requires</span> ChainAdapterRequirements&lt;Iter1, Iter2&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <a class="code hl_function" href="classhelios_1_1utils_1_1ChainAdapter.html#a3a8275d11f139d46ccc715db0bb3dcbe">ChainAdapter&lt;Iter1, Iter2&gt;::operator++</a>() <span class="keyword">noexcept</span>(</div>
<div class="line">    <span class="keyword">noexcept</span>(++std::declval&lt;Iter1&amp;&gt;()) &amp;&amp; <span class="keyword">noexcept</span>(++std::declval&lt;Iter2&amp;&gt;()) &amp;&amp;</div>
<div class="line">    <span class="keyword">noexcept</span>(std::declval&lt;Iter1&amp;&gt;() == std::declval&lt;Iter1&amp;&gt;()) &amp;&amp;</div>
<div class="line">    <span class="keyword">noexcept</span>(std::declval&lt;Iter2&amp;&gt;() != std::declval&lt;Iter2&amp;&gt;())) -&gt; ChainAdapter&amp; {</div>
<div class="line">  <span class="keywordflow">if</span> (in_first_) {</div>
<div class="line">    ++first_current_;</div>
<div class="line">    <span class="keywordflow">if</span> (first_current_ == first_end_) {</div>
<div class="line">      in_first_ = <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="keywordflow">if</span> (second_current_ != second_end_) {</div>
<div class="line">      ++second_current_;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter1, <span class="keyword">typename</span> Iter2&gt;</div>
<div class="line">  <span class="keyword">requires</span> ChainAdapterRequirements&lt;Iter1, Iter2&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <a class="code hl_function" href="classhelios_1_1utils_1_1ChainAdapter.html#a3a8275d11f139d46ccc715db0bb3dcbe">ChainAdapter&lt;Iter1, Iter2&gt;::operator++</a>(<span class="keywordtype">int</span>) <span class="keyword">noexcept</span>(</div>
<div class="line">    std::is_nothrow_copy_constructible_v&lt;ChainAdapter&gt; &amp;&amp; <span class="keyword">noexcept</span>(++std::declval&lt;ChainAdapter&amp;&gt;())) -&gt; ChainAdapter {</div>
<div class="line">  <span class="keyword">auto</span> temp = *<span class="keyword">this</span>;</div>
<div class="line">  ++(*this);</div>
<div class="line">  <span class="keywordflow">return</span> temp;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter1, <span class="keyword">typename</span> Iter2&gt;</div>
<div class="line">  <span class="keyword">requires</span> ChainAdapterRequirements&lt;Iter1, Iter2&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keywordtype">bool</span> <a class="code hl_function" href="classhelios_1_1utils_1_1ChainAdapter.html#a24d079ad5a4b289c447a207a9d7e5f9f">ChainAdapter&lt;Iter1, Iter2&gt;::operator==</a>(<span class="keyword">const</span> ChainAdapter&amp; other) <span class="keyword">const</span></div>
<div class="line">    <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(std::declval&lt;const Iter1&amp;&gt;() == std::declval&lt;const Iter1&amp;&gt;()) &amp;&amp;</div>
<div class="line">             <span class="keyword">noexcept</span>(std::declval&lt;const Iter2&amp;&gt;() == std::declval&lt;const Iter2&amp;&gt;())) {</div>
<div class="line">  <span class="comment">// Check if both are at end (in second range and at second_end_)</span></div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">bool</span> this_at_end = !in_first_ &amp;&amp; (second_current_ == second_end_);</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">bool</span> other_at_end = !other.in_first_ &amp;&amp; (other.second_current_ == other.second_end_);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (this_at_end &amp;&amp; other_at_end) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Otherwise, must be in same range at same position</span></div>
<div class="line">  <span class="keywordflow">if</span> (in_first_ != other.in_first_) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> in_first_ ? (first_current_ == other.first_current_) : (second_current_ == other.second_current_);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter1, <span class="keyword">typename</span> Iter2&gt;</div>
<div class="line">  <span class="keyword">requires</span> ChainAdapterRequirements&lt;Iter1, Iter2&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <a class="code hl_function" href="classhelios_1_1utils_1_1ChainAdapter.html#a02e09c72c1f7579cf1aebd23e952a9f3">ChainAdapter&lt;Iter1, Iter2&gt;::end</a>() <span class="keyword">const</span></div>
<div class="line">    <span class="keyword">noexcept</span>(std::is_nothrow_copy_constructible_v&lt;ChainAdapter&gt; &amp;&amp; std::is_nothrow_copy_constructible_v&lt;Iter1&gt; &amp;&amp;</div>
<div class="line">             std::is_nothrow_copy_constructible_v&lt;Iter2&gt;) -&gt; ChainAdapter {</div>
<div class="line">  <span class="keyword">auto</span> end_iter = *<span class="keyword">this</span>;</div>
<div class="line">  end_iter.<a id="a140" name="a140"></a>first_current_ = first_end_;</div>
<div class="line">  end_iter.second_current_ = second_end_;</div>
<div class="line">  end_iter.in_first_ = <span class="keyword">false</span>;</div>
<div class="line">  <span class="keywordflow">return</span> end_iter;</div>
<div class="line">}</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * @brief Adapter that iterates through elements in reverse order.</span></div>
<div class="line"><span class="comment"> * @details Requires a bidirectional iterator. Uses operator-- to traverse backwards.</span></div>
<div class="line"><span class="comment"> * @tparam Iter Type of the underlying iterator</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * @example</span></div>
<div class="line"><span class="comment"> * @code</span></div>
<div class="line"><span class="comment"> * // Reverse iterate through entities</span></div>
<div class="line"><span class="comment"> * auto reversed = query.Reverse();</span></div>
<div class="line"><span class="comment"> * @endcode</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</div>
<div class="line">  <span class="keyword">requires</span> ReverseAdapterRequirements&lt;Iter&gt;</div>
<div class="line"><span class="keyword">class </span>ReverseAdapter final : <span class="keyword">public</span> FunctionalAdapterBase&lt;ReverseAdapter&lt;Iter&gt;&gt; {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">using </span><a id="a141" name="a141"></a><a class="code hl_typedef" href="classhelios_1_1utils_1_1ReverseAdapter.html#a0a3d06fab6819e6cabed1ab7d12b64d1">iterator_category</a> = std::bidirectional_iterator_tag;</div>
<div class="line">  <span class="keyword">using </span><a id="a142" name="a142"></a><a class="code hl_typedef" href="classhelios_1_1utils_1_1ReverseAdapter.html#a1d9dbd4e44312d4efe16924b844d8d69">value_type</a> = std::iter_value_t&lt;Iter&gt;;</div>
<div class="line">  <span class="keyword">using </span><a id="a143" name="a143"></a><a class="code hl_typedef" href="classhelios_1_1utils_1_1ReverseAdapter.html#a1f4898e6dc036cc99f329aa9827ada92">difference_type</a> = std::iter_difference_t&lt;Iter&gt;;</div>
<div class="line">  <span class="keyword">using </span><a id="a144" name="a144"></a><a class="code hl_typedef" href="classhelios_1_1utils_1_1ReverseAdapter.html#a0016a78e71908e23969dad3bd1cbad35">pointer</a> = <a class="code hl_typedef" href="classhelios_1_1utils_1_1ReverseAdapter.html#a1d9dbd4e44312d4efe16924b844d8d69">value_type</a>*;</div>
<div class="line">  <span class="keyword">using </span><a id="a145" name="a145"></a><a class="code hl_typedef" href="classhelios_1_1utils_1_1ReverseAdapter.html#acb920920722e8f59de1595671ad11c3d">reference</a> = <a class="code hl_typedef" href="classhelios_1_1utils_1_1ReverseAdapter.html#a1d9dbd4e44312d4efe16924b844d8d69">value_type</a>;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /**</span></div>
<div class="line"><span class="comment">   * @brief Constructs a reverse adapter.</span></div>
<div class="line"><span class="comment">   * @param begin Iterator to the beginning of the range</span></div>
<div class="line"><span class="comment">   * @param end Iterator to the end of the range</span></div>
<div class="line"><span class="comment">   */</span></div>
<div class="line">  <span class="keyword">constexpr</span> ReverseAdapter(Iter <a id="a146" name="a146"></a><a class="code hl_function" href="classhelios_1_1utils_1_1ReverseAdapter.html#a687dad1f29e1f36aebdf922b3b897d2f">begin</a>, Iter <a id="a147" name="a147"></a><a class="code hl_function" href="classhelios_1_1utils_1_1ReverseAdapter.html#a4d3cbce219d27af71b91791f425a8150">end</a>) <span class="keyword">noexcept</span>(std::is_nothrow_move_constructible_v&lt;Iter&gt; &amp;&amp;</div>
<div class="line">                                                          std::is_nothrow_copy_constructible_v&lt;Iter&gt; &amp;&amp;</div>
<div class="line">                                                          <span class="keyword">noexcept</span>(std::declval&lt;Iter&amp;&gt;() == std::declval&lt;Iter&amp;&gt;()) &amp;&amp;</div>
<div class="line">                                                          <span class="keyword">noexcept</span>(--std::declval&lt;Iter&amp;&gt;()));</div>
<div class="line">  <span class="keyword">constexpr</span> ReverseAdapter(<span class="keyword">const</span> ReverseAdapter&amp;) <span class="keyword">noexcept</span>(std::is_nothrow_copy_constructible_v&lt;Iter&gt;) = <span class="keywordflow">default</span>;</div>
<div class="line">  <span class="keyword">constexpr</span> ReverseAdapter(ReverseAdapter&amp;&amp;) <span class="keyword">noexcept</span>(std::is_nothrow_move_constructible_v&lt;Iter&gt;) = <span class="keywordflow">default</span>;</div>
<div class="line">  <span class="keyword">constexpr</span> <a id="a148" name="a148"></a><a class="code hl_function" href="classhelios_1_1utils_1_1ReverseAdapter.html#a332259986bc53236f836c8e5a2815895">~ReverseAdapter</a>() <span class="keyword">noexcept</span>(std::is_nothrow_destructible_v&lt;Iter&gt;) = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">constexpr</span> ReverseAdapter&amp; <a id="a149" name="a149"></a><a class="code hl_function" href="classhelios_1_1utils_1_1ReverseAdapter.html#a33e10fd7dd3463f8f56d3cc1f5e60b84">operator=</a>(<span class="keyword">const</span> ReverseAdapter&amp;) <span class="keyword">noexcept</span>(std::is_nothrow_copy_assignable_v&lt;Iter&gt;) =</div>
<div class="line">      <span class="keywordflow">default</span>;</div>
<div class="line">  <span class="keyword">constexpr</span> ReverseAdapter&amp; <a class="code hl_function" href="classhelios_1_1utils_1_1ReverseAdapter.html#a33e10fd7dd3463f8f56d3cc1f5e60b84">operator=</a>(ReverseAdapter&amp;&amp;) <span class="keyword">noexcept</span>(std::is_nothrow_move_assignable_v&lt;Iter&gt;) = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">constexpr</span> ReverseAdapter&amp; <a id="a150" name="a150"></a><a class="code hl_function" href="classhelios_1_1utils_1_1ReverseAdapter.html#a5d7c9ff067c6e550836d27aa49ab821b">operator++</a>() <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(std::declval&lt;Iter&amp;&gt;() == std::declval&lt;Iter&amp;&gt;()) &amp;&amp;</div>
<div class="line">                                                  <span class="keyword">noexcept</span>(--std::declval&lt;Iter&amp;&gt;()));</div>
<div class="line">  <span class="keyword">constexpr</span> ReverseAdapter <a class="code hl_function" href="classhelios_1_1utils_1_1ReverseAdapter.html#a5d7c9ff067c6e550836d27aa49ab821b">operator++</a>(<span class="keywordtype">int</span>) <span class="keyword">noexcept</span>(std::is_nothrow_copy_constructible_v&lt;ReverseAdapter&gt; &amp;&amp;</div>
<div class="line">                                                    <span class="keyword">noexcept</span>(++std::declval&lt;ReverseAdapter&amp;&gt;()));</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">constexpr</span> ReverseAdapter&amp; <a id="a151" name="a151"></a><a class="code hl_function" href="classhelios_1_1utils_1_1ReverseAdapter.html#a4f0c20587413122ef5dc052daffbd951">operator--</a>() <span class="keyword">noexcept</span>(std::is_nothrow_copy_constructible_v&lt;Iter&gt; &amp;&amp;</div>
<div class="line">                                                  <span class="keyword">noexcept</span>(++std::declval&lt;Iter&amp;&gt;()) &amp;&amp;</div>
<div class="line">                                                  <span class="keyword">noexcept</span>(std::declval&lt;Iter&amp;&gt;() != std::declval&lt;Iter&amp;&gt;()));</div>
<div class="line">  <span class="keyword">constexpr</span> ReverseAdapter <a class="code hl_function" href="classhelios_1_1utils_1_1ReverseAdapter.html#a4f0c20587413122ef5dc052daffbd951">operator--</a>(<span class="keywordtype">int</span>) <span class="keyword">noexcept</span>(std::is_nothrow_copy_constructible_v&lt;ReverseAdapter&gt; &amp;&amp;</div>
<div class="line">                                                    <span class="keyword">noexcept</span>(--std::declval&lt;ReverseAdapter&amp;&gt;()));</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">constexpr</span> <a class="code hl_typedef" href="classhelios_1_1utils_1_1ReverseAdapter.html#a1d9dbd4e44312d4efe16924b844d8d69">value_type</a> <a id="a152" name="a152"></a><a class="code hl_function" href="classhelios_1_1utils_1_1ReverseAdapter.html#a1d48b20946337845a42b070e83d5ff9f">operator*</a>() <span class="keyword">const</span> <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(*std::declval&lt;const Iter&amp;&gt;())) { <span class="keywordflow">return</span> *current_; }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">constexpr</span> <span class="keywordtype">bool</span> <a id="a153" name="a153"></a><a class="code hl_function" href="classhelios_1_1utils_1_1ReverseAdapter.html#a75016224852787fd29203a5d6254a14d">operator==</a>(<span class="keyword">const</span> ReverseAdapter&amp; other) <span class="keyword">const</span></div>
<div class="line">      <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(std::declval&lt;const Iter&amp;&gt;() == std::declval&lt;const Iter&amp;&gt;()));</div>
<div class="line">  <span class="keyword">constexpr</span> <span class="keywordtype">bool</span> <a id="a154" name="a154"></a><a class="code hl_function" href="classhelios_1_1utils_1_1ReverseAdapter.html#a964fd09ecfa6872fa8fbc357a0c31b12">operator!=</a>(<span class="keyword">const</span> ReverseAdapter&amp; other) <span class="keyword">const</span></div>
<div class="line">      <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(std::declval&lt;ReverseAdapter&gt;() == std::declval&lt;ReverseAdapter&gt;())) {</div>
<div class="line">    <span class="keywordflow">return</span> !(*<span class="keyword">this</span> == other);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">constexpr</span> ReverseAdapter <a class="code hl_function" href="classhelios_1_1utils_1_1ReverseAdapter.html#a687dad1f29e1f36aebdf922b3b897d2f">begin</a>() <span class="keyword">const</span> <span class="keyword">noexcept</span>(std::is_nothrow_copy_constructible_v&lt;ReverseAdapter&gt;) {</div>
<div class="line">    <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">constexpr</span> ReverseAdapter <a class="code hl_function" href="classhelios_1_1utils_1_1ReverseAdapter.html#a4d3cbce219d27af71b91791f425a8150">end</a>() <span class="keyword">const</span> <span class="keyword">noexcept</span>(std::is_nothrow_copy_constructible_v&lt;ReverseAdapter&gt;);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  Iter begin_;</div>
<div class="line">  Iter current_;</div>
<div class="line">  Iter end_;</div>
<div class="line">  <span class="keywordtype">bool</span> done_ = <span class="keyword">false</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</div>
<div class="line">  <span class="keyword">requires</span> ReverseAdapterRequirements&lt;Iter&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <a id="a155" name="a155"></a><a class="code hl_function" href="classhelios_1_1utils_1_1ReverseAdapter.html#a0069640d5679ee7c4b060958ff4569b9">ReverseAdapter&lt;Iter&gt;::ReverseAdapter</a>(Iter begin, Iter end) <span class="keyword">noexcept</span>(</div>
<div class="line">    std::is_nothrow_move_constructible_v&lt;Iter&gt; &amp;&amp; std::is_nothrow_copy_constructible_v&lt;Iter&gt; &amp;&amp;</div>
<div class="line">    <span class="keyword">noexcept</span>(std::declval&lt;Iter&amp;&gt;() == std::declval&lt;Iter&amp;&gt;()) &amp;&amp; <span class="keyword">noexcept</span>(--std::declval&lt;Iter&amp;&gt;()))</div>
<div class="line">    : begin_(std::move(begin)), current_(std::move(end)), end_(current_), done_(begin_ == end_) {</div>
<div class="line">  <span class="keywordflow">if</span> (current_ != begin_) {</div>
<div class="line">    --current_;</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</div>
<div class="line">  <span class="keyword">requires</span> ReverseAdapterRequirements&lt;Iter&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <a class="code hl_function" href="classhelios_1_1utils_1_1ReverseAdapter.html#a5d7c9ff067c6e550836d27aa49ab821b">ReverseAdapter&lt;Iter&gt;::operator++</a>() <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(std::declval&lt;Iter&amp;&gt;() == std::declval&lt;Iter&amp;&gt;()) &amp;&amp;</div>
<div class="line">                                                           <span class="keyword">noexcept</span>(--std::declval&lt;Iter&amp;&gt;())) -&gt; ReverseAdapter&amp; {</div>
<div class="line">  <span class="keywordflow">if</span> (!done_) {</div>
<div class="line">    <span class="keywordflow">if</span> (current_ == begin_) {</div>
<div class="line">      done_ = <span class="keyword">true</span>;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      --current_;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</div>
<div class="line">  <span class="keyword">requires</span> ReverseAdapterRequirements&lt;Iter&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <a class="code hl_function" href="classhelios_1_1utils_1_1ReverseAdapter.html#a5d7c9ff067c6e550836d27aa49ab821b">ReverseAdapter&lt;Iter&gt;::operator++</a>(<span class="keywordtype">int</span>) <span class="keyword">noexcept</span>(std::is_nothrow_copy_constructible_v&lt;ReverseAdapter&gt; &amp;&amp;</div>
<div class="line">                                                              <span class="keyword">noexcept</span>(++std::declval&lt;ReverseAdapter&amp;&gt;()))</div>
<div class="line">    -&gt; ReverseAdapter {</div>
<div class="line">  <span class="keyword">auto</span> temp = *<span class="keyword">this</span>;</div>
<div class="line">  ++(*this);</div>
<div class="line">  <span class="keywordflow">return</span> temp;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</div>
<div class="line">  <span class="keyword">requires</span> ReverseAdapterRequirements&lt;Iter&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <a class="code hl_function" href="classhelios_1_1utils_1_1ReverseAdapter.html#a4f0c20587413122ef5dc052daffbd951">ReverseAdapter&lt;Iter&gt;::operator--</a>() <span class="keyword">noexcept</span>(std::is_nothrow_copy_constructible_v&lt;Iter&gt; &amp;&amp;</div>
<div class="line">                                                           <span class="keyword">noexcept</span>(++std::declval&lt;Iter&amp;&gt;()) &amp;&amp;</div>
<div class="line">                                                           <span class="keyword">noexcept</span>(std::declval&lt;Iter&amp;&gt;() != std::declval&lt;Iter&amp;&gt;()))</div>
<div class="line">    -&gt; ReverseAdapter&amp; {</div>
<div class="line">  <span class="keywordflow">if</span> (done_) {</div>
<div class="line">    done_ = <span class="keyword">false</span>;</div>
<div class="line">    current_ = begin_;</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="keywordflow">if</span> (current_ != end_) {</div>
<div class="line">      ++current_;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</div>
<div class="line">  <span class="keyword">requires</span> ReverseAdapterRequirements&lt;Iter&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <a class="code hl_function" href="classhelios_1_1utils_1_1ReverseAdapter.html#a4f0c20587413122ef5dc052daffbd951">ReverseAdapter&lt;Iter&gt;::operator--</a>(<span class="keywordtype">int</span>) <span class="keyword">noexcept</span>(std::is_nothrow_copy_constructible_v&lt;ReverseAdapter&gt; &amp;&amp;</div>
<div class="line">                                                              <span class="keyword">noexcept</span>(--std::declval&lt;ReverseAdapter&amp;&gt;()))</div>
<div class="line">    -&gt; ReverseAdapter {</div>
<div class="line">  <span class="keyword">auto</span> temp = *<span class="keyword">this</span>;</div>
<div class="line">  --(*this);</div>
<div class="line">  <span class="keywordflow">return</span> temp;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</div>
<div class="line">  <span class="keyword">requires</span> ReverseAdapterRequirements&lt;Iter&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keywordtype">bool</span> <a class="code hl_function" href="classhelios_1_1utils_1_1ReverseAdapter.html#a75016224852787fd29203a5d6254a14d">ReverseAdapter&lt;Iter&gt;::operator==</a>(<span class="keyword">const</span> ReverseAdapter&amp; other) <span class="keyword">const</span></div>
<div class="line">    <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(std::declval&lt;const Iter&amp;&gt;() == std::declval&lt;const Iter&amp;&gt;())) {</div>
<div class="line">  <span class="keywordflow">if</span> (done_ &amp;&amp; other.done_) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> done_ == other.done_ &amp;&amp; current_ == other.current_;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</div>
<div class="line">  <span class="keyword">requires</span> ReverseAdapterRequirements&lt;Iter&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <a class="code hl_function" href="classhelios_1_1utils_1_1ReverseAdapter.html#a4d3cbce219d27af71b91791f425a8150">ReverseAdapter&lt;Iter&gt;::end</a>() <span class="keyword">const</span> <span class="keyword">noexcept</span>(std::is_nothrow_copy_constructible_v&lt;ReverseAdapter&gt;)</div>
<div class="line">    -&gt; ReverseAdapter {</div>
<div class="line">  <span class="keyword">auto</span> result = *<span class="keyword">this</span>;</div>
<div class="line">  result.<a id="a156" name="a156"></a>done_ = <span class="keyword">true</span>;</div>
<div class="line">  <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * @brief Adapter that flattens nested ranges into a single sequence.</span></div>
<div class="line"><span class="comment"> * @details Iterates through an outer range of ranges, yielding elements from inner ranges.</span></div>
<div class="line"><span class="comment"> * @tparam Iter Type of the outer iterator</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * @example</span></div>
<div class="line"><span class="comment"> * @code</span></div>
<div class="line"><span class="comment"> * // Join queries of `Position` and `Velocity` components</span></div>
<div class="line"><span class="comment"> * auto joined = query1.Join(query2);</span></div>
<div class="line"><span class="comment"> * joined.ForEach([](const Position&amp; pos, const Velocity&amp; vel) {</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</div>
<div class="line">  <span class="keyword">requires</span> JoinAdapterRequirements&lt;Iter&gt;</div>
<div class="line"><span class="keyword">class </span>JoinAdapter final : <span class="keyword">public</span> FunctionalAdapterBase&lt;JoinAdapter&lt;Iter&gt;&gt; {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">using </span>iterator_category = std::forward_iterator_tag;</div>
<div class="line">  <span class="keyword">using </span>outer_value_type = std::iter_value_t&lt;Iter&gt;;</div>
<div class="line">  <span class="keyword">using </span>inner_iterator_type = std::ranges::iterator_t&lt;outer_value_type&gt;;</div>
<div class="line">  <span class="keyword">using </span>value_type = std::iter_value_t&lt;inner_iterator_type&gt;;</div>
<div class="line">  <span class="keyword">using </span>difference_type = std::ptrdiff_t;</div>
<div class="line">  <span class="keyword">using </span>pointer = value_type*;</div>
<div class="line">  <span class="keyword">using </span>reference = value_type;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /**</span></div>
<div class="line"><span class="comment">   * @brief Constructs a join adapter.</span></div>
<div class="line"><span class="comment">   * @param begin Iterator to the beginning of the outer range</span></div>
<div class="line"><span class="comment">   * @param end Iterator to the end of the outer range</span></div>
<div class="line"><span class="comment">   */</span></div>
<div class="line">  <span class="keyword">constexpr</span> JoinAdapter(Iter begin, Iter end) <span class="keyword">noexcept</span>(std::is_nothrow_move_constructible_v&lt;Iter&gt; &amp;&amp;</div>
<div class="line">                                                       std::is_nothrow_copy_constructible_v&lt;Iter&gt; &amp;&amp;</div>
<div class="line">                                                       std::is_nothrow_move_constructible_v&lt;inner_iterator_type&gt; &amp;&amp;</div>
<div class="line">                                                       <span class="keyword">noexcept</span>(std::declval&lt;Iter&amp;&gt;() != std::declval&lt;Iter&amp;&gt;()) &amp;&amp;</div>
<div class="line">                                                       <span class="keyword">noexcept</span>(*std::declval&lt;inner_iterator_type&amp;&gt;()) &amp;&amp;</div>
<div class="line">                                                       <span class="keyword">noexcept</span>(AdvanceToValid()));</div>
<div class="line">  <span class="keyword">constexpr</span> JoinAdapter(<span class="keyword">const</span> JoinAdapter&amp;) <span class="keyword">noexcept</span>(std::is_nothrow_copy_constructible_v&lt;Iter&gt; &amp;&amp;</div>
<div class="line">                                                     std::is_nothrow_copy_constructible_v&lt;inner_iterator_type&gt;) =</div>
<div class="line">      <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">constexpr</span> JoinAdapter(JoinAdapter&amp;&amp;) <span class="keyword">noexcept</span>(std::is_nothrow_move_constructible_v&lt;Iter&gt; &amp;&amp;</div>
<div class="line">                                                std::is_nothrow_move_constructible_v&lt;inner_iterator_type&gt;) = <span class="keywordflow">default</span>;</div>
<div class="line">  <span class="keyword">constexpr</span> ~JoinAdapter() <span class="keyword">noexcept</span>(std::is_nothrow_destructible_v&lt;Iter&gt; &amp;&amp;</div>
<div class="line">                                    std::is_nothrow_destructible_v&lt;inner_iterator_type&gt;) = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">constexpr</span> JoinAdapter&amp; operator=(<span class="keyword">const</span> JoinAdapter&amp;) <span class="keyword">noexcept</span>(</div>
<div class="line">      std::is_nothrow_copy_assignable_v&lt;Iter&gt; &amp;&amp; std::is_nothrow_copy_assignable_v&lt;inner_iterator_type&gt;) = <span class="keywordflow">default</span>;</div>
<div class="line">  <span class="keyword">constexpr</span> JoinAdapter&amp; operator=(JoinAdapter&amp;&amp;) <span class="keyword">noexcept</span>(</div>
<div class="line">      std::is_nothrow_move_assignable_v&lt;Iter&gt; &amp;&amp; std::is_nothrow_move_assignable_v&lt;inner_iterator_type&gt;) = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">constexpr</span> JoinAdapter&amp; operator++() <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(std::declval&lt;inner_iterator_type&amp;&gt;() !=</div>
<div class="line">                                                        std::declval&lt;inner_iterator_type&amp;&gt;()) &amp;&amp;</div>
<div class="line">                                               <span class="keyword">noexcept</span>(++std::declval&lt;inner_iterator_type&amp;&gt;()) &amp;&amp;</div>
<div class="line">                                               <span class="keyword">noexcept</span>(AdvanceToValid()));</div>
<div class="line">  <span class="keyword">constexpr</span> JoinAdapter operator++(<span class="keywordtype">int</span>) <span class="keyword">noexcept</span>(std::is_nothrow_copy_constructible_v&lt;JoinAdapter&gt; &amp;&amp;</div>
<div class="line">                                                 <span class="keyword">noexcept</span>(++std::declval&lt;JoinAdapter&amp;&gt;()));</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">constexpr</span> value_type operator*() <span class="keyword">const</span> <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(*std::declval&lt;const inner_iterator_type&amp;&gt;())) {</div>
<div class="line">    <span class="keywordflow">return</span> *inner_current_;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">constexpr</span> <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> JoinAdapter&amp; other) <span class="keyword">const</span></div>
<div class="line">      <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(std::declval&lt;const Iter&amp;&gt;() == std::declval&lt;const Iter&amp;&gt;()) &amp;&amp;</div>
<div class="line">               <span class="keyword">noexcept</span>(std::declval&lt;const inner_iterator_type&amp;&gt;() == std::declval&lt;const inner_iterator_type&amp;&gt;()));</div>
<div class="line">  <span class="keyword">constexpr</span> <span class="keywordtype">bool</span> operator!=(<span class="keyword">const</span> JoinAdapter&amp; other) <span class="keyword">const</span></div>
<div class="line">      <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(std::declval&lt;JoinAdapter&gt;() == std::declval&lt;JoinAdapter&gt;())) {</div>
<div class="line">    <span class="keywordflow">return</span> !(*<span class="keyword">this</span> == other);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">constexpr</span> JoinAdapter begin() <span class="keyword">const</span> <span class="keyword">noexcept</span>(std::is_nothrow_constructible_v&lt;JoinAdapter, const Iter&amp;, const Iter&amp;&gt;) {</div>
<div class="line">    <span class="keywordflow">return</span> {outer_begin_, outer_end_};</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">constexpr</span> JoinAdapter end() <span class="keyword">const</span></div>
<div class="line">      <span class="keyword">noexcept</span>(std::is_nothrow_copy_constructible_v&lt;JoinAdapter&gt; &amp;&amp; std::is_nothrow_copy_assignable_v&lt;Iter&gt;);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keyword">constexpr</span> <span class="keywordtype">void</span> AdvanceToValid() <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(std::declval&lt;Iter&amp;&gt;() == std::declval&lt;Iter&amp;&gt;()) &amp;&amp;</div>
<div class="line">                                           <span class="keyword">noexcept</span>(std::declval&lt;inner_iterator_type&amp;&gt;() ==</div>
<div class="line">                                                    std::declval&lt;inner_iterator_type&amp;&gt;()) &amp;&amp;</div>
<div class="line">                                           <span class="keyword">noexcept</span>(++std::declval&lt;Iter&amp;&gt;()) &amp;&amp; <span class="keyword">noexcept</span>(*std::declval&lt;Iter&amp;&gt;()) &amp;&amp;</div>
<div class="line">                                           std::is_nothrow_move_assignable_v&lt;inner_iterator_type&gt;);</div>
<div class="line"> </div>
<div class="line">  Iter outer_begin_;</div>
<div class="line">  Iter outer_current_;</div>
<div class="line">  Iter outer_end_;</div>
<div class="line">  inner_iterator_type inner_current_;</div>
<div class="line">  inner_iterator_type inner_end_;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</div>
<div class="line">  <span class="keyword">requires</span> JoinAdapterRequirements&lt;Iter&gt;</div>
<div class="line"><span class="keyword">constexpr</span> JoinAdapter&lt;Iter&gt;::JoinAdapter(Iter begin,</div>
<div class="line">                                         Iter end) <span class="keyword">noexcept</span>(std::is_nothrow_move_constructible_v&lt;Iter&gt; &amp;&amp;</div>
<div class="line">                                                            std::is_nothrow_copy_constructible_v&lt;Iter&gt; &amp;&amp;</div>
<div class="line">                                                            std::is_nothrow_move_constructible_v&lt;inner_iterator_type&gt; &amp;&amp;</div>
<div class="line">                                                            <span class="keyword">noexcept</span>(std::declval&lt;Iter&amp;&gt;() != std::declval&lt;Iter&amp;&gt;()) &amp;&amp;</div>
<div class="line">                                                            <span class="keyword">noexcept</span>(*std::declval&lt;inner_iterator_type&amp;&gt;()) &amp;&amp;</div>
<div class="line">                                                            <span class="keyword">noexcept</span>(AdvanceToValid()))</div>
<div class="line">    : outer_begin_(std::move(begin)), outer_current_(outer_begin_), outer_end_(std::move(end)) {</div>
<div class="line">  <span class="keywordflow">if</span> (outer_current_ != outer_end_) {</div>
<div class="line">    <span class="keyword">auto</span>&amp; inner_range = *outer_current_;</div>
<div class="line">    inner_current_ = std::ranges::begin(inner_range);</div>
<div class="line">    inner_end_ = std::ranges::end(inner_range);</div>
<div class="line">  }</div>
<div class="line">  AdvanceToValid();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</div>
<div class="line">  <span class="keyword">requires</span> JoinAdapterRequirements&lt;Iter&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> JoinAdapter&lt;Iter&gt;::operator++() <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(std::declval&lt;inner_iterator_type&amp;&gt;() !=</div>
<div class="line">                                                                 std::declval&lt;inner_iterator_type&amp;&gt;()) &amp;&amp;</div>
<div class="line">                                                        <span class="keyword">noexcept</span>(++std::declval&lt;inner_iterator_type&amp;&gt;()) &amp;&amp;</div>
<div class="line">                                                        <span class="keyword">noexcept</span>(AdvanceToValid())) -&gt; JoinAdapter&amp; {</div>
<div class="line">  <span class="keywordflow">if</span> (inner_current_ != inner_end_) {</div>
<div class="line">    ++inner_current_;</div>
<div class="line">  }</div>
<div class="line">  AdvanceToValid();</div>
<div class="line">  <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</div>
<div class="line">  <span class="keyword">requires</span> JoinAdapterRequirements&lt;Iter&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> JoinAdapter&lt;Iter&gt;::operator++(<span class="keywordtype">int</span>) <span class="keyword">noexcept</span>(std::is_nothrow_copy_constructible_v&lt;JoinAdapter&gt; &amp;&amp;</div>
<div class="line">                                                           <span class="keyword">noexcept</span>(++std::declval&lt;JoinAdapter&amp;&gt;())) -&gt; JoinAdapter {</div>
<div class="line">  <span class="keyword">auto</span> temp = *<span class="keyword">this</span>;</div>
<div class="line">  ++(*this);</div>
<div class="line">  <span class="keywordflow">return</span> temp;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</div>
<div class="line">  <span class="keyword">requires</span> JoinAdapterRequirements&lt;Iter&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keywordtype">bool</span> JoinAdapter&lt;Iter&gt;::operator==(<span class="keyword">const</span> JoinAdapter&amp; other) <span class="keyword">const</span></div>
<div class="line">    <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(std::declval&lt;const Iter&amp;&gt;() == std::declval&lt;const Iter&amp;&gt;()) &amp;&amp;</div>
<div class="line">             <span class="keyword">noexcept</span>(std::declval&lt;const inner_iterator_type&amp;&gt;() == std::declval&lt;const inner_iterator_type&amp;&gt;())) {</div>
<div class="line">  <span class="keywordflow">if</span> (outer_current_ != other.outer_current_) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">if</span> (outer_current_ == outer_end_) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> inner_current_ == other.inner_current_;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</div>
<div class="line">  <span class="keyword">requires</span> JoinAdapterRequirements&lt;Iter&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> JoinAdapter&lt;Iter&gt;::end() <span class="keyword">const</span></div>
<div class="line">    <span class="keyword">noexcept</span>(std::is_nothrow_copy_constructible_v&lt;JoinAdapter&gt; &amp;&amp; std::is_nothrow_copy_assignable_v&lt;Iter&gt;)</div>
<div class="line">        -&gt; JoinAdapter {</div>
<div class="line">  <span class="keyword">auto</span> result = *<span class="keyword">this</span>;</div>
<div class="line">  result.outer_current_ = result.outer_end_;</div>
<div class="line">  <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</div>
<div class="line">  <span class="keyword">requires</span> JoinAdapterRequirements&lt;Iter&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keywordtype">void</span> JoinAdapter&lt;Iter&gt;::AdvanceToValid() <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(std::declval&lt;Iter&amp;&gt;() == std::declval&lt;Iter&amp;&gt;()) &amp;&amp;</div>
<div class="line">                                                            <span class="keyword">noexcept</span>(std::declval&lt;inner_iterator_type&amp;&gt;() ==</div>
<div class="line">                                                                     std::declval&lt;inner_iterator_type&amp;&gt;()) &amp;&amp;</div>
<div class="line">                                                            <span class="keyword">noexcept</span>(++std::declval&lt;Iter&amp;&gt;()) &amp;&amp;</div>
<div class="line">                                                            <span class="keyword">noexcept</span>(*std::declval&lt;Iter&amp;&gt;()) &amp;&amp;</div>
<div class="line">                                                            std::is_nothrow_move_assignable_v&lt;inner_iterator_type&gt;) {</div>
<div class="line">  <span class="keywordflow">while</span> (outer_current_ != outer_end_) {</div>
<div class="line">    <span class="keywordflow">if</span> (inner_current_ == inner_end_) {</div>
<div class="line">      ++outer_current_;</div>
<div class="line">      <span class="keywordflow">if</span> (outer_current_ == outer_end_) {</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">      }</div>
<div class="line">      <span class="keyword">auto</span>&amp; inner_range = *outer_current_;</div>
<div class="line">      inner_current_ = std::ranges::begin(inner_range);</div>
<div class="line">      inner_end_ = std::ranges::end(inner_range);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (inner_current_ != inner_end_) {</div>
<div class="line">      <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * @brief Adapter that yields sliding windows of elements.</span></div>
<div class="line"><span class="comment"> * @details Creates overlapping windows of a fixed size, moving one element at a time.</span></div>
<div class="line"><span class="comment"> * @tparam Iter Type of the underlying iterator</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</div>
<div class="line">  <span class="keyword">requires</span> SlideAdapterRequirements&lt;Iter&gt;</div>
<div class="line"><span class="keyword">class </span>SlideAdapter final : <span class="keyword">public</span> FunctionalAdapterBase&lt;SlideAdapter&lt;Iter&gt;&gt; {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">using </span>iterator_category = std::forward_iterator_tag;</div>
<div class="line">  <span class="keyword">using </span>value_type = std::vector&lt;std::iter_value_t&lt;Iter&gt;&gt;;</div>
<div class="line">  <span class="keyword">using </span>difference_type = std::iter_difference_t&lt;Iter&gt;;</div>
<div class="line">  <span class="keyword">using </span>pointer = value_type*;</div>
<div class="line">  <span class="keyword">using </span>reference = value_type;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /**</span></div>
<div class="line"><span class="comment">   * @brief Constructs a slide adapter.</span></div>
<div class="line"><span class="comment">   * @param begin Iterator to the beginning of the range</span></div>
<div class="line"><span class="comment">   * @param end Iterator to the end of the range</span></div>
<div class="line"><span class="comment">   * @param window_size Size of the sliding window</span></div>
<div class="line"><span class="comment">   * @warning window_size must be greater than 0</span></div>
<div class="line"><span class="comment">   */</span></div>
<div class="line">  <span class="keyword">constexpr</span> SlideAdapter(Iter begin, Iter end,</div>
<div class="line">                         <span class="keywordtype">size_t</span> window_size) <span class="keyword">noexcept</span>(std::is_nothrow_move_constructible_v&lt;Iter&gt; &amp;&amp;</div>
<div class="line">                                                      std::is_nothrow_copy_constructible_v&lt;Iter&gt; &amp;&amp;</div>
<div class="line">                                                      <span class="keyword">noexcept</span>(std::declval&lt;Iter&amp;&gt;() != std::declval&lt;Iter&amp;&gt;()) &amp;&amp;</div>
<div class="line">                                                      <span class="keyword">noexcept</span>(++std::declval&lt;Iter&amp;&gt;()));</div>
<div class="line">  <span class="keyword">constexpr</span> SlideAdapter(<span class="keyword">const</span> SlideAdapter&amp;) <span class="keyword">noexcept</span>(std::is_nothrow_copy_constructible_v&lt;Iter&gt;) = <span class="keywordflow">default</span>;</div>
<div class="line">  <span class="keyword">constexpr</span> SlideAdapter(SlideAdapter&amp;&amp;) <span class="keyword">noexcept</span>(std::is_nothrow_move_constructible_v&lt;Iter&gt;) = <span class="keywordflow">default</span>;</div>
<div class="line">  <span class="keyword">constexpr</span> ~SlideAdapter() <span class="keyword">noexcept</span>(std::is_nothrow_destructible_v&lt;Iter&gt;) = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">constexpr</span> SlideAdapter&amp; operator=(<span class="keyword">const</span> SlideAdapter&amp;) <span class="keyword">noexcept</span>(std::is_nothrow_copy_assignable_v&lt;Iter&gt;) = <span class="keywordflow">default</span>;</div>
<div class="line">  <span class="keyword">constexpr</span> SlideAdapter&amp; operator=(SlideAdapter&amp;&amp;) <span class="keyword">noexcept</span>(std::is_nothrow_move_assignable_v&lt;Iter&gt;) = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">constexpr</span> SlideAdapter&amp; operator++() <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(std::declval&lt;Iter&amp;&gt;() != std::declval&lt;Iter&amp;&gt;()) &amp;&amp;</div>
<div class="line">                                                <span class="keyword">noexcept</span>(++std::declval&lt;Iter&amp;&gt;()));</div>
<div class="line">  <span class="keyword">constexpr</span> SlideAdapter operator++(<span class="keywordtype">int</span>) <span class="keyword">noexcept</span>(std::is_nothrow_copy_constructible_v&lt;SlideAdapter&gt; &amp;&amp;</div>
<div class="line">                                                  <span class="keyword">noexcept</span>(++std::declval&lt;SlideAdapter&amp;&gt;()));</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">constexpr</span> value_type operator*() <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">constexpr</span> <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> SlideAdapter&amp; other) <span class="keyword">const</span></div>
<div class="line">      <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(std::declval&lt;const Iter&amp;&gt;() == std::declval&lt;const Iter&amp;&gt;())) {</div>
<div class="line">    <span class="keywordflow">return</span> current_ == other.current_;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">constexpr</span> <span class="keywordtype">bool</span> operator!=(<span class="keyword">const</span> SlideAdapter&amp; other) <span class="keyword">const</span></div>
<div class="line">      <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(std::declval&lt;const Iter&amp;&gt;() != std::declval&lt;const Iter&amp;&gt;())) {</div>
<div class="line">    <span class="keywordflow">return</span> current_ != other.current_;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">constexpr</span> SlideAdapter begin() <span class="keyword">const</span></div>
<div class="line">      <span class="keyword">noexcept</span>(std::is_nothrow_constructible_v&lt;SlideAdapter, const Iter&amp;, const Iter&amp;, size_t&gt;) {</div>
<div class="line">    <span class="keywordflow">return</span> {begin_, end_, window_size_};</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">constexpr</span> SlideAdapter end() <span class="keyword">const</span></div>
<div class="line">      <span class="keyword">noexcept</span>(std::is_nothrow_copy_constructible_v&lt;SlideAdapter&gt; &amp;&amp; std::is_nothrow_copy_assignable_v&lt;Iter&gt; &amp;&amp;</div>
<div class="line">               <span class="keyword">noexcept</span>(std::declval&lt;Iter&amp;&gt;() != std::declval&lt;const Iter&amp;&gt;()) &amp;&amp; <span class="keyword">noexcept</span>(++std::declval&lt;Iter&amp;&gt;()));</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  Iter begin_;</div>
<div class="line">  Iter current_;</div>
<div class="line">  Iter end_;</div>
<div class="line">  <span class="keywordtype">size_t</span> window_size_ = 0;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</div>
<div class="line">  <span class="keyword">requires</span> SlideAdapterRequirements&lt;Iter&gt;</div>
<div class="line"><span class="keyword">constexpr</span> SlideAdapter&lt;Iter&gt;::SlideAdapter(Iter begin, Iter end, <span class="keywordtype">size_t</span> window_size) <span class="keyword">noexcept</span>(</div>
<div class="line">    std::is_nothrow_move_constructible_v&lt;Iter&gt; &amp;&amp; std::is_nothrow_copy_constructible_v&lt;Iter&gt; &amp;&amp;</div>
<div class="line">    <span class="keyword">noexcept</span>(std::declval&lt;Iter&amp;&gt;() != std::declval&lt;Iter&amp;&gt;()) &amp;&amp; <span class="keyword">noexcept</span>(++std::declval&lt;Iter&amp;&gt;()))</div>
<div class="line">    : begin_(std::move(begin)), current_(begin_), end_(std::move(end)), window_size_(window_size) {</div>
<div class="line">  <span class="comment">// If we can&#39;t form a complete window, start at end</span></div>
<div class="line">  Iter iter = begin_;</div>
<div class="line">  <span class="keywordtype">size_t</span> count = 0;</div>
<div class="line">  <span class="keywordflow">while</span> (iter != end_) {</div>
<div class="line">    ++iter;</div>
<div class="line">    ++count;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">if</span> (count &lt; window_size_) {</div>
<div class="line">    current_ = end_;</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</div>
<div class="line">  <span class="keyword">requires</span> SlideAdapterRequirements&lt;Iter&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> SlideAdapter&lt;Iter&gt;::operator++() <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(std::declval&lt;Iter&amp;&gt;() != std::declval&lt;Iter&amp;&gt;()) &amp;&amp;</div>
<div class="line">                                                         <span class="keyword">noexcept</span>(++std::declval&lt;Iter&amp;&gt;())) -&gt; SlideAdapter&amp; {</div>
<div class="line">  <span class="keywordflow">if</span> (current_ != end_) {</div>
<div class="line">    ++current_;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</div>
<div class="line">  <span class="keyword">requires</span> SlideAdapterRequirements&lt;Iter&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> SlideAdapter&lt;Iter&gt;::operator++(<span class="keywordtype">int</span>) <span class="keyword">noexcept</span>(std::is_nothrow_copy_constructible_v&lt;SlideAdapter&gt; &amp;&amp;</div>
<div class="line">                                                            <span class="keyword">noexcept</span>(++std::declval&lt;SlideAdapter&amp;&gt;())) -&gt; SlideAdapter {</div>
<div class="line">  <span class="keyword">auto</span> temp = *<span class="keyword">this</span>;</div>
<div class="line">  ++(*this);</div>
<div class="line">  <span class="keywordflow">return</span> temp;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</div>
<div class="line">  <span class="keyword">requires</span> SlideAdapterRequirements&lt;Iter&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> SlideAdapter&lt;Iter&gt;::operator*() <span class="keyword">const</span> -&gt; value_type {</div>
<div class="line">  value_type window;</div>
<div class="line">  window.reserve(window_size_);</div>
<div class="line"> </div>
<div class="line">  Iter iter = current_;</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; window_size_ &amp;&amp; iter != end_; ++i, ++iter) {</div>
<div class="line">    window.push_back(*iter);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> window;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</div>
<div class="line">  <span class="keyword">requires</span> SlideAdapterRequirements&lt;Iter&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> SlideAdapter&lt;Iter&gt;::end() <span class="keyword">const</span></div>
<div class="line">    <span class="keyword">noexcept</span>(std::is_nothrow_copy_constructible_v&lt;SlideAdapter&gt; &amp;&amp; std::is_nothrow_copy_assignable_v&lt;Iter&gt; &amp;&amp;</div>
<div class="line">             <span class="keyword">noexcept</span>(std::declval&lt;Iter&amp;&gt;() != std::declval&lt;const Iter&amp;&gt;()) &amp;&amp; <span class="keyword">noexcept</span>(++std::declval&lt;Iter&amp;&gt;()))</div>
<div class="line">        -&gt; SlideAdapter {</div>
<div class="line">  <span class="keyword">auto</span> result = *<span class="keyword">this</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Calculate end position: when we can&#39;t form a complete window</span></div>
<div class="line">  Iter iter = begin_;</div>
<div class="line">  <span class="keywordtype">size_t</span> count = 0;</div>
<div class="line">  <span class="keywordflow">while</span> (iter != end_) {</div>
<div class="line">    ++iter;</div>
<div class="line">    ++count;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Position where we can&#39;t form more windows</span></div>
<div class="line">  <span class="keywordflow">if</span> (count &gt;= window_size_) {</div>
<div class="line">    result.current_ = begin_;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; count - window_size_ + 1; ++i) {</div>
<div class="line">      ++result.current_;</div>
<div class="line">    }</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    result.current_ = end_;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * @brief Adapter that yields every Nth element from the range.</span></div>
<div class="line"><span class="comment"> * @details Similar to StepBy but with different semantics - takes stride, not step.</span></div>
<div class="line"><span class="comment"> * @tparam Iter Type of the underlying iterator</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</div>
<div class="line">  <span class="keyword">requires</span> StrideAdapterRequirements&lt;Iter&gt;</div>
<div class="line"><span class="keyword">class </span>StrideAdapter final : <span class="keyword">public</span> FunctionalAdapterBase&lt;StrideAdapter&lt;Iter&gt;&gt; {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">using </span>iterator_category = std::forward_iterator_tag;</div>
<div class="line">  <span class="keyword">using </span>value_type = std::iter_value_t&lt;Iter&gt;;</div>
<div class="line">  <span class="keyword">using </span>difference_type = std::iter_difference_t&lt;Iter&gt;;</div>
<div class="line">  <span class="keyword">using </span>pointer = value_type*;</div>
<div class="line">  <span class="keyword">using </span>reference = value_type;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /**</span></div>
<div class="line"><span class="comment">   * @brief Constructs a stride adapter.</span></div>
<div class="line"><span class="comment">   * @param begin Iterator to the beginning of the range</span></div>
<div class="line"><span class="comment">   * @param end Iterator to the end of the range</span></div>
<div class="line"><span class="comment">   * @param stride Number of elements to skip between yields (1 = every element, 2 = every other, etc.)</span></div>
<div class="line"><span class="comment">   * @warning stride must be greater than 0</span></div>
<div class="line"><span class="comment">   */</span></div>
<div class="line">  <span class="keyword">constexpr</span> StrideAdapter(Iter begin, Iter end, <span class="keywordtype">size_t</span> stride) <span class="keyword">noexcept</span>(std::is_nothrow_move_constructible_v&lt;Iter&gt; &amp;&amp;</div>
<div class="line">                                                                        std::is_nothrow_copy_constructible_v&lt;Iter&gt;)</div>
<div class="line">      : begin_(std::move(begin)), current_(begin_), end_(std::move(end)), stride_(stride) {}</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">constexpr</span> StrideAdapter(<span class="keyword">const</span> StrideAdapter&amp;) <span class="keyword">noexcept</span>(std::is_nothrow_copy_constructible_v&lt;Iter&gt;) = <span class="keywordflow">default</span>;</div>
<div class="line">  <span class="keyword">constexpr</span> StrideAdapter(StrideAdapter&amp;&amp;) <span class="keyword">noexcept</span>(std::is_nothrow_move_constructible_v&lt;Iter&gt;) = <span class="keywordflow">default</span>;</div>
<div class="line">  <span class="keyword">constexpr</span> ~StrideAdapter() <span class="keyword">noexcept</span>(std::is_nothrow_destructible_v&lt;Iter&gt;) = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">constexpr</span> StrideAdapter&amp; operator=(<span class="keyword">const</span> StrideAdapter&amp;) <span class="keyword">noexcept</span>(std::is_nothrow_copy_assignable_v&lt;Iter&gt;) = <span class="keywordflow">default</span>;</div>
<div class="line">  <span class="keyword">constexpr</span> StrideAdapter&amp; operator=(StrideAdapter&amp;&amp;) <span class="keyword">noexcept</span>(std::is_nothrow_move_assignable_v&lt;Iter&gt;) = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">constexpr</span> StrideAdapter&amp; operator++() <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(std::declval&lt;Iter&amp;&gt;() != std::declval&lt;Iter&amp;&gt;()) &amp;&amp;</div>
<div class="line">                                                 <span class="keyword">noexcept</span>(++std::declval&lt;Iter&amp;&gt;()));</div>
<div class="line">  <span class="keyword">constexpr</span> StrideAdapter operator++(<span class="keywordtype">int</span>) <span class="keyword">noexcept</span>(std::is_nothrow_copy_constructible_v&lt;StrideAdapter&gt; &amp;&amp;</div>
<div class="line">                                                   <span class="keyword">noexcept</span>(++std::declval&lt;StrideAdapter&amp;&gt;()));</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">constexpr</span> value_type operator*() <span class="keyword">const</span> <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(*std::declval&lt;const Iter&amp;&gt;())) { <span class="keywordflow">return</span> *current_; }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">constexpr</span> <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> StrideAdapter&amp; other) <span class="keyword">const</span></div>
<div class="line">      <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(std::declval&lt;const Iter&amp;&gt;() == std::declval&lt;const Iter&amp;&gt;())) {</div>
<div class="line">    <span class="keywordflow">return</span> current_ == other.current_;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">constexpr</span> <span class="keywordtype">bool</span> operator!=(<span class="keyword">const</span> StrideAdapter&amp; other) <span class="keyword">const</span></div>
<div class="line">      <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(std::declval&lt;const Iter&amp;&gt;() != std::declval&lt;const Iter&amp;&gt;())) {</div>
<div class="line">    <span class="keywordflow">return</span> current_ != other.current_;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">constexpr</span> StrideAdapter begin() <span class="keyword">const</span></div>
<div class="line">      <span class="keyword">noexcept</span>(std::is_nothrow_constructible_v&lt;StrideAdapter, const Iter&amp;, const Iter&amp;, size_t&gt;) {</div>
<div class="line">    <span class="keywordflow">return</span> {begin_, end_, stride_};</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">constexpr</span> StrideAdapter end() <span class="keyword">const</span></div>
<div class="line">      <span class="keyword">noexcept</span>(std::is_nothrow_copy_constructible_v&lt;StrideAdapter&gt; &amp;&amp; std::is_nothrow_copy_assignable_v&lt;Iter&gt;);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  Iter begin_;</div>
<div class="line">  Iter current_;</div>
<div class="line">  Iter end_;</div>
<div class="line">  <span class="keywordtype">size_t</span> stride_;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</div>
<div class="line">  <span class="keyword">requires</span> StrideAdapterRequirements&lt;Iter&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> StrideAdapter&lt;Iter&gt;::operator++() <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(std::declval&lt;Iter&amp;&gt;() != std::declval&lt;Iter&amp;&gt;()) &amp;&amp;</div>
<div class="line">                                                          <span class="keyword">noexcept</span>(++std::declval&lt;Iter&amp;&gt;())) -&gt; StrideAdapter&amp; {</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; stride_ &amp;&amp; current_ != end_; ++i) {</div>
<div class="line">    ++current_;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</div>
<div class="line">  <span class="keyword">requires</span> StrideAdapterRequirements&lt;Iter&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> StrideAdapter&lt;Iter&gt;::operator++(<span class="keywordtype">int</span>) <span class="keyword">noexcept</span>(std::is_nothrow_copy_constructible_v&lt;StrideAdapter&gt; &amp;&amp;</div>
<div class="line">                                                             <span class="keyword">noexcept</span>(++std::declval&lt;StrideAdapter&amp;&gt;()))</div>
<div class="line">    -&gt; StrideAdapter {</div>
<div class="line">  <span class="keyword">auto</span> temp = *<span class="keyword">this</span>;</div>
<div class="line">  ++(*this);</div>
<div class="line">  <span class="keywordflow">return</span> temp;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</div>
<div class="line">  <span class="keyword">requires</span> StrideAdapterRequirements&lt;Iter&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> StrideAdapter&lt;Iter&gt;::end() <span class="keyword">const</span></div>
<div class="line">    <span class="keyword">noexcept</span>(std::is_nothrow_copy_constructible_v&lt;StrideAdapter&gt; &amp;&amp; std::is_nothrow_copy_assignable_v&lt;Iter&gt;)</div>
<div class="line">        -&gt; StrideAdapter {</div>
<div class="line">  <span class="keyword">auto</span> result = *<span class="keyword">this</span>;</div>
<div class="line">  result.current_ = end_;</div>
<div class="line">  <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * @brief Adapter that combines two ranges into pairs.</span></div>
<div class="line"><span class="comment"> * @details Iterates both ranges in parallel, yielding tuples of corresponding elements.</span></div>
<div class="line"><span class="comment"> * Stops when either range is exhausted.</span></div>
<div class="line"><span class="comment"> * @tparam Iter1 Type of the first iterator</span></div>
<div class="line"><span class="comment"> * @tparam Iter2 Type of the second iterator</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter1, <span class="keyword">typename</span> Iter2&gt;</div>
<div class="line">  <span class="keyword">requires</span> ZipAdapterRequirements&lt;Iter1, Iter2&gt;</div>
<div class="line"><span class="keyword">class </span>ZipAdapter final : <span class="keyword">public</span> FunctionalAdapterBase&lt;ZipAdapter&lt;Iter1, Iter2&gt;&gt; {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">using </span>iterator_category = std::forward_iterator_tag;</div>
<div class="line">  <span class="keyword">using </span>value_type = std::tuple&lt;std::iter_value_t&lt;Iter1&gt;, std::iter_value_t&lt;Iter2&gt;&gt;;</div>
<div class="line">  <span class="keyword">using </span>difference_type = std::ptrdiff_t;</div>
<div class="line">  <span class="keyword">using </span>pointer = value_type*;</div>
<div class="line">  <span class="keyword">using </span>reference = value_type;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /**</span></div>
<div class="line"><span class="comment">   * @brief Constructs a zip adapter.</span></div>
<div class="line"><span class="comment">   * @param begin1 Iterator to the beginning of the first range</span></div>
<div class="line"><span class="comment">   * @param end1 Iterator to the end of the first range</span></div>
<div class="line"><span class="comment">   * @param begin2 Iterator to the beginning of the second range</span></div>
<div class="line"><span class="comment">   * @param end2 Iterator to the end of the second range</span></div>
<div class="line"><span class="comment">   */</span></div>
<div class="line">  <span class="keyword">constexpr</span> ZipAdapter(Iter1 begin1, Iter1 end1, Iter2 begin2,</div>
<div class="line">                       Iter2 end2) <span class="keyword">noexcept</span>(std::is_nothrow_move_constructible_v&lt;Iter1&gt; &amp;&amp;</div>
<div class="line">                                            std::is_nothrow_copy_constructible_v&lt;Iter1&gt; &amp;&amp;</div>
<div class="line">                                            std::is_nothrow_move_constructible_v&lt;Iter2&gt; &amp;&amp;</div>
<div class="line">                                            std::is_nothrow_copy_constructible_v&lt;Iter2&gt;)</div>
<div class="line">      : first_begin_(std::move(begin1)),</div>
<div class="line">        first_current_(first_begin_),</div>
<div class="line">        first_end_(std::move(end1)),</div>
<div class="line">        second_begin_(std::move(begin2)),</div>
<div class="line">        second_current_(second_begin_),</div>
<div class="line">        second_end_(std::move(end2)) {}</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">constexpr</span> ZipAdapter(<span class="keyword">const</span> ZipAdapter&amp;) <span class="keyword">noexcept</span>(std::is_nothrow_copy_constructible_v&lt;Iter1&gt; &amp;&amp;</div>
<div class="line">                                                   std::is_nothrow_copy_constructible_v&lt;Iter2&gt;) = <span class="keywordflow">default</span>;</div>
<div class="line">  <span class="keyword">constexpr</span> ZipAdapter(ZipAdapter&amp;&amp;) <span class="keyword">noexcept</span>(std::is_nothrow_move_constructible_v&lt;Iter1&gt; &amp;&amp;</div>
<div class="line">                                              std::is_nothrow_move_constructible_v&lt;Iter2&gt;) = <span class="keywordflow">default</span>;</div>
<div class="line">  <span class="keyword">constexpr</span> ~ZipAdapter() <span class="keyword">noexcept</span>(std::is_nothrow_destructible_v&lt;Iter1&gt; &amp;&amp;</div>
<div class="line">                                   std::is_nothrow_destructible_v&lt;Iter2&gt;) = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">constexpr</span> ZipAdapter&amp; operator=(<span class="keyword">const</span> ZipAdapter&amp;) <span class="keyword">noexcept</span>(std::is_nothrow_copy_assignable_v&lt;Iter1&gt; &amp;&amp;</div>
<div class="line">                                                              std::is_nothrow_copy_assignable_v&lt;Iter2&gt;) = <span class="keywordflow">default</span>;</div>
<div class="line">  <span class="keyword">constexpr</span> ZipAdapter&amp; operator=(ZipAdapter&amp;&amp;) <span class="keyword">noexcept</span>(std::is_nothrow_move_assignable_v&lt;Iter1&gt; &amp;&amp;</div>
<div class="line">                                                         std::is_nothrow_move_assignable_v&lt;Iter2&gt;) = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">constexpr</span> ZipAdapter&amp; operator++() <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(std::declval&lt;Iter1&amp;&gt;() != std::declval&lt;Iter1&amp;&gt;()) &amp;&amp;</div>
<div class="line">                                              <span class="keyword">noexcept</span>(++std::declval&lt;Iter1&amp;&gt;()) &amp;&amp;</div>
<div class="line">                                              <span class="keyword">noexcept</span>(std::declval&lt;Iter2&amp;&gt;() != std::declval&lt;Iter2&amp;&gt;()) &amp;&amp;</div>
<div class="line">                                              <span class="keyword">noexcept</span>(++std::declval&lt;Iter2&amp;&gt;()));</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">constexpr</span> ZipAdapter operator++(<span class="keywordtype">int</span>) <span class="keyword">noexcept</span>(std::is_nothrow_copy_constructible_v&lt;ZipAdapter&gt; &amp;&amp;</div>
<div class="line">                                                <span class="keyword">noexcept</span>(++std::declval&lt;ZipAdapter&amp;&gt;()));</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">constexpr</span> value_type operator*()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> std::make_tuple(*first_current_, *second_current_); }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">constexpr</span> <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> ZipAdapter&amp; other) <span class="keyword">const</span></div>
<div class="line">      <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(std::declval&lt;const Iter1&amp;&gt;() == std::declval&lt;const Iter1&amp;&gt;()) &amp;&amp;</div>
<div class="line">               <span class="keyword">noexcept</span>(std::declval&lt;const Iter2&amp;&gt;() == std::declval&lt;const Iter2&amp;&gt;())) {</div>
<div class="line">    <span class="keywordflow">return</span> first_current_ == other.first_current_ || second_current_ == other.second_current_;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">constexpr</span> <span class="keywordtype">bool</span> operator!=(<span class="keyword">const</span> ZipAdapter&amp; other) <span class="keyword">const</span></div>
<div class="line">      <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(std::declval&lt;const ZipAdapter&amp;&gt;() == std::declval&lt;const ZipAdapter&amp;&gt;())) {</div>
<div class="line">    <span class="keywordflow">return</span> !(*<span class="keyword">this</span> == other);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">constexpr</span> <span class="keywordtype">bool</span> IsAtEnd() <span class="keyword">const</span> <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(std::declval&lt;const Iter1&amp;&gt;() == std::declval&lt;const Iter1&amp;&gt;()) &amp;&amp;</div>
<div class="line">                                          <span class="keyword">noexcept</span>(std::declval&lt;const Iter2&amp;&gt;() == std::declval&lt;const Iter2&amp;&gt;())) {</div>
<div class="line">    <span class="keywordflow">return</span> first_current_ == first_end_ || second_current_ == second_end_;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">constexpr</span> ZipAdapter begin() <span class="keyword">const</span> <span class="keyword">noexcept</span>(std::is_nothrow_copy_constructible_v&lt;ZipAdapter&gt;) { <span class="keywordflow">return</span> *<span class="keyword">this</span>; }</div>
<div class="line">  <span class="keyword">constexpr</span> ZipAdapter end() <span class="keyword">const</span> <span class="keyword">noexcept</span>(std::is_nothrow_copy_constructible_v&lt;ZipAdapter&gt;);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  Iter1 first_begin_;</div>
<div class="line">  Iter1 first_current_;</div>
<div class="line">  Iter1 first_end_;</div>
<div class="line">  Iter2 second_begin_;</div>
<div class="line">  Iter2 second_current_;</div>
<div class="line">  Iter2 second_end_;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter1, <span class="keyword">typename</span> Iter2&gt;</div>
<div class="line">  <span class="keyword">requires</span> ZipAdapterRequirements&lt;Iter1, Iter2&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> ZipAdapter&lt;Iter1, Iter2&gt;::operator++() <span class="keyword">noexcept</span>(</div>
<div class="line">    <span class="keyword">noexcept</span>(std::declval&lt;Iter1&amp;&gt;() != std::declval&lt;Iter1&amp;&gt;()) &amp;&amp; <span class="keyword">noexcept</span>(++std::declval&lt;Iter1&amp;&gt;()) &amp;&amp;</div>
<div class="line">    <span class="keyword">noexcept</span>(std::declval&lt;Iter2&amp;&gt;() != std::declval&lt;Iter2&amp;&gt;()) &amp;&amp; <span class="keyword">noexcept</span>(++std::declval&lt;Iter2&amp;&gt;())) -&gt; ZipAdapter&amp; {</div>
<div class="line">  <span class="keywordflow">if</span> (first_current_ != first_end_) {</div>
<div class="line">    ++first_current_;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">if</span> (second_current_ != second_end_) {</div>
<div class="line">    ++second_current_;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter1, <span class="keyword">typename</span> Iter2&gt;</div>
<div class="line">  <span class="keyword">requires</span> ZipAdapterRequirements&lt;Iter1, Iter2&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> ZipAdapter&lt;Iter1, Iter2&gt;::operator++(<span class="keywordtype">int</span>) <span class="keyword">noexcept</span>(std::is_nothrow_copy_constructible_v&lt;ZipAdapter&gt; &amp;&amp;</div>
<div class="line">                                                                  <span class="keyword">noexcept</span>(++std::declval&lt;ZipAdapter&amp;&gt;()))</div>
<div class="line">    -&gt; ZipAdapter {</div>
<div class="line">  <span class="keyword">auto</span> temp = *<span class="keyword">this</span>;</div>
<div class="line">  ++(*this);</div>
<div class="line">  <span class="keywordflow">return</span> temp;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter1, <span class="keyword">typename</span> Iter2&gt;</div>
<div class="line">  <span class="keyword">requires</span> ZipAdapterRequirements&lt;Iter1, Iter2&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> ZipAdapter&lt;Iter1, Iter2&gt;::end() <span class="keyword">const</span> <span class="keyword">noexcept</span>(std::is_nothrow_copy_constructible_v&lt;ZipAdapter&gt;)</div>
<div class="line">    -&gt; ZipAdapter {</div>
<div class="line">  <span class="keyword">auto</span> result = *<span class="keyword">this</span>;</div>
<div class="line">  result.first_current_ = result.first_end_;</div>
<div class="line">  result.second_current_ = result.second_end_;</div>
<div class="line">  <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * @brief CRTP base class providing common adapter operations.</span></div>
<div class="line"><span class="comment"> * @details Provides chaining methods (Filter, Map, Take, Skip, etc.) that can be used by any derived adapter class.</span></div>
<div class="line"><span class="comment"> * Uses CRTP pattern to return the correct derived type.</span></div>
<div class="line"><span class="comment"> * @tparam Derived The derived adapter class</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Derived&gt;</div>
<div class="line"><span class="keyword">class </span>FunctionalAdapterBase {</div>
<div class="line"><span class="keyword">public</span>:<span class="comment"></span></div>
<div class="line"><span class="comment">  /**</span></div>
<div class="line"><span class="comment">   * @brief Chains another filter operation on top of this iterator.</span></div>
<div class="line"><span class="comment">   * @tparam Pred Predicate type</span></div>
<div class="line"><span class="comment">   * @param predicate Function to filter elements</span></div>
<div class="line"><span class="comment">   * @return FilterAdapter that applies this adapter then filters</span></div>
<div class="line"><span class="comment">   */</span></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Pred&gt;</div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> <span class="keyword">auto</span> Filter(Pred predicate) <span class="keyword">const</span></div>
<div class="line">      <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(FilterAdapter&lt;Derived, Pred&gt;(<a id="a157" name="a157"></a><a class="code hl_function" href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">GetDerived</a>().begin(), <a class="code hl_function" href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">GetDerived</a>().end(), std::move(predicate)))) {</div>
<div class="line">    <span class="keywordflow">return</span> FilterAdapter&lt;Derived, Pred&gt;(<a class="code hl_function" href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">GetDerived</a>().begin(), <a class="code hl_function" href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">GetDerived</a>().end(), std::move(predicate));</div>
<div class="line">  }</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /**</span></div>
<div class="line"><span class="comment">   * @brief Transforms each element using the given function.</span></div>
<div class="line"><span class="comment">   * @tparam Func Transformation function type</span></div>
<div class="line"><span class="comment">   * @param transform Function to apply to each element</span></div>
<div class="line"><span class="comment">   * @return MapAdapter that transforms adapted results</span></div>
<div class="line"><span class="comment">   */</span></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Func&gt;</div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> <span class="keyword">auto</span> Map(Func transform) <span class="keyword">const</span></div>
<div class="line">      <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(MapAdapter&lt;Derived, Func&gt;(<a class="code hl_function" href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">GetDerived</a>().begin(), <a class="code hl_function" href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">GetDerived</a>().end(), std::move(transform)))) {</div>
<div class="line">    <span class="keywordflow">return</span> MapAdapter&lt;Derived, Func&gt;(<a class="code hl_function" href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">GetDerived</a>().begin(), <a class="code hl_function" href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">GetDerived</a>().end(), std::move(transform));</div>
<div class="line">  }</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /**</span></div>
<div class="line"><span class="comment">   * @brief Limits the number of elements to at most count.</span></div>
<div class="line"><span class="comment">   * @param count Maximum number of elements to yield</span></div>
<div class="line"><span class="comment">   * @return TakeAdapter that limits adapted results</span></div>
<div class="line"><span class="comment">   */</span></div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> <span class="keyword">auto</span> Take(<span class="keywordtype">size_t</span> count) <span class="keyword">const</span></div>
<div class="line">      <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(TakeAdapter&lt;Derived&gt;(<a class="code hl_function" href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">GetDerived</a>().begin(), <a class="code hl_function" href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">GetDerived</a>().end(), count))) {</div>
<div class="line">    <span class="keywordflow">return</span> TakeAdapter&lt;Derived&gt;(<a class="code hl_function" href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">GetDerived</a>().begin(), <a class="code hl_function" href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">GetDerived</a>().end(), count);</div>
<div class="line">  }</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /**</span></div>
<div class="line"><span class="comment">   * @brief Skips the first count elements.</span></div>
<div class="line"><span class="comment">   * @param count Number of elements to skip</span></div>
<div class="line"><span class="comment">   * @return SkipAdapter that skips adapted results</span></div>
<div class="line"><span class="comment">   */</span></div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> <span class="keyword">auto</span> Skip(<span class="keywordtype">size_t</span> count) <span class="keyword">const</span></div>
<div class="line">      <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(SkipAdapter&lt;Derived&gt;(<a class="code hl_function" href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">GetDerived</a>().begin(), <a class="code hl_function" href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">GetDerived</a>().end(), count))) {</div>
<div class="line">    <span class="keywordflow">return</span> SkipAdapter&lt;Derived&gt;(<a class="code hl_function" href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">GetDerived</a>().begin(), <a class="code hl_function" href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">GetDerived</a>().end(), count);</div>
<div class="line">  }</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /**</span></div>
<div class="line"><span class="comment">   * @brief Takes elements while a predicate is true.</span></div>
<div class="line"><span class="comment">   * @tparam Pred Predicate type for take-while operation</span></div>
<div class="line"><span class="comment">   * @param predicate Predicate to determine when to stop taking</span></div>
<div class="line"><span class="comment">   * @return TakeWhileAdapter that conditionally takes elements</span></div>
<div class="line"><span class="comment">   */</span></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Pred&gt;</div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> <span class="keyword">auto</span> TakeWhile(Pred predicate) <span class="keyword">const</span></div>
<div class="line">      <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(TakeWhileAdapter&lt;Derived, Pred&gt;(<a class="code hl_function" href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">GetDerived</a>().begin(), <a class="code hl_function" href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">GetDerived</a>().end(),</div>
<div class="line">                                                        std::move(predicate)))) {</div>
<div class="line">    <span class="keywordflow">return</span> TakeWhileAdapter&lt;Derived, Pred&gt;(<a class="code hl_function" href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">GetDerived</a>().begin(), <a class="code hl_function" href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">GetDerived</a>().end(), std::move(predicate));</div>
<div class="line">  }</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /**</span></div>
<div class="line"><span class="comment">   * @brief Skips elements while a predicate is true.</span></div>
<div class="line"><span class="comment">   * @tparam Pred Predicate type for skip-while operation</span></div>
<div class="line"><span class="comment">   * @param predicate Predicate to determine when to stop skipping</span></div>
<div class="line"><span class="comment">   * @return SkipWhileAdapter that conditionally skips elements</span></div>
<div class="line"><span class="comment">   */</span></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Pred&gt;</div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> <span class="keyword">auto</span> SkipWhile(Pred predicate) <span class="keyword">const</span></div>
<div class="line">      <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(SkipWhileAdapter&lt;Derived, Pred&gt;(<a class="code hl_function" href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">GetDerived</a>().begin(), <a class="code hl_function" href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">GetDerived</a>().end(),</div>
<div class="line">                                                        std::move(predicate)))) {</div>
<div class="line">    <span class="keywordflow">return</span> SkipWhileAdapter&lt;Derived, Pred&gt;(<a class="code hl_function" href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">GetDerived</a>().begin(), <a class="code hl_function" href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">GetDerived</a>().end(), std::move(predicate));</div>
<div class="line">  }</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /**</span></div>
<div class="line"><span class="comment">   * @brief Adds an index to each element.</span></div>
<div class="line"><span class="comment">   * @return EnumerateAdapter that pairs indices with values</span></div>
<div class="line"><span class="comment">   */</span></div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> <span class="keyword">auto</span> Enumerate() <span class="keyword">const</span></div>
<div class="line">      <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(EnumerateAdapter&lt;Derived&gt;(<a class="code hl_function" href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">GetDerived</a>().begin(), <a class="code hl_function" href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">GetDerived</a>().end()))) {</div>
<div class="line">    <span class="keywordflow">return</span> EnumerateAdapter&lt;Derived&gt;(<a class="code hl_function" href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">GetDerived</a>().begin(), <a class="code hl_function" href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">GetDerived</a>().end());</div>
<div class="line">  }</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /**</span></div>
<div class="line"><span class="comment">   * @brief Observes each element without modifying it.</span></div>
<div class="line"><span class="comment">   * @tparam Func Inspector function type</span></div>
<div class="line"><span class="comment">   * @param inspector Function to call on each element</span></div>
<div class="line"><span class="comment">   * @return InspectAdapter for side effects</span></div>
<div class="line"><span class="comment">   */</span></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Func&gt;</div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> <span class="keyword">auto</span> Inspect(Func inspector) <span class="keyword">const</span></div>
<div class="line">      <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(InspectAdapter&lt;Derived, Func&gt;(<a class="code hl_function" href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">GetDerived</a>().begin(), <a class="code hl_function" href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">GetDerived</a>().end(),</div>
<div class="line">                                                      std::move(inspector)))) {</div>
<div class="line">    <span class="keywordflow">return</span> InspectAdapter&lt;Derived, Func&gt;(<a class="code hl_function" href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">GetDerived</a>().begin(), <a class="code hl_function" href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">GetDerived</a>().end(), std::move(inspector));</div>
<div class="line">  }</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /**</span></div>
<div class="line"><span class="comment">   * @brief Takes every Nth element.</span></div>
<div class="line"><span class="comment">   * @param step Step size between elements</span></div>
<div class="line"><span class="comment">   * @return StepByAdapter that skips elements</span></div>
<div class="line"><span class="comment">   */</span></div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> <span class="keyword">auto</span> StepBy(<span class="keywordtype">size_t</span> step) <span class="keyword">const</span></div>
<div class="line">      <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(StepByAdapter&lt;Derived&gt;(<a class="code hl_function" href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">GetDerived</a>().begin(), <a class="code hl_function" href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">GetDerived</a>().end(), step))) {</div>
<div class="line">    <span class="keywordflow">return</span> StepByAdapter&lt;Derived&gt;(<a class="code hl_function" href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">GetDerived</a>().begin(), <a class="code hl_function" href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">GetDerived</a>().end(), step);</div>
<div class="line">  }</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /**</span></div>
<div class="line"><span class="comment">   * @brief Chains another range after this one.</span></div>
<div class="line"><span class="comment">   * @tparam OtherIter Iterator type of the other adapter</span></div>
<div class="line"><span class="comment">   * @param begin Begin iterator of the other adapter</span></div>
<div class="line"><span class="comment">   * @param end End iterator of the other adapter</span></div>
<div class="line"><span class="comment">   * @return ChainAdapter that yields elements from both ranges</span></div>
<div class="line"><span class="comment">   */</span></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> OtherIter&gt;</div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> <span class="keyword">auto</span> Chain(OtherIter begin, OtherIter end) <span class="keyword">const</span></div>
<div class="line">      <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(ChainAdapter&lt;Derived, OtherIter&gt;(<a class="code hl_function" href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">GetDerived</a>().begin(), <a class="code hl_function" href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">GetDerived</a>().end(), std::move(begin),</div>
<div class="line">                                                         std::move(end)))) {</div>
<div class="line">    <span class="keywordflow">return</span> ChainAdapter&lt;Derived, OtherIter&gt;(<a class="code hl_function" href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">GetDerived</a>().begin(), <a class="code hl_function" href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">GetDerived</a>().end(), std::move(begin), std::move(end));</div>
<div class="line">  }</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /**</span></div>
<div class="line"><span class="comment">   * @brief Chains another range after this one.</span></div>
<div class="line"><span class="comment">   * @tparam R Range type of the other adapter</span></div>
<div class="line"><span class="comment">   * @param range The other range to chain</span></div>
<div class="line"><span class="comment">   * @return ChainAdapter that yields elements from both ranges</span></div>
<div class="line"><span class="comment">   */</span></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> R&gt;</div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> <span class="keyword">auto</span> Chain(R&amp; range) <span class="keyword">const</span> <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(<a id="a158" name="a158"></a><a class="code hl_function" href="functional__adapters_8hpp.html#aadcef6f6e0d096f987d0f75a5aac3abf">ChainAdapterFromRange</a>(<a class="code hl_function" href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">GetDerived</a>(), range))) {</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code hl_function" href="functional__adapters_8hpp.html#aadcef6f6e0d096f987d0f75a5aac3abf">ChainAdapterFromRange</a>(<a class="code hl_function" href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">GetDerived</a>(), range);</div>
<div class="line">  }</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /**</span></div>
<div class="line"><span class="comment">   * @brief Chains another range after this one.</span></div>
<div class="line"><span class="comment">   * @tparam R Range type of the other adapter</span></div>
<div class="line"><span class="comment">   * @param range The other range to chain</span></div>
<div class="line"><span class="comment">   * @return ChainAdapter that yields elements from both ranges</span></div>
<div class="line"><span class="comment">   */</span></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> R&gt;</div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> <span class="keyword">auto</span> Chain(<span class="keyword">const</span> R&amp; range) <span class="keyword">const</span></div>
<div class="line">      <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(<a class="code hl_function" href="functional__adapters_8hpp.html#aadcef6f6e0d096f987d0f75a5aac3abf">ChainAdapterFromRange</a>(<a class="code hl_function" href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">GetDerived</a>(), range))) {</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code hl_function" href="functional__adapters_8hpp.html#aadcef6f6e0d096f987d0f75a5aac3abf">ChainAdapterFromRange</a>(<a class="code hl_function" href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">GetDerived</a>(), range);</div>
<div class="line">  }</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /**</span></div>
<div class="line"><span class="comment">   * @brief Reverses the order of elements.</span></div>
<div class="line"><span class="comment">   * @note Requires bidirectional iterator support</span></div>
<div class="line"><span class="comment">   * @return ReverseAdapter that yields elements in reverse order</span></div>
<div class="line"><span class="comment">   */</span></div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> <span class="keyword">auto</span> Reverse() <span class="keyword">const</span></div>
<div class="line">      <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(ReverseAdapter&lt;Derived&gt;(<a class="code hl_function" href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">GetDerived</a>().begin(), <a class="code hl_function" href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">GetDerived</a>().end()))) {</div>
<div class="line">    <span class="keywordflow">return</span> ReverseAdapter&lt;Derived&gt;(<a class="code hl_function" href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">GetDerived</a>().begin(), <a class="code hl_function" href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">GetDerived</a>().end());</div>
<div class="line">  }</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /**</span></div>
<div class="line"><span class="comment">   * @brief Creates sliding windows over elements.</span></div>
<div class="line"><span class="comment">   * @param window_size Size of the sliding window</span></div>
<div class="line"><span class="comment">   * @return SlideAdapter that yields windows of elements</span></div>
<div class="line"><span class="comment">   * @warning window_size must be greater than 0</span></div>
<div class="line"><span class="comment">   */</span></div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> <span class="keyword">auto</span> Slide(<span class="keywordtype">size_t</span> window_size) <span class="keyword">const</span></div>
<div class="line">      <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(SlideAdapter&lt;Derived&gt;(<a class="code hl_function" href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">GetDerived</a>().begin(), <a class="code hl_function" href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">GetDerived</a>().end(), window_size))) {</div>
<div class="line">    <span class="keywordflow">return</span> SlideAdapter&lt;Derived&gt;(<a class="code hl_function" href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">GetDerived</a>().begin(), <a class="code hl_function" href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">GetDerived</a>().end(), window_size);</div>
<div class="line">  }</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /**</span></div>
<div class="line"><span class="comment">   * @brief Takes every Nth element with stride.</span></div>
<div class="line"><span class="comment">   * @param stride Number of elements to skip between yields</span></div>
<div class="line"><span class="comment">   * @return StrideAdapter that yields every Nth element</span></div>
<div class="line"><span class="comment">   * @warning stride must be greater than 0</span></div>
<div class="line"><span class="comment">   */</span></div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> <span class="keyword">auto</span> Stride(<span class="keywordtype">size_t</span> stride) <span class="keyword">const</span></div>
<div class="line">      <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(StrideAdapter&lt;Derived&gt;(<a class="code hl_function" href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">GetDerived</a>().begin(), <a class="code hl_function" href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">GetDerived</a>().end(), stride))) {</div>
<div class="line">    <span class="keywordflow">return</span> StrideAdapter&lt;Derived&gt;(<a class="code hl_function" href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">GetDerived</a>().begin(), <a class="code hl_function" href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">GetDerived</a>().end(), stride);</div>
<div class="line">  }</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /**</span></div>
<div class="line"><span class="comment">   * @brief Zips another range with this one.</span></div>
<div class="line"><span class="comment">   * @tparam OtherIter Iterator type to zip with</span></div>
<div class="line"><span class="comment">   * @param begin Begin iterator for the other range</span></div>
<div class="line"><span class="comment">   * @param end End iterator for the other range</span></div>
<div class="line"><span class="comment">   * @return ZipAdapter that yields tuples of corresponding elements</span></div>
<div class="line"><span class="comment">   */</span></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> OtherIter&gt;</div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> <span class="keyword">auto</span> Zip(OtherIter begin, OtherIter end) <span class="keyword">const</span></div>
<div class="line">      <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(ZipAdapter&lt;Derived, OtherIter&gt;(<a class="code hl_function" href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">GetDerived</a>().begin(), <a class="code hl_function" href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">GetDerived</a>().end(), std::move(begin),</div>
<div class="line">                                                       std::move(end)))) {</div>
<div class="line">    <span class="keywordflow">return</span> ZipAdapter&lt;Derived, OtherIter&gt;(<a class="code hl_function" href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">GetDerived</a>().begin(), <a class="code hl_function" href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">GetDerived</a>().end(), std::move(begin), std::move((end)));</div>
<div class="line">  }</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /**</span></div>
<div class="line"><span class="comment">   * @brief Zips another range with this one.</span></div>
<div class="line"><span class="comment">   * @tparam R Other range</span></div>
<div class="line"><span class="comment">   * @param range The other range to zip with</span></div>
<div class="line"><span class="comment">   * @return ZipAdapter that</span></div>
<div class="line"><span class="comment">   */</span></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> R&gt;</div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> <span class="keyword">auto</span> Zip(R&amp; range) <span class="keyword">const</span> <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(<a id="a159" name="a159"></a><a class="code hl_function" href="functional__adapters_8hpp.html#a22e05a1859c49e16d93d42691c556664">ZipAdapterFromRange</a>(<a class="code hl_function" href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">GetDerived</a>(), range))) {</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code hl_function" href="functional__adapters_8hpp.html#a22e05a1859c49e16d93d42691c556664">ZipAdapterFromRange</a>(<a class="code hl_function" href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">GetDerived</a>(), range);</div>
<div class="line">  }</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /**</span></div>
<div class="line"><span class="comment">   * @brief Zips another range with this one.</span></div>
<div class="line"><span class="comment">   * @tparam R Other range</span></div>
<div class="line"><span class="comment">   * @param range The other range to zip with</span></div>
<div class="line"><span class="comment">   * @return ZipAdapter that</span></div>
<div class="line"><span class="comment">   */</span></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> R&gt;</div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> <span class="keyword">auto</span> Zip(<span class="keyword">const</span> R&amp; range) <span class="keyword">const</span> <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(<a class="code hl_function" href="functional__adapters_8hpp.html#a22e05a1859c49e16d93d42691c556664">ZipAdapterFromRange</a>(<a class="code hl_function" href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">GetDerived</a>(), range))) {</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code hl_function" href="functional__adapters_8hpp.html#a22e05a1859c49e16d93d42691c556664">ZipAdapterFromRange</a>(<a class="code hl_function" href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">GetDerived</a>(), range);</div>
<div class="line">  }</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /**</span></div>
<div class="line"><span class="comment">   * @brief Terminal operation: applies an action to each element.</span></div>
<div class="line"><span class="comment">   * @tparam Action Function type that processes each element</span></div>
<div class="line"><span class="comment">   * @param action Function to apply to each element</span></div>
<div class="line"><span class="comment">   */</span></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Action&gt;</div>
<div class="line">  <span class="keyword">constexpr</span> <span class="keywordtype">void</span> ForEach(<span class="keyword">const</span> Action&amp; action) <span class="keyword">const</span>;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /**</span></div>
<div class="line"><span class="comment">   * @brief Terminal operation: reduces elements to a single value using a folder function.</span></div>
<div class="line"><span class="comment">   * @tparam T Accumulator type</span></div>
<div class="line"><span class="comment">   * @tparam Folder Function type that combines accumulator with each element</span></div>
<div class="line"><span class="comment">   * @param init Initial accumulator value</span></div>
<div class="line"><span class="comment">   * @param folder Function to fold elements</span></div>
<div class="line"><span class="comment">   * @return Final accumulated value</span></div>
<div class="line"><span class="comment">   */</span></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Folder&gt;</div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> T Fold(T init, <span class="keyword">const</span> Folder&amp; folder) <span class="keyword">const</span>;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /**</span></div>
<div class="line"><span class="comment">   * @brief Terminal operation: checks if any element satisfies a predicate.</span></div>
<div class="line"><span class="comment">   * @tparam Pred Predicate type</span></div>
<div class="line"><span class="comment">   * @param predicate Function to test elements</span></div>
<div class="line"><span class="comment">   * @return True if any element satisfies the predicate, false otherwise</span></div>
<div class="line"><span class="comment">   */</span></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Pred&gt;</div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> <span class="keywordtype">bool</span> Any(<span class="keyword">const</span> Pred&amp; predicate) <span class="keyword">const</span>;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /**</span></div>
<div class="line"><span class="comment">   * @brief Terminal operation: checks if all elements satisfy a predicate.</span></div>
<div class="line"><span class="comment">   * @tparam Pred Predicate type</span></div>
<div class="line"><span class="comment">   * @param predicate Function to test elements</span></div>
<div class="line"><span class="comment">   * @return True if all elements satisfy the predicate, false otherwise</span></div>
<div class="line"><span class="comment">   */</span></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Pred&gt;</div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> <span class="keywordtype">bool</span> All(<span class="keyword">const</span> Pred&amp; predicate) <span class="keyword">const</span>;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /**</span></div>
<div class="line"><span class="comment">   * @brief Terminal operation: checks if no elements satisfy a predicate.</span></div>
<div class="line"><span class="comment">   * @tparam Pred Predicate type</span></div>
<div class="line"><span class="comment">   * @param predicate Function to test elements</span></div>
<div class="line"><span class="comment">   * @return True if no elements satisfy the predicate, false otherwise</span></div>
<div class="line"><span class="comment">   */</span></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Pred&gt;</div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> <span class="keywordtype">bool</span> None(<span class="keyword">const</span> Pred&amp; predicate)<span class="keyword"> const </span>{</div>
<div class="line">    <span class="keywordflow">return</span> !Any(predicate);</div>
<div class="line">  }</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /**</span></div>
<div class="line"><span class="comment">   * @brief Terminal operation: finds the first element satisfying a predicate.</span></div>
<div class="line"><span class="comment">   * @tparam Pred Predicate type</span></div>
<div class="line"><span class="comment">   * @param predicate Function to test elements</span></div>
<div class="line"><span class="comment">   * @return Optional containing the first matching element, or empty if none found</span></div>
<div class="line"><span class="comment">   */</span></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Pred&gt;</div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> <span class="keyword">auto</span> Find(<span class="keyword">const</span> Pred&amp; predicate) <span class="keyword">const</span>;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /**</span></div>
<div class="line"><span class="comment">   * @brief Terminal operation: counts elements satisfying a predicate.</span></div>
<div class="line"><span class="comment">   * @tparam Pred Predicate type</span></div>
<div class="line"><span class="comment">   * @param predicate Function to test elements</span></div>
<div class="line"><span class="comment">   * @return Number of elements that satisfy the predicate</span></div>
<div class="line"><span class="comment">   */</span></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Pred&gt;</div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> <span class="keywordtype">size_t</span> CountIf(<span class="keyword">const</span> Pred&amp; predicate) <span class="keyword">const</span>;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /**</span></div>
<div class="line"><span class="comment">   * @brief Terminal operation: partitions elements into two groups based on a predicate.</span></div>
<div class="line"><span class="comment">   * @tparam Pred Predicate type</span></div>
<div class="line"><span class="comment">   * @param predicate Function to test elements</span></div>
<div class="line"><span class="comment">   * @return Pair of vectors: first contains elements satisfying predicate, second contains the rest</span></div>
<div class="line"><span class="comment">   */</span></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Pred&gt;</div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> <span class="keyword">auto</span> Partition(<span class="keyword">const</span> Pred&amp; predicate) <span class="keyword">const</span>;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /**</span></div>
<div class="line"><span class="comment">   * @brief Terminal operation: finds the element with the maximum value according to a key function.</span></div>
<div class="line"><span class="comment">   * @tparam KeyFunc Key extraction function type</span></div>
<div class="line"><span class="comment">   * @param key_func Function to extract comparison key from each element</span></div>
<div class="line"><span class="comment">   * @return Optional containing the element with maximum key, or empty if no elements</span></div>
<div class="line"><span class="comment">   */</span></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyFunc&gt;</div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> <span class="keyword">auto</span> MaxBy(<span class="keyword">const</span> KeyFunc&amp; key_func) <span class="keyword">const</span>;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /**</span></div>
<div class="line"><span class="comment">   * @brief Terminal operation: finds the element with the minimum value according to a key function.</span></div>
<div class="line"><span class="comment">   * @tparam KeyFunc Key extraction function type</span></div>
<div class="line"><span class="comment">   * @param key_func Function to extract comparison key from each element</span></div>
<div class="line"><span class="comment">   * @return Optional containing the element with minimum key, or empty if no elements</span></div>
<div class="line"><span class="comment">   */</span></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyFunc&gt;</div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> <span class="keyword">auto</span> MinBy(<span class="keyword">const</span> KeyFunc&amp; key_func) <span class="keyword">const</span>;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /**</span></div>
<div class="line"><span class="comment">   * @brief Terminal operation: groups elements by a key function.</span></div>
<div class="line"><span class="comment">   * @tparam KeyFunc Key extraction function type</span></div>
<div class="line"><span class="comment">   * @param key_func Function to extract grouping key from each element</span></div>
<div class="line"><span class="comment">   * @return Map from keys to vectors of elements with that key</span></div>
<div class="line"><span class="comment">   */</span></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyFunc&gt;</div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> <span class="keyword">auto</span> GroupBy(<span class="keyword">const</span> KeyFunc&amp; key_func) <span class="keyword">const</span>;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /**</span></div>
<div class="line"><span class="comment">   * @brief Terminal operation: collects all elements into a vector.</span></div>
<div class="line"><span class="comment">   * @return Vector containing all elements</span></div>
<div class="line"><span class="comment">   */</span></div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> <span class="keyword">auto</span> Collect() <span class="keyword">const</span>;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /**</span></div>
<div class="line"><span class="comment">   * @brief Terminal operation: writes all elements into an output iterator.</span></div>
<div class="line"><span class="comment">   * @details Consumes the adapter and writes each element to the provided output iterator.</span></div>
<div class="line"><span class="comment">   * This is more efficient than Collect() when you already have a destination container.</span></div>
<div class="line"><span class="comment">   * @tparam OutIt Output iterator type</span></div>
<div class="line"><span class="comment">   * @param out Output iterator to write elements into</span></div>
<div class="line"><span class="comment">   *</span></div>
<div class="line"><span class="comment">   * @example</span></div>
<div class="line"><span class="comment">   * @code</span></div>
<div class="line"><span class="comment">   * std::vector&lt;int&gt; results;</span></div>
<div class="line"><span class="comment">   * query.Filter([](int x) { return x &gt; 5; }).Into(std::back_inserter(results));</span></div>
<div class="line"><span class="comment">   * @endcode</span></div>
<div class="line"><span class="comment">   */</span></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> OutIt&gt;</div>
<div class="line">  <span class="keyword">constexpr</span> <span class="keywordtype">void</span> <a id="a160" name="a160"></a><a class="code hl_function" href="namespacehelios_1_1utils.html#afc9a7a7bb1cbdcdf23e717f41fa763be">Into</a>(OutIt out) <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">protected</span>:<span class="comment"></span></div>
<div class="line"><span class="comment">  /**</span></div>
<div class="line"><span class="comment">   * @brief Gets reference to derived class instance.</span></div>
<div class="line"><span class="comment">   * @return Reference to derived class</span></div>
<div class="line"><span class="comment">   */</span></div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> Derived&amp; <a class="code hl_function" href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">GetDerived</a>() <span class="keyword">noexcept</span> { <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>Derived&amp;<span class="keyword">&gt;</span>(*this); }</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /**</span></div>
<div class="line"><span class="comment">   * @brief Gets const reference to derived class instance.</span></div>
<div class="line"><span class="comment">   * @return Const reference to derived class</span></div>
<div class="line"><span class="comment">   */</span></div>
<div class="line">  [[nodiscard]] <span class="keyword">constexpr</span> <span class="keyword">const</span> Derived&amp; <a class="code hl_function" href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">GetDerived</a>() <span class="keyword">const</span> <span class="keyword">noexcept</span> { <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keyword">const </span>Derived&amp;<span class="keyword">&gt;</span>(*this); }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Derived&gt;</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Action&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keywordtype">void</span> FunctionalAdapterBase&lt;Derived&gt;::ForEach(<span class="keyword">const</span> Action&amp; action)<span class="keyword"> const </span>{</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp;&amp; value : <a class="code hl_function" href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">GetDerived</a>()) {</div>
<div class="line">    <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (std::invocable&lt;Action, <span class="keyword">decltype</span>(value)&gt;) {</div>
<div class="line">      action(std::forward&lt;<span class="keyword">decltype</span>(value)&gt;(value));</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      std::apply(action, std::forward&lt;<span class="keyword">decltype</span>(value)&gt;(value));</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Derived&gt;</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Folder&gt;</div>
<div class="line"><span class="keyword">constexpr</span> T FunctionalAdapterBase&lt;Derived&gt;::Fold(T init, <span class="keyword">const</span> Folder&amp; folder)<span class="keyword"> const </span>{</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp;&amp; value : <a class="code hl_function" href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">GetDerived</a>()) {</div>
<div class="line">    <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (std::invocable&lt;Folder, T&amp;&amp;, <span class="keyword">decltype</span>(value)&gt;) {</div>
<div class="line">      init = folder(std::move(init), std::forward&lt;<span class="keyword">decltype</span>(value)&gt;(value));</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      init = std::apply(</div>
<div class="line">          [&amp;init, &amp;folder](<span class="keyword">auto</span>&amp;&amp;... args) { <span class="keywordflow">return</span> folder(std::move(init), std::forward&lt;<span class="keyword">decltype</span>(args)&gt;(args)...); },</div>
<div class="line">          std::forward&lt;decltype(value)&gt;(value));</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> init;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Derived&gt;</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Pred&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keywordtype">bool</span> FunctionalAdapterBase&lt;Derived&gt;::Any(<span class="keyword">const</span> Pred&amp; predicate)<span class="keyword"> const </span>{</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp;&amp; value : <a class="code hl_function" href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">GetDerived</a>()) {</div>
<div class="line">    <span class="keywordtype">bool</span> result = <span class="keyword">false</span>;</div>
<div class="line">    <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (std::invocable&lt;Pred, <span class="keyword">decltype</span>(value)&gt;) {</div>
<div class="line">      result = predicate(std::forward&lt;<span class="keyword">decltype</span>(value)&gt;(value));</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      result = std::apply(predicate, std::forward&lt;<span class="keyword">decltype</span>(value)&gt;(value));</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (result) {</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Derived&gt;</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Pred&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keywordtype">bool</span> FunctionalAdapterBase&lt;Derived&gt;::All(<span class="keyword">const</span> Pred&amp; predicate)<span class="keyword"> const </span>{</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp;&amp; value : <a class="code hl_function" href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">GetDerived</a>()) {</div>
<div class="line">    <span class="keywordtype">bool</span> result = <span class="keyword">false</span>;</div>
<div class="line">    <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (std::invocable&lt;Pred, <span class="keyword">decltype</span>(value)&gt;) {</div>
<div class="line">      result = predicate(std::forward&lt;<span class="keyword">decltype</span>(value)&gt;(value));</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      result = std::apply(predicate, std::forward&lt;<span class="keyword">decltype</span>(value)&gt;(value));</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (!result) {</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Derived&gt;</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Pred&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> FunctionalAdapterBase&lt;Derived&gt;::Find(<span class="keyword">const</span> Pred&amp; predicate)<span class="keyword"> const </span>{</div>
<div class="line">  <span class="keyword">using </span>ValueType = std::iter_value_t&lt;Derived&gt;;</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp;&amp; value : <a class="code hl_function" href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">GetDerived</a>()) {</div>
<div class="line">    <span class="keywordtype">bool</span> result = <span class="keyword">false</span>;</div>
<div class="line">    <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (std::invocable&lt;Pred, <span class="keyword">decltype</span>(value)&gt;) {</div>
<div class="line">      result = predicate(std::forward&lt;<span class="keyword">decltype</span>(value)&gt;(value));</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      result = std::apply(predicate, std::forward&lt;<span class="keyword">decltype</span>(value)&gt;(value));</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (result) {</div>
<div class="line">      <span class="keywordflow">return</span> std::optional&lt;ValueType&gt;(std::forward&lt;<span class="keyword">decltype</span>(value)&gt;(value));</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> std::optional&lt;ValueType&gt;{};</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Derived&gt;</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Pred&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keywordtype">size_t</span> FunctionalAdapterBase&lt;Derived&gt;::CountIf(<span class="keyword">const</span> Pred&amp; predicate)<span class="keyword"> const </span>{</div>
<div class="line">  <span class="keywordtype">size_t</span> count = 0;</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp;&amp; value : <a class="code hl_function" href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">GetDerived</a>()) {</div>
<div class="line">    <span class="keywordtype">bool</span> result = <span class="keyword">false</span>;</div>
<div class="line">    <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (std::invocable&lt;Pred, <span class="keyword">decltype</span>(value)&gt;) {</div>
<div class="line">      result = predicate(std::forward&lt;<span class="keyword">decltype</span>(value)&gt;(value));</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      result = std::apply(predicate, std::forward&lt;<span class="keyword">decltype</span>(value)&gt;(value));</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (result) {</div>
<div class="line">      ++count;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> count;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Derived&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> FunctionalAdapterBase&lt;Derived&gt;::Collect()<span class="keyword"> const </span>{</div>
<div class="line">  <span class="keyword">using </span>ValueType = std::iter_value_t&lt;Derived&gt;;</div>
<div class="line">  std::vector&lt;ValueType&gt; result;</div>
<div class="line">  result.reserve(<span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(std::distance(<a class="code hl_function" href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">GetDerived</a>().begin(), <a class="code hl_function" href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">GetDerived</a>().end())));</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp;&amp; value : <a class="code hl_function" href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">GetDerived</a>()) {</div>
<div class="line">    result.push_back(std::forward&lt;<span class="keyword">decltype</span>(value)&gt;(value));</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Derived&gt;</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> OutIt&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keywordtype">void</span> FunctionalAdapterBase&lt;Derived&gt;::Into(OutIt out)<span class="keyword"> const </span>{</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp;&amp; value : <a class="code hl_function" href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">GetDerived</a>()) {</div>
<div class="line">    *out++ = std::forward&lt;decltype(value)&gt;(value);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Derived&gt;</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Pred&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> FunctionalAdapterBase&lt;Derived&gt;::Partition(<span class="keyword">const</span> Pred&amp; predicate)<span class="keyword"> const </span>{</div>
<div class="line">  <span class="keyword">using </span>ValueType = std::iter_value_t&lt;Derived&gt;;</div>
<div class="line">  std::vector&lt;ValueType&gt; matched;</div>
<div class="line">  std::vector&lt;ValueType&gt; not_matched;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp;&amp; value : <a class="code hl_function" href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">GetDerived</a>()) {</div>
<div class="line">    <span class="keywordtype">bool</span> result = <span class="keyword">false</span>;</div>
<div class="line">    <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (std::invocable&lt;Pred, <span class="keyword">decltype</span>(value)&gt;) {</div>
<div class="line">      result = predicate(std::forward&lt;<span class="keyword">decltype</span>(value)&gt;(value));</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      result = std::apply(predicate, std::forward&lt;<span class="keyword">decltype</span>(value)&gt;(value));</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (result) {</div>
<div class="line">      matched.push_back(std::forward&lt;<span class="keyword">decltype</span>(value)&gt;(value));</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      not_matched.push_back(std::forward&lt;<span class="keyword">decltype</span>(value)&gt;(value));</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> std::pair{std::move(matched), std::move(not_matched)};</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Derived&gt;</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyFunc&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> FunctionalAdapterBase&lt;Derived&gt;::MaxBy(<span class="keyword">const</span> KeyFunc&amp; key_func)<span class="keyword"> const </span>{</div>
<div class="line">  <span class="keyword">using </span>ValueType = std::iter_value_t&lt;Derived&gt;;</div>
<div class="line">  <span class="keyword">auto</span> iter = <a class="code hl_function" href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">GetDerived</a>().begin();</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> end_iter = <a class="code hl_function" href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">GetDerived</a>().end();</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (iter == end_iter) {</div>
<div class="line">    <span class="keywordflow">return</span> std::nullopt;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  std::optional&lt;ValueType&gt; max_element;</div>
<div class="line">  max_element.emplace(*iter);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> get_key = [&amp;key_func](<span class="keyword">auto</span>&amp;&amp; val) {</div>
<div class="line">    <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (std::invocable&lt;KeyFunc, <span class="keyword">decltype</span>(val)&gt;) {</div>
<div class="line">      <span class="keywordflow">return</span> key_func(std::forward&lt;<span class="keyword">decltype</span>(val)&gt;(val));</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      <span class="keywordflow">return</span> std::apply(key_func, std::forward&lt;<span class="keyword">decltype</span>(val)&gt;(val));</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> max_key = get_key(*max_element);</div>
<div class="line">  ++iter;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">while</span> (iter != end_iter) {</div>
<div class="line">    <span class="keyword">auto</span> current = *iter;</div>
<div class="line">    <span class="keyword">auto</span> current_key = get_key(current);</div>
<div class="line">    <span class="keywordflow">if</span> (current_key &gt; max_key) {</div>
<div class="line">      max_key = current_key;</div>
<div class="line">      max_element.emplace(current);</div>
<div class="line">    }</div>
<div class="line">    ++iter;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> max_element;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Derived&gt;</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyFunc&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> FunctionalAdapterBase&lt;Derived&gt;::MinBy(<span class="keyword">const</span> KeyFunc&amp; key_func)<span class="keyword"> const </span>{</div>
<div class="line">  <span class="keyword">using </span>ValueType = std::iter_value_t&lt;Derived&gt;;</div>
<div class="line">  <span class="keyword">auto</span> iter = <a class="code hl_function" href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">GetDerived</a>().begin();</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> end_iter = <a class="code hl_function" href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">GetDerived</a>().end();</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (iter == end_iter) {</div>
<div class="line">    <span class="keywordflow">return</span> std::nullopt;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  std::optional&lt;ValueType&gt; min_element;</div>
<div class="line">  min_element.emplace(*iter);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> get_key = [&amp;key_func](<span class="keyword">auto</span>&amp;&amp; val) {</div>
<div class="line">    <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (std::invocable&lt;KeyFunc, <span class="keyword">decltype</span>(val)&gt;) {</div>
<div class="line">      <span class="keywordflow">return</span> key_func(std::forward&lt;<span class="keyword">decltype</span>(val)&gt;(val));</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      <span class="keywordflow">return</span> std::apply(key_func, std::forward&lt;<span class="keyword">decltype</span>(val)&gt;(val));</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> min_key = get_key(*min_element);</div>
<div class="line">  ++iter;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">while</span> (iter != end_iter) {</div>
<div class="line">    <span class="keyword">auto</span> current = *iter;</div>
<div class="line">    <span class="keyword">auto</span> current_key = get_key(current);</div>
<div class="line">    <span class="keywordflow">if</span> (current_key &lt; min_key) {</div>
<div class="line">      min_key = current_key;</div>
<div class="line">      min_element.emplace(current);</div>
<div class="line">    }</div>
<div class="line">    ++iter;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> min_element;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Derived&gt;</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyFunc&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> FunctionalAdapterBase&lt;Derived&gt;::GroupBy(<span class="keyword">const</span> KeyFunc&amp; key_func)<span class="keyword"> const </span>{</div>
<div class="line">  <span class="keyword">using </span>ValueType = std::iter_value_t&lt;Derived&gt;;</div>
<div class="line">  <span class="keyword">using </span>KeyType = std::decay_t&lt;std::invoke_result_t&lt;KeyFunc, ValueType&gt;&gt;;</div>
<div class="line">  std::unordered_map&lt;KeyType, std::vector&lt;ValueType&gt;&gt; groups;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp;&amp; value : <a class="code hl_function" href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">GetDerived</a>()) {</div>
<div class="line">    KeyType key;</div>
<div class="line">    <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (std::invocable&lt;KeyFunc, <span class="keyword">decltype</span>(value)&gt;) {</div>
<div class="line">      key = key_func(std::forward&lt;<span class="keyword">decltype</span>(value)&gt;(value));</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      key = std::apply(key_func, std::forward&lt;<span class="keyword">decltype</span>(value)&gt;(value));</div>
<div class="line">    }</div>
<div class="line">    groups[std::move(key)].push_back(std::forward&lt;<span class="keyword">decltype</span>(value)&gt;(value));</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> groups;</div>
<div class="line">}</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * @brief Helper function to create a FilterAdapter from a non-const range.</span></div>
<div class="line"><span class="comment"> * @tparam R Range type</span></div>
<div class="line"><span class="comment"> * @tparam Pred Predicate type</span></div>
<div class="line"><span class="comment"> * @param range Range to filter</span></div>
<div class="line"><span class="comment"> * @param predicate Function to filter elements</span></div>
<div class="line"><span class="comment"> * @return FilterAdapter for the range</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">template</span> &lt;std::ranges::range R, <span class="keyword">typename</span> Pred&gt;</div>
<div class="line">  <span class="keyword">requires</span> FilterAdapterRequirements&lt;std::ranges::iterator_t&lt;R&gt;, Pred&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <a id="a161" name="a161"></a><a class="code hl_function" href="functional__adapters_8hpp.html#add0bba7ad8887393d4a80827e4d1331c">FilterAdapterFromRange</a>(R&amp; range, Pred predicate) <span class="keyword">noexcept</span>(</div>
<div class="line">    <span class="keyword">noexcept</span>(FilterAdapter&lt;std::ranges::iterator_t&lt;R&gt;, Pred&gt;(std::ranges::begin(range), std::ranges::end(range),</div>
<div class="line">                                                             std::move(predicate))))</div>
<div class="line">    -&gt; FilterAdapter&lt;std::ranges::iterator_t&lt;R&gt;, Pred&gt; {</div>
<div class="line">  <span class="keywordflow">return</span> {std::ranges::begin(range), std::ranges::end(range), std::move(predicate)};</div>
<div class="line">}</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * @brief Helper function to create a FilterAdapter from a const range.</span></div>
<div class="line"><span class="comment"> * @tparam R Range type</span></div>
<div class="line"><span class="comment"> * @tparam Pred Predicate type</span></div>
<div class="line"><span class="comment"> * @param range Range to filter</span></div>
<div class="line"><span class="comment"> * @param predicate Function to filter elements</span></div>
<div class="line"><span class="comment"> * @return FilterAdapter for the range</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">template</span> &lt;std::ranges::range R, <span class="keyword">typename</span> Pred&gt;</div>
<div class="line">  <span class="keyword">requires</span> FilterAdapterRequirements&lt;decltype(std::ranges::cbegin(std::declval&lt;const R&amp;&gt;())), Pred&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <a class="code hl_function" href="functional__adapters_8hpp.html#add0bba7ad8887393d4a80827e4d1331c">FilterAdapterFromRange</a>(<span class="keyword">const</span> R&amp; range, Pred predicate) <span class="keyword">noexcept</span>(</div>
<div class="line">    <span class="keyword">noexcept</span>(FilterAdapter&lt;decltype(std::ranges::cbegin(range)), Pred&gt;(std::ranges::cbegin(range),</div>
<div class="line">                                                                       std::ranges::cend(range), std::move(predicate))))</div>
<div class="line">    -&gt; FilterAdapter&lt;<span class="keyword">decltype</span>(std::ranges::cbegin(range)), Pred&gt; {</div>
<div class="line">  <span class="keywordflow">return</span> {std::ranges::cbegin(range), std::ranges::cend(range), std::move(predicate)};</div>
<div class="line">}</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * @brief Helper function to create a MapAdapter from a range.</span></div>
<div class="line"><span class="comment"> * @tparam R Range type</span></div>
<div class="line"><span class="comment"> * @tparam Func Transformation function type</span></div>
<div class="line"><span class="comment"> * @param range Range to map</span></div>
<div class="line"><span class="comment"> * @param transform Function to apply to each element</span></div>
<div class="line"><span class="comment"> * @return MapAdapter for the range</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">template</span> &lt;std::ranges::range R, <span class="keyword">typename</span> Func&gt;</div>
<div class="line">  <span class="keyword">requires</span> MapAdapterRequirements&lt;std::ranges::iterator_t&lt;R&gt;, Func&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <a id="a162" name="a162"></a><a class="code hl_function" href="functional__adapters_8hpp.html#ae484a9df0df45155f7f4b1bc3c82a926">MapAdapterFromRange</a>(R&amp; range, Func transform) <span class="keyword">noexcept</span>(</div>
<div class="line">    <span class="keyword">noexcept</span>(MapAdapter&lt;std::ranges::iterator_t&lt;R&gt;, Func&gt;(std::ranges::begin(range), std::ranges::end(range),</div>
<div class="line">                                                          std::move(transform))))</div>
<div class="line">    -&gt; MapAdapter&lt;std::ranges::iterator_t&lt;R&gt;, Func&gt; {</div>
<div class="line">  <span class="keywordflow">return</span> {std::ranges::begin(range), std::ranges::end(range), std::move(transform)};</div>
<div class="line">}</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * @brief Helper function to create a MapAdapter from a const range.</span></div>
<div class="line"><span class="comment"> * @tparam R Range type</span></div>
<div class="line"><span class="comment"> * @tparam Func Transformation function type</span></div>
<div class="line"><span class="comment"> * @param range Range to map</span></div>
<div class="line"><span class="comment"> * @param transform Function to apply to each element</span></div>
<div class="line"><span class="comment"> * @return MapAdapter for the range</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">template</span> &lt;std::ranges::range R, <span class="keyword">typename</span> Func&gt;</div>
<div class="line">  <span class="keyword">requires</span> MapAdapterRequirements&lt;decltype(std::ranges::cbegin(std::declval&lt;const R&amp;&gt;())), Func&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <a class="code hl_function" href="functional__adapters_8hpp.html#ae484a9df0df45155f7f4b1bc3c82a926">MapAdapterFromRange</a>(<span class="keyword">const</span> R&amp; range, Func transform) <span class="keyword">noexcept</span>(</div>
<div class="line">    <span class="keyword">noexcept</span>(MapAdapter&lt;decltype(std::ranges::cbegin(range)), Func&gt;(std::ranges::cbegin(range),</div>
<div class="line">                                                                    std::ranges::cend(range), std::move(transform))))</div>
<div class="line">    -&gt; MapAdapter&lt;<span class="keyword">decltype</span>(std::ranges::cbegin(range)), Func&gt; {</div>
<div class="line">  <span class="keywordflow">return</span> {std::ranges::cbegin(range), std::ranges::cend(range), std::move(transform)};</div>
<div class="line">}</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * @brief Helper function to create a TakeAdapter from a non-const range.</span></div>
<div class="line"><span class="comment"> * @tparam R Range type</span></div>
<div class="line"><span class="comment"> * @param range Range to take from</span></div>
<div class="line"><span class="comment"> * @param count Maximum number of elements to yield</span></div>
<div class="line"><span class="comment"> * @return TakeAdapter for the range</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">template</span> &lt;std::ranges::range R&gt;</div>
<div class="line">  <span class="keyword">requires</span> TakeAdapterRequirements&lt;std::ranges::iterator_t&lt;R&gt;&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <a id="a163" name="a163"></a><a class="code hl_function" href="functional__adapters_8hpp.html#a6a5fe42a5d6a908d4890d22cdd1ac0b5">TakeAdapterFromRange</a>(R&amp; range, <span class="keywordtype">size_t</span> count) <span class="keyword">noexcept</span>(</div>
<div class="line">    <span class="keyword">noexcept</span>(TakeAdapter&lt;std::ranges::iterator_t&lt;R&gt;&gt;(std::ranges::begin(range), std::ranges::end(range), count)))</div>
<div class="line">    -&gt; TakeAdapter&lt;std::ranges::iterator_t&lt;R&gt;&gt; {</div>
<div class="line">  <span class="keywordflow">return</span> {std::ranges::begin(range), std::ranges::end(range), count};</div>
<div class="line">}</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * @brief Helper function to create a TakeAdapter from a const range.</span></div>
<div class="line"><span class="comment"> * @tparam R Range type</span></div>
<div class="line"><span class="comment"> * @param range Range to take from</span></div>
<div class="line"><span class="comment"> * @param count Maximum number of elements to yield</span></div>
<div class="line"><span class="comment"> * @return TakeAdapter for the range</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">template</span> &lt;std::ranges::range R&gt;</div>
<div class="line">  <span class="keyword">requires</span> TakeAdapterRequirements&lt;decltype(std::ranges::cbegin(std::declval&lt;const R&amp;&gt;()))&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <a class="code hl_function" href="functional__adapters_8hpp.html#a6a5fe42a5d6a908d4890d22cdd1ac0b5">TakeAdapterFromRange</a>(<span class="keyword">const</span> R&amp; range, <span class="keywordtype">size_t</span> count) <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(</div>
<div class="line">    TakeAdapter&lt;decltype(std::ranges::cbegin(range))&gt;(std::ranges::cbegin(range), std::ranges::cend(range), count)))</div>
<div class="line">    -&gt; TakeAdapter&lt;<span class="keyword">decltype</span>(std::ranges::cbegin(range))&gt; {</div>
<div class="line">  <span class="keywordflow">return</span> {std::ranges::cbegin(range), std::ranges::cend(range), count};</div>
<div class="line">}</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * @brief Helper function to create a SkipAdapter from a non-const range.</span></div>
<div class="line"><span class="comment"> * @tparam R Range type</span></div>
<div class="line"><span class="comment"> * @param range Range to skip from</span></div>
<div class="line"><span class="comment"> * @param count Number of elements to skip</span></div>
<div class="line"><span class="comment"> * @return SkipAdapter for the range</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">template</span> &lt;std::ranges::range R&gt;</div>
<div class="line">  <span class="keyword">requires</span> SkipAdapterRequirements&lt;std::ranges::iterator_t&lt;R&gt;&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <a id="a164" name="a164"></a><a class="code hl_function" href="functional__adapters_8hpp.html#a865e738990cd1d760c9a395d24646704">SkipAdapterFromRange</a>(R&amp; range, <span class="keywordtype">size_t</span> count) <span class="keyword">noexcept</span>(</div>
<div class="line">    <span class="keyword">noexcept</span>(SkipAdapter&lt;std::ranges::iterator_t&lt;R&gt;&gt;(std::ranges::begin(range), std::ranges::end(range), count)))</div>
<div class="line">    -&gt; SkipAdapter&lt;std::ranges::iterator_t&lt;R&gt;&gt; {</div>
<div class="line">  <span class="keywordflow">return</span> {std::ranges::begin(range), std::ranges::end(range), count};</div>
<div class="line">}</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * @brief Helper function to create a SkipAdapter from a const range.</span></div>
<div class="line"><span class="comment"> * @tparam R Range type</span></div>
<div class="line"><span class="comment"> * @param range Range to skip from</span></div>
<div class="line"><span class="comment"> * @param count Number of elements to skip</span></div>
<div class="line"><span class="comment"> * @return SkipAdapter for the range</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">template</span> &lt;std::ranges::range R&gt;</div>
<div class="line">  <span class="keyword">requires</span> SkipAdapterRequirements&lt;decltype(std::ranges::cbegin(std::declval&lt;const R&amp;&gt;()))&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <a class="code hl_function" href="functional__adapters_8hpp.html#a865e738990cd1d760c9a395d24646704">SkipAdapterFromRange</a>(<span class="keyword">const</span> R&amp; range, <span class="keywordtype">size_t</span> count) <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(</div>
<div class="line">    SkipAdapter&lt;decltype(std::ranges::cbegin(range))&gt;(std::ranges::cbegin(range), std::ranges::cend(range), count)))</div>
<div class="line">    -&gt; SkipAdapter&lt;<span class="keyword">decltype</span>(std::ranges::cbegin(range))&gt; {</div>
<div class="line">  <span class="keywordflow">return</span> {std::ranges::cbegin(range), std::ranges::cend(range), count};</div>
<div class="line">}</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * @brief Helper function to create a TakeWhileAdapter from a non-const range.</span></div>
<div class="line"><span class="comment"> * @tparam R Range type</span></div>
<div class="line"><span class="comment"> * @tparam Pred Predicate type</span></div>
<div class="line"><span class="comment"> * @param range Range to take from</span></div>
<div class="line"><span class="comment"> * @param predicate Predicate to test elements</span></div>
<div class="line"><span class="comment"> * @return TakeWhileAdapter for the range</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">template</span> &lt;std::ranges::range R, <span class="keyword">typename</span> Pred&gt;</div>
<div class="line">  <span class="keyword">requires</span> TakeWhileAdapterRequirements&lt;std::ranges::iterator_t&lt;R&gt;, Pred&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <a id="a165" name="a165"></a><a class="code hl_function" href="functional__adapters_8hpp.html#ae395ae0aba4682d48ff4e235a326fbf0">TakeWhileAdapterFromRange</a>(R&amp; range, Pred predicate) <span class="keyword">noexcept</span>(</div>
<div class="line">    <span class="keyword">noexcept</span>(TakeWhileAdapter&lt;std::ranges::iterator_t&lt;R&gt;, Pred&gt;(std::ranges::begin(range), std::ranges::end(range),</div>
<div class="line">                                                                std::move(predicate))))</div>
<div class="line">    -&gt; TakeWhileAdapter&lt;std::ranges::iterator_t&lt;R&gt;, Pred&gt; {</div>
<div class="line">  <span class="keywordflow">return</span> {std::ranges::begin(range), std::ranges::end(range), std::move(predicate)};</div>
<div class="line">}</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * @brief Helper function to create a TakeWhileAdapter from a const range.</span></div>
<div class="line"><span class="comment"> * @tparam R Range type</span></div>
<div class="line"><span class="comment"> * @tparam Pred Predicate type</span></div>
<div class="line"><span class="comment"> * @param range Range to take from</span></div>
<div class="line"><span class="comment"> * @param predicate Predicate to test elements</span></div>
<div class="line"><span class="comment"> * @return TakeWhileAdapter for the range</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">template</span> &lt;std::ranges::range R, <span class="keyword">typename</span> Pred&gt;</div>
<div class="line">  <span class="keyword">requires</span> TakeWhileAdapterRequirements&lt;decltype(std::ranges::cbegin(std::declval&lt;const R&amp;&gt;())), Pred&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <a class="code hl_function" href="functional__adapters_8hpp.html#ae395ae0aba4682d48ff4e235a326fbf0">TakeWhileAdapterFromRange</a>(<span class="keyword">const</span> R&amp; range, Pred predicate) <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(</div>
<div class="line">    TakeWhileAdapter&lt;decltype(std::ranges::cbegin(range)), Pred&gt;(std::ranges::cbegin(range), std::ranges::cend(range),</div>
<div class="line">                                                                 std::move(predicate))))</div>
<div class="line">    -&gt; TakeWhileAdapter&lt;<span class="keyword">decltype</span>(std::ranges::cbegin(range)), Pred&gt; {</div>
<div class="line">  <span class="keywordflow">return</span> {std::ranges::cbegin(range), std::ranges::cend(range), std::move(predicate)};</div>
<div class="line">}</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * @brief Helper function to create a SkipWhileAdapter from a non-const range.</span></div>
<div class="line"><span class="comment"> * @tparam R Range type</span></div>
<div class="line"><span class="comment"> * @tparam Pred Predicate type</span></div>
<div class="line"><span class="comment"> * @param range Range to skip from</span></div>
<div class="line"><span class="comment"> * @param predicate Predicate to test elements</span></div>
<div class="line"><span class="comment"> * @return SkipWhileAdapter for the range</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">template</span> &lt;std::ranges::range R, <span class="keyword">typename</span> Pred&gt;</div>
<div class="line">  <span class="keyword">requires</span> SkipWhileAdapterRequirements&lt;std::ranges::iterator_t&lt;R&gt;, Pred&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <a id="a166" name="a166"></a><a class="code hl_function" href="functional__adapters_8hpp.html#a3f7766fbd29295bb0e1464dace44c679">SkipWhileAdapterFromRange</a>(R&amp; range, Pred predicate) <span class="keyword">noexcept</span>(</div>
<div class="line">    <span class="keyword">noexcept</span>(SkipWhileAdapter&lt;std::ranges::iterator_t&lt;R&gt;, Pred&gt;(std::ranges::begin(range), std::ranges::end(range),</div>
<div class="line">                                                                std::move(predicate))))</div>
<div class="line">    -&gt; SkipWhileAdapter&lt;std::ranges::iterator_t&lt;R&gt;, Pred&gt; {</div>
<div class="line">  <span class="keywordflow">return</span> {std::ranges::begin(range), std::ranges::end(range), std::move(predicate)};</div>
<div class="line">}</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * @brief Helper function to create a SkipWhileAdapter from a const range.</span></div>
<div class="line"><span class="comment"> * @tparam R Range type</span></div>
<div class="line"><span class="comment"> * @tparam Pred Predicate type</span></div>
<div class="line"><span class="comment"> * @param range Range to skip from</span></div>
<div class="line"><span class="comment"> * @param predicate Predicate to test elements</span></div>
<div class="line"><span class="comment"> * @return SkipWhileAdapter for the range</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">template</span> &lt;std::ranges::range R, <span class="keyword">typename</span> Pred&gt;</div>
<div class="line">  <span class="keyword">requires</span> SkipWhileAdapterRequirements&lt;decltype(std::ranges::cbegin(std::declval&lt;const R&amp;&gt;())), Pred&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <a class="code hl_function" href="functional__adapters_8hpp.html#a3f7766fbd29295bb0e1464dace44c679">SkipWhileAdapterFromRange</a>(<span class="keyword">const</span> R&amp; range, Pred predicate) <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(</div>
<div class="line">    SkipWhileAdapter&lt;decltype(std::ranges::cbegin(range)), Pred&gt;(std::ranges::cbegin(range), std::ranges::cend(range),</div>
<div class="line">                                                                 std::move(predicate))))</div>
<div class="line">    -&gt; SkipWhileAdapter&lt;<span class="keyword">decltype</span>(std::ranges::cbegin(range)), Pred&gt; {</div>
<div class="line">  <span class="keywordflow">return</span> {std::ranges::cbegin(range), std::ranges::cend(range), std::move(predicate)};</div>
<div class="line">}</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * @brief Helper function to create an EnumerateAdapter from a non-const range.</span></div>
<div class="line"><span class="comment"> * @tparam R Range type</span></div>
<div class="line"><span class="comment"> * @param range Range to enumerate</span></div>
<div class="line"><span class="comment"> * @return EnumerateAdapter for the range</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">template</span> &lt;std::ranges::range R&gt;</div>
<div class="line">  <span class="keyword">requires</span> EnumerateAdapterRequirements&lt;std::ranges::iterator_t&lt;R&gt;&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <a id="a167" name="a167"></a><a class="code hl_function" href="functional__adapters_8hpp.html#a26c8c7da02f4a54443fbb24411500ba2">EnumerateAdapterFromRange</a>(R&amp; range) <span class="keyword">noexcept</span>(</div>
<div class="line">    <span class="keyword">noexcept</span>(EnumerateAdapter&lt;std::ranges::iterator_t&lt;R&gt;&gt;(std::ranges::begin(range), std::ranges::end(range))))</div>
<div class="line">    -&gt; EnumerateAdapter&lt;std::ranges::iterator_t&lt;R&gt;&gt; {</div>
<div class="line">  <span class="keywordflow">return</span> {std::ranges::begin(range), std::ranges::end(range)};</div>
<div class="line">}</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * @brief Helper function to create an EnumerateAdapter from a const range.</span></div>
<div class="line"><span class="comment"> * @tparam R Range type</span></div>
<div class="line"><span class="comment"> * @param range Range to enumerate</span></div>
<div class="line"><span class="comment"> * @return EnumerateAdapter for the range</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">template</span> &lt;std::ranges::range R&gt;</div>
<div class="line">  <span class="keyword">requires</span> EnumerateAdapterRequirements&lt;decltype(std::ranges::cbegin(std::declval&lt;const R&amp;&gt;()))&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <a class="code hl_function" href="functional__adapters_8hpp.html#a26c8c7da02f4a54443fbb24411500ba2">EnumerateAdapterFromRange</a>(<span class="keyword">const</span> R&amp; range) <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(</div>
<div class="line">    EnumerateAdapter&lt;decltype(std::ranges::cbegin(range))&gt;(std::ranges::cbegin(range), std::ranges::cend(range))))</div>
<div class="line">    -&gt; EnumerateAdapter&lt;<span class="keyword">decltype</span>(std::ranges::cbegin(range))&gt; {</div>
<div class="line">  <span class="keywordflow">return</span> {std::ranges::cbegin(range), std::ranges::cend(range)};</div>
<div class="line">}</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * @brief Helper function to create an InspectAdapter from a non-const range.</span></div>
<div class="line"><span class="comment"> * @tparam R Range type</span></div>
<div class="line"><span class="comment"> * @tparam Func Inspector function type</span></div>
<div class="line"><span class="comment"> * @param range Range to inspect</span></div>
<div class="line"><span class="comment"> * @param inspector Function to call on each element</span></div>
<div class="line"><span class="comment"> * @return InspectAdapter for the range</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">template</span> &lt;std::ranges::range R, <span class="keyword">typename</span> Func&gt;</div>
<div class="line">  <span class="keyword">requires</span> InspectAdapterRequirements&lt;std::ranges::iterator_t&lt;R&gt;, Func&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <a id="a168" name="a168"></a><a class="code hl_function" href="functional__adapters_8hpp.html#ad246f1f7640da69f162cf174105bde02">InspectAdapterFromRange</a>(R&amp; range, Func inspector) <span class="keyword">noexcept</span>(</div>
<div class="line">    <span class="keyword">noexcept</span>(InspectAdapter&lt;std::ranges::iterator_t&lt;R&gt;, Func&gt;(std::ranges::begin(range), std::ranges::end(range),</div>
<div class="line">                                                              std::move(inspector))))</div>
<div class="line">    -&gt; InspectAdapter&lt;std::ranges::iterator_t&lt;R&gt;, Func&gt; {</div>
<div class="line">  <span class="keywordflow">return</span> {std::ranges::begin(range), std::ranges::end(range), std::move(inspector)};</div>
<div class="line">}</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * @brief Helper function to create an InspectAdapter from a const range.</span></div>
<div class="line"><span class="comment"> * @tparam R Range type</span></div>
<div class="line"><span class="comment"> * @tparam Func Inspector function type</span></div>
<div class="line"><span class="comment"> * @param range Range to inspect</span></div>
<div class="line"><span class="comment"> * @param inspector Function to call for each element</span></div>
<div class="line"><span class="comment"> * @return InspectAdapter for the range</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">template</span> &lt;std::ranges::range R, <span class="keyword">typename</span> Func&gt;</div>
<div class="line">  <span class="keyword">requires</span> InspectAdapterRequirements&lt;decltype(std::ranges::cbegin(std::declval&lt;const R&amp;&gt;())), Func&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <a class="code hl_function" href="functional__adapters_8hpp.html#ad246f1f7640da69f162cf174105bde02">InspectAdapterFromRange</a>(<span class="keyword">const</span> R&amp; range, Func inspector) <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(</div>
<div class="line">    InspectAdapter&lt;decltype(std::ranges::cbegin(range)), Func&gt;(std::ranges::cbegin(range), std::ranges::cend(range),</div>
<div class="line">                                                               std::move(inspector))))</div>
<div class="line">    -&gt; InspectAdapter&lt;<span class="keyword">decltype</span>(std::ranges::cbegin(range)), Func&gt; {</div>
<div class="line">  <span class="keywordflow">return</span> {std::ranges::cbegin(range), std::ranges::cend(range), std::move(inspector)};</div>
<div class="line">}</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * @brief Helper function to create a StepByAdapter from a non-const range.</span></div>
<div class="line"><span class="comment"> * @tparam R Range type</span></div>
<div class="line"><span class="comment"> * @param range Range to step through</span></div>
<div class="line"><span class="comment"> * @param step Step size</span></div>
<div class="line"><span class="comment"> * @return StepByAdapter for the range</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">template</span> &lt;std::ranges::range R&gt;</div>
<div class="line">  <span class="keyword">requires</span> StepByAdapterRequirements&lt;std::ranges::iterator_t&lt;R&gt;&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <a id="a169" name="a169"></a><a class="code hl_function" href="functional__adapters_8hpp.html#abf8910c7748dc4db0ce7534c2ee6c941">StepByAdapterFromRange</a>(R&amp; range, <span class="keywordtype">size_t</span> step) <span class="keyword">noexcept</span>(</div>
<div class="line">    <span class="keyword">noexcept</span>(StepByAdapter&lt;std::ranges::iterator_t&lt;R&gt;&gt;(std::ranges::begin(range), std::ranges::end(range), step)))</div>
<div class="line">    -&gt; StepByAdapter&lt;std::ranges::iterator_t&lt;R&gt;&gt; {</div>
<div class="line">  <span class="keywordflow">return</span> {std::ranges::begin(range), std::ranges::end(range), step};</div>
<div class="line">}</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * @brief Helper function to create a StepByAdapter from a const range.</span></div>
<div class="line"><span class="comment"> * @tparam R Range type</span></div>
<div class="line"><span class="comment"> * @param range Range to step through</span></div>
<div class="line"><span class="comment"> * @param step Number of elements to step by</span></div>
<div class="line"><span class="comment"> * @return StepByAdapter for the range</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">template</span> &lt;std::ranges::range R&gt;</div>
<div class="line">  <span class="keyword">requires</span> StepByAdapterRequirements&lt;decltype(std::ranges::cbegin(std::declval&lt;const R&amp;&gt;()))&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <a class="code hl_function" href="functional__adapters_8hpp.html#abf8910c7748dc4db0ce7534c2ee6c941">StepByAdapterFromRange</a>(<span class="keyword">const</span> R&amp; range, <span class="keywordtype">size_t</span> step) <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(</div>
<div class="line">    StepByAdapter&lt;decltype(std::ranges::cbegin(range))&gt;(std::ranges::cbegin(range), std::ranges::cend(range), step)))</div>
<div class="line">    -&gt; StepByAdapter&lt;<span class="keyword">decltype</span>(std::ranges::cbegin(range))&gt; {</div>
<div class="line">  <span class="keywordflow">return</span> {std::ranges::cbegin(range), std::ranges::cend(range), step};</div>
<div class="line">}</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * @brief Helper function to create a ChainAdapter from two non-const ranges.</span></div>
<div class="line"><span class="comment"> * @tparam R1 First range type</span></div>
<div class="line"><span class="comment"> * @tparam R2 Second range type</span></div>
<div class="line"><span class="comment"> * @param range1 First range</span></div>
<div class="line"><span class="comment"> * @param range2 Second range</span></div>
<div class="line"><span class="comment"> * @return ChainAdapter for the two ranges</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">template</span> &lt;std::ranges::range R1, std::ranges::range R2&gt;</div>
<div class="line">  <span class="keyword">requires</span> ChainAdapterRequirements&lt;std::ranges::iterator_t&lt;R1&gt;, std::ranges::iterator_t&lt;R2&gt;&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <a class="code hl_function" href="functional__adapters_8hpp.html#aadcef6f6e0d096f987d0f75a5aac3abf">ChainAdapterFromRange</a>(R1&amp; range1, R2&amp; range2) <span class="keyword">noexcept</span>(</div>
<div class="line">    <span class="keyword">noexcept</span>(ChainAdapter&lt;std::ranges::iterator_t&lt;R1&gt;, std::ranges::iterator_t&lt;R2&gt;&gt;(</div>
<div class="line">        std::ranges::begin(range1), std::ranges::end(range1), std::ranges::begin(range2), std::ranges::end(range2))))</div>
<div class="line">    -&gt; ChainAdapter&lt;std::ranges::iterator_t&lt;R1&gt;, std::ranges::iterator_t&lt;R2&gt;&gt; {</div>
<div class="line">  <span class="keywordflow">return</span> {std::ranges::begin(range1), std::ranges::end(range1), std::ranges::begin(range2), std::ranges::end(range2)};</div>
<div class="line">}</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * @brief Helper function to create a ChainAdapter from non-const and const ranges.</span></div>
<div class="line"><span class="comment"> * @tparam R1 First range type</span></div>
<div class="line"><span class="comment"> * @tparam R2 Second range type</span></div>
<div class="line"><span class="comment"> * @param range1 First range</span></div>
<div class="line"><span class="comment"> * @param range2 Second range</span></div>
<div class="line"><span class="comment"> * @return ChainAdapter for the two ranges</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">template</span> &lt;std::ranges::range R1, std::ranges::range R2&gt;</div>
<div class="line">  <span class="keyword">requires</span> ChainAdapterRequirements&lt;std::ranges::iterator_t&lt;R1&gt;,</div>
<div class="line">                                    <span class="keyword">decltype</span>(std::ranges::cbegin(std::declval&lt;const R2&amp;&gt;()))&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <a class="code hl_function" href="functional__adapters_8hpp.html#aadcef6f6e0d096f987d0f75a5aac3abf">ChainAdapterFromRange</a>(R1&amp; range1, <span class="keyword">const</span> R2&amp; range2) <span class="keyword">noexcept</span>(</div>
<div class="line">    <span class="keyword">noexcept</span>(ChainAdapter&lt;std::ranges::iterator_t&lt;R1&gt;, <span class="keyword">decltype</span>(std::ranges::cbegin(range2))&gt;(</div>
<div class="line">        std::ranges::begin(range1), std::ranges::end(range1), std::ranges::cbegin(range2), std::ranges::cend(range2))))</div>
<div class="line">    -&gt; ChainAdapter&lt;std::ranges::iterator_t&lt;R1&gt;, <span class="keyword">decltype</span>(std::ranges::cbegin(range2))&gt; {</div>
<div class="line">  <span class="keywordflow">return</span> {std::ranges::begin(range1), std::ranges::end(range1), std::ranges::cbegin(range2), std::ranges::cend(range2)};</div>
<div class="line">}</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * @brief Helper function to create a ChainAdapter from const and non-const ranges.</span></div>
<div class="line"><span class="comment"> * @tparam R1 First range type</span></div>
<div class="line"><span class="comment"> * @tparam R2 Second range type</span></div>
<div class="line"><span class="comment"> * @param range1 First range</span></div>
<div class="line"><span class="comment"> * @param range2 Second range</span></div>
<div class="line"><span class="comment"> * @return ChainAdapter for the two ranges</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">template</span> &lt;std::ranges::range R1, std::ranges::range R2&gt;</div>
<div class="line">  <span class="keyword">requires</span> ChainAdapterRequirements&lt;decltype(std::ranges::cbegin(std::declval&lt;const R1&amp;&gt;())),</div>
<div class="line">                                    std::ranges::iterator_t&lt;R2&gt;&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <a class="code hl_function" href="functional__adapters_8hpp.html#aadcef6f6e0d096f987d0f75a5aac3abf">ChainAdapterFromRange</a>(<span class="keyword">const</span> R1&amp; range1, R2&amp; range2) <span class="keyword">noexcept</span>(</div>
<div class="line">    <span class="keyword">noexcept</span>(ChainAdapter&lt;<span class="keyword">decltype</span>(std::ranges::cbegin(range1)), std::ranges::iterator_t&lt;R2&gt;&gt;(</div>
<div class="line">        std::ranges::cbegin(range1), std::ranges::cend(range1), std::ranges::begin(range2), std::ranges::end(range2))))</div>
<div class="line">    -&gt; ChainAdapter&lt;<span class="keyword">decltype</span>(std::ranges::cbegin(range1)), std::ranges::iterator_t&lt;R2&gt;&gt; {</div>
<div class="line">  <span class="keywordflow">return</span> {std::ranges::cbegin(range1), std::ranges::cend(range1), std::ranges::begin(range2), std::ranges::end(range2)};</div>
<div class="line">}</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * @brief Helper function to create a ChainAdapter from two const ranges.</span></div>
<div class="line"><span class="comment"> * @tparam R1 First range type</span></div>
<div class="line"><span class="comment"> * @tparam R2 Second range type</span></div>
<div class="line"><span class="comment"> * @param range1 First range</span></div>
<div class="line"><span class="comment"> * @param range2 Second range</span></div>
<div class="line"><span class="comment"> * @return ChainAdapter for the two ranges</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">template</span> &lt;std::ranges::range R1, std::ranges::range R2&gt;</div>
<div class="line">  <span class="keyword">requires</span> ChainAdapterRequirements&lt;decltype(std::ranges::cbegin(std::declval&lt;const R1&amp;&gt;())),</div>
<div class="line">                                    <span class="keyword">decltype</span>(std::ranges::cbegin(std::declval&lt;const R2&amp;&gt;()))&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <a class="code hl_function" href="functional__adapters_8hpp.html#aadcef6f6e0d096f987d0f75a5aac3abf">ChainAdapterFromRange</a>(<span class="keyword">const</span> R1&amp; range1, <span class="keyword">const</span> R2&amp; range2) <span class="keyword">noexcept</span>(</div>
<div class="line">    <span class="keyword">noexcept</span>(ChainAdapter&lt;decltype(std::ranges::cbegin(range1)), decltype(std::ranges::cbegin(range2))&gt;(</div>
<div class="line">        std::ranges::cbegin(range1), std::ranges::cend(range1), std::ranges::cbegin(range2),</div>
<div class="line">        std::ranges::cend(range2))))</div>
<div class="line">    -&gt; ChainAdapter&lt;<span class="keyword">decltype</span>(std::ranges::cbegin(range1)), <span class="keyword">decltype</span>(std::ranges::cbegin(range2))&gt; {</div>
<div class="line">  <span class="keywordflow">return</span> {std::ranges::cbegin(range1), std::ranges::cend(range1), std::ranges::cbegin(range2),</div>
<div class="line">          std::ranges::cend(range2)};</div>
<div class="line">}</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * @brief Helper function to create a ReverseAdapter from a range.</span></div>
<div class="line"><span class="comment"> * @tparam R Range type</span></div>
<div class="line"><span class="comment"> * @param range Range to reverse</span></div>
<div class="line"><span class="comment"> * @return ReverseAdapter for the range</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">template</span> &lt;std::ranges::range R&gt;</div>
<div class="line">  <span class="keyword">requires</span> ReverseAdapterRequirements&lt;std::ranges::iterator_t&lt;R&gt;&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <a id="a170" name="a170"></a><a class="code hl_function" href="functional__adapters_8hpp.html#a1f22bfef6bdc6c9e48c264f1ab73b94c">ReverseAdapterFromRange</a>(R&amp; range) <span class="keyword">noexcept</span>(</div>
<div class="line">    <span class="keyword">noexcept</span>(ReverseAdapter&lt;std::ranges::iterator_t&lt;R&gt;&gt;(std::ranges::begin(range), std::ranges::end(range))))</div>
<div class="line">    -&gt; ReverseAdapter&lt;std::ranges::iterator_t&lt;R&gt;&gt; {</div>
<div class="line">  <span class="keywordflow">return</span> {std::ranges::begin(range), std::ranges::end(range)};</div>
<div class="line">}</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * @brief Helper function to create a ReverseAdapter from a const range.</span></div>
<div class="line"><span class="comment"> * @tparam R Range type</span></div>
<div class="line"><span class="comment"> * @param range Range to reverse</span></div>
<div class="line"><span class="comment"> * @return ReverseAdapter for the range</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">template</span> &lt;std::ranges::range R&gt;</div>
<div class="line">  <span class="keyword">requires</span> ReverseAdapterRequirements&lt;decltype(std::ranges::cbegin(std::declval&lt;const R&amp;&gt;()))&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <a class="code hl_function" href="functional__adapters_8hpp.html#a1f22bfef6bdc6c9e48c264f1ab73b94c">ReverseAdapterFromRange</a>(<span class="keyword">const</span> R&amp; range) <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(</div>
<div class="line">    ReverseAdapter&lt;decltype(std::ranges::cbegin(range))&gt;(std::ranges::cbegin(range), std::ranges::cend(range))))</div>
<div class="line">    -&gt; ReverseAdapter&lt;<span class="keyword">decltype</span>(std::ranges::cbegin(range))&gt; {</div>
<div class="line">  <span class="keywordflow">return</span> {std::ranges::cbegin(range), std::ranges::cend(range)};</div>
<div class="line">}</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * @brief Helper function to create a JoinAdapter from a range.</span></div>
<div class="line"><span class="comment"> * @tparam R Range type</span></div>
<div class="line"><span class="comment"> * @param range Range to join</span></div>
<div class="line"><span class="comment"> * @return JoinAdapter for the range</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">template</span> &lt;std::ranges::range R&gt;</div>
<div class="line">  <span class="keyword">requires</span> JoinAdapterRequirements&lt;std::ranges::iterator_t&lt;R&gt;&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <a id="a171" name="a171"></a><a class="code hl_function" href="functional__adapters_8hpp.html#a24be1e723416c19e6b3f500653076dd9">JoinAdapterFromRange</a>(R&amp; range) <span class="keyword">noexcept</span>(</div>
<div class="line">    <span class="keyword">noexcept</span>(JoinAdapter&lt;std::ranges::iterator_t&lt;R&gt;&gt;(std::ranges::begin(range), std::ranges::end(range))))</div>
<div class="line">    -&gt; JoinAdapter&lt;std::ranges::iterator_t&lt;R&gt;&gt; {</div>
<div class="line">  <span class="keywordflow">return</span> {std::ranges::begin(range), std::ranges::end(range)};</div>
<div class="line">}</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * @brief Helper function to create a JoinAdapter from a const range.</span></div>
<div class="line"><span class="comment"> * @tparam R Range type</span></div>
<div class="line"><span class="comment"> * @param range Range to join</span></div>
<div class="line"><span class="comment"> * @return JoinAdapter for the range</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">template</span> &lt;std::ranges::range R&gt;</div>
<div class="line">  <span class="keyword">requires</span> JoinAdapterRequirements&lt;decltype(std::ranges::cbegin(std::declval&lt;const R&amp;&gt;()))&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <a class="code hl_function" href="functional__adapters_8hpp.html#a24be1e723416c19e6b3f500653076dd9">JoinAdapterFromRange</a>(<span class="keyword">const</span> R&amp; range) <span class="keyword">noexcept</span>(</div>
<div class="line">    <span class="keyword">noexcept</span>(JoinAdapter&lt;decltype(std::ranges::cbegin(range))&gt;(std::ranges::cbegin(range), std::ranges::cend(range))))</div>
<div class="line">    -&gt; JoinAdapter&lt;<span class="keyword">decltype</span>(std::ranges::cbegin(range))&gt; {</div>
<div class="line">  <span class="keywordflow">return</span> {std::ranges::cbegin(range), std::ranges::cend(range)};</div>
<div class="line">}</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * @brief Helper function to create a SlideAdapter from a range.</span></div>
<div class="line"><span class="comment"> * @tparam R Range type</span></div>
<div class="line"><span class="comment"> * @param range Range to slide over</span></div>
<div class="line"><span class="comment"> * @param window_size Size of the sliding window</span></div>
<div class="line"><span class="comment"> * @return SlideAdapter for the range</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">template</span> &lt;std::ranges::range R&gt;</div>
<div class="line">  <span class="keyword">requires</span> SlideAdapterRequirements&lt;std::ranges::iterator_t&lt;R&gt;&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <a id="a172" name="a172"></a><a class="code hl_function" href="functional__adapters_8hpp.html#aea9c1e9b8d0d8913b14a2c348aa0c2a4">SlideAdapterFromRange</a>(R&amp; range, <span class="keywordtype">size_t</span> window_size) <span class="keyword">noexcept</span>(</div>
<div class="line">    <span class="keyword">noexcept</span>(SlideAdapter&lt;std::ranges::iterator_t&lt;R&gt;&gt;(std::ranges::begin(range), std::ranges::end(range), window_size)))</div>
<div class="line">    -&gt; SlideAdapter&lt;std::ranges::iterator_t&lt;R&gt;&gt; {</div>
<div class="line">  <span class="keywordflow">return</span> {std::ranges::begin(range), std::ranges::end(range), window_size};</div>
<div class="line">}</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * @brief Helper function to create a SlideAdapter from a const range.</span></div>
<div class="line"><span class="comment"> * @tparam R Range type</span></div>
<div class="line"><span class="comment"> * @param range Range to slide over</span></div>
<div class="line"><span class="comment"> * @param window_size Size of the sliding window</span></div>
<div class="line"><span class="comment"> * @return SlideAdapter for the range</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">template</span> &lt;std::ranges::range R&gt;</div>
<div class="line">  <span class="keyword">requires</span> SlideAdapterRequirements&lt;decltype(std::ranges::cbegin(std::declval&lt;const R&amp;&gt;()))&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <a class="code hl_function" href="functional__adapters_8hpp.html#aea9c1e9b8d0d8913b14a2c348aa0c2a4">SlideAdapterFromRange</a>(<span class="keyword">const</span> R&amp; range, <span class="keywordtype">size_t</span> window_size) <span class="keyword">noexcept</span>(</div>
<div class="line">    <span class="keyword">noexcept</span>(SlideAdapter&lt;decltype(std::ranges::cbegin(range))&gt;(std::ranges::cbegin(range), std::ranges::cend(range),</div>
<div class="line">                                                                window_size)))</div>
<div class="line">    -&gt; SlideAdapter&lt;<span class="keyword">decltype</span>(std::ranges::cbegin(range))&gt; {</div>
<div class="line">  <span class="keywordflow">return</span> {std::ranges::cbegin(range), std::ranges::cend(range), window_size};</div>
<div class="line">}</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * @brief Helper function to create a StrideAdapter from a range.</span></div>
<div class="line"><span class="comment"> * @tparam R Range type</span></div>
<div class="line"><span class="comment"> * @param range Range to stride over</span></div>
<div class="line"><span class="comment"> * @param stride Stride value</span></div>
<div class="line"><span class="comment"> * @return StrideAdapter for the range</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">template</span> &lt;std::ranges::range R&gt;</div>
<div class="line">  <span class="keyword">requires</span> StrideAdapterRequirements&lt;std::ranges::iterator_t&lt;R&gt;&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <a id="a173" name="a173"></a><a class="code hl_function" href="functional__adapters_8hpp.html#af4298b8b0abb2ebfe46dccfd80362d61">StrideAdapterFromRange</a>(R&amp; range, <span class="keywordtype">size_t</span> stride) <span class="keyword">noexcept</span>(</div>
<div class="line">    <span class="keyword">noexcept</span>(StrideAdapter&lt;std::ranges::iterator_t&lt;R&gt;&gt;(std::ranges::begin(range), std::ranges::end(range), stride)))</div>
<div class="line">    -&gt; StrideAdapter&lt;std::ranges::iterator_t&lt;R&gt;&gt; {</div>
<div class="line">  <span class="keywordflow">return</span> {std::ranges::begin(range), std::ranges::end(range), stride};</div>
<div class="line">}</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * @brief Helper function to create a StrideAdapter from a const range.</span></div>
<div class="line"><span class="comment"> * @tparam R Range type</span></div>
<div class="line"><span class="comment"> * @param range Range to stride over</span></div>
<div class="line"><span class="comment"> * @param stride Stride value</span></div>
<div class="line"><span class="comment"> * @return StrideAdapter for the range</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">template</span> &lt;std::ranges::range R&gt;</div>
<div class="line">  <span class="keyword">requires</span> StrideAdapterRequirements&lt;decltype(std::ranges::cbegin(std::declval&lt;const R&amp;&gt;()))&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <a class="code hl_function" href="functional__adapters_8hpp.html#af4298b8b0abb2ebfe46dccfd80362d61">StrideAdapterFromRange</a>(<span class="keyword">const</span> R&amp; range, <span class="keywordtype">size_t</span> stride) <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(</div>
<div class="line">    StrideAdapter&lt;decltype(std::ranges::cbegin(range))&gt;(std::ranges::cbegin(range), std::ranges::cend(range), stride)))</div>
<div class="line">    -&gt; StrideAdapter&lt;<span class="keyword">decltype</span>(std::ranges::cbegin(range))&gt; {</div>
<div class="line">  <span class="keywordflow">return</span> {std::ranges::cbegin(range), std::ranges::cend(range), stride};</div>
<div class="line">}</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * @brief Helper function to create a ZipAdapter from two ranges.</span></div>
<div class="line"><span class="comment"> * @tparam R1 First range type</span></div>
<div class="line"><span class="comment"> * @tparam R2 Second range type</span></div>
<div class="line"><span class="comment"> * @param range1 First range</span></div>
<div class="line"><span class="comment"> * @param range2 Second range</span></div>
<div class="line"><span class="comment"> * @return ZipAdapter for the two ranges</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">template</span> &lt;std::ranges::range R1, std::ranges::range R2&gt;</div>
<div class="line">  <span class="keyword">requires</span> ZipAdapterRequirements&lt;std::ranges::iterator_t&lt;R1&gt;, std::ranges::iterator_t&lt;R2&gt;&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <a class="code hl_function" href="functional__adapters_8hpp.html#a22e05a1859c49e16d93d42691c556664">ZipAdapterFromRange</a>(R1&amp; range1, R2&amp; range2) <span class="keyword">noexcept</span>(</div>
<div class="line">    <span class="keyword">noexcept</span>(ZipAdapter&lt;std::ranges::iterator_t&lt;R1&gt;, std::ranges::iterator_t&lt;R2&gt;&gt;(</div>
<div class="line">        std::ranges::begin(range1), std::ranges::end(range1), std::ranges::begin(range2), std::ranges::end(range2))))</div>
<div class="line">    -&gt; ZipAdapter&lt;std::ranges::iterator_t&lt;R1&gt;, std::ranges::iterator_t&lt;R2&gt;&gt; {</div>
<div class="line">  <span class="keywordflow">return</span> {std::ranges::begin(range1), std::ranges::end(range1), std::ranges::begin(range2), std::ranges::end(range2)};</div>
<div class="line">}</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * @brief Helper function to create a ZipAdapter from a range and a const range.</span></div>
<div class="line"><span class="comment"> * @tparam R1 First range type</span></div>
<div class="line"><span class="comment"> * @tparam R2 Second range type</span></div>
<div class="line"><span class="comment"> * @param range1 First range</span></div>
<div class="line"><span class="comment"> * @param range2 Second range</span></div>
<div class="line"><span class="comment"> * @return ZipAdapter for the two ranges</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">template</span> &lt;std::ranges::range R1, std::ranges::range R2&gt;</div>
<div class="line">  <span class="keyword">requires</span> ZipAdapterRequirements&lt;std::ranges::iterator_t&lt;R1&gt;, <span class="keyword">decltype</span>(std::ranges::cbegin(std::declval&lt;const R2&amp;&gt;()))&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <a class="code hl_function" href="functional__adapters_8hpp.html#a22e05a1859c49e16d93d42691c556664">ZipAdapterFromRange</a>(R1&amp; range1, <span class="keyword">const</span> R2&amp; range2) <span class="keyword">noexcept</span>(</div>
<div class="line">    <span class="keyword">noexcept</span>(ZipAdapter&lt;std::ranges::iterator_t&lt;R1&gt;, <span class="keyword">decltype</span>(std::ranges::cbegin(range2))&gt;(</div>
<div class="line">        std::ranges::begin(range1), std::ranges::end(range1), std::ranges::cbegin(range2), std::ranges::cend(range2))))</div>
<div class="line">    -&gt; ZipAdapter&lt;std::ranges::iterator_t&lt;R1&gt;, <span class="keyword">decltype</span>(std::ranges::cbegin(range2))&gt; {</div>
<div class="line">  <span class="keywordflow">return</span> {std::ranges::begin(range1), std::ranges::end(range1), std::ranges::cbegin(range2), std::ranges::cend(range2)};</div>
<div class="line">}</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * @brief Helper function to create a ZipAdapter from two const ranges.</span></div>
<div class="line"><span class="comment"> * @tparam R1 First range type</span></div>
<div class="line"><span class="comment"> * @tparam R2 Second range type</span></div>
<div class="line"><span class="comment"> * @param range1 First range</span></div>
<div class="line"><span class="comment"> * @param range2 Second range</span></div>
<div class="line"><span class="comment"> * @return ZipAdapter for the two ranges</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">template</span> &lt;std::ranges::range R1, std::ranges::range R2&gt;</div>
<div class="line">  <span class="keyword">requires</span> ZipAdapterRequirements&lt;decltype(std::ranges::cbegin(std::declval&lt;const R1&amp;&gt;())),</div>
<div class="line">                                  <span class="keyword">decltype</span>(std::ranges::cbegin(std::declval&lt;const R2&amp;&gt;()))&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <a class="code hl_function" href="functional__adapters_8hpp.html#a22e05a1859c49e16d93d42691c556664">ZipAdapterFromRange</a>(<span class="keyword">const</span> R1&amp; range1, <span class="keyword">const</span> R2&amp; range2) <span class="keyword">noexcept</span>(</div>
<div class="line">    <span class="keyword">noexcept</span>(ZipAdapter&lt;decltype(std::ranges::cbegin(range1)), decltype(std::ranges::cbegin(range2))&gt;(</div>
<div class="line">        std::ranges::cbegin(range1), std::ranges::cend(range1), std::ranges::cbegin(range2),</div>
<div class="line">        std::ranges::cend(range2))))</div>
<div class="line">    -&gt; ZipAdapter&lt;<span class="keyword">decltype</span>(std::ranges::cbegin(range1)), <span class="keyword">decltype</span>(std::ranges::cbegin(range2))&gt; {</div>
<div class="line">  <span class="keywordflow">return</span> {std::ranges::cbegin(range1), std::ranges::cend(range1), std::ranges::cbegin(range2),</div>
<div class="line">          std::ranges::cend(range2)};</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">}  <span class="comment">// namespace helios::utils</span></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1ChainAdapter_html_a02e09c72c1f7579cf1aebd23e952a9f3"><div class="ttname"><a href="classhelios_1_1utils_1_1ChainAdapter.html#a02e09c72c1f7579cf1aebd23e952a9f3">helios::utils::ChainAdapter::end</a></div><div class="ttdeci">constexpr ChainAdapter end() const noexcept(std::is_nothrow_copy_constructible_v&lt; ChainAdapter &gt; &amp;&amp;std::is_nothrow_copy_constructible_v&lt; Iter1 &gt; &amp;&amp;std::is_nothrow_copy_constructible_v&lt; Iter2 &gt;)</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l01579">functional_adapters.hpp:1579</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1ChainAdapter_html_a0deb22c1e54bfed5b4d8852a31a500c6"><div class="ttname"><a href="classhelios_1_1utils_1_1ChainAdapter.html#a0deb22c1e54bfed5b4d8852a31a500c6">helios::utils::ChainAdapter::pointer</a></div><div class="ttdeci">value_type * pointer</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l01459">functional_adapters.hpp:1459</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1ChainAdapter_html_a1aa1883fd20402a6cd7651d6c00b8a0d"><div class="ttname"><a href="classhelios_1_1utils_1_1ChainAdapter.html#a1aa1883fd20402a6cd7651d6c00b8a0d">helios::utils::ChainAdapter::iterator_category</a></div><div class="ttdeci">std::forward_iterator_tag iterator_category</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l01456">functional_adapters.hpp:1456</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1ChainAdapter_html_a24d079ad5a4b289c447a207a9d7e5f9f"><div class="ttname"><a href="classhelios_1_1utils_1_1ChainAdapter.html#a24d079ad5a4b289c447a207a9d7e5f9f">helios::utils::ChainAdapter::operator==</a></div><div class="ttdeci">constexpr bool operator==(const ChainAdapter &amp;other) const noexcept(noexcept(std::declval&lt; const Iter1 &amp; &gt;()==std::declval&lt; const Iter1 &amp; &gt;()) &amp;&amp;noexcept(std::declval&lt; const Iter2 &amp; &gt;()==std::declval&lt; const Iter2 &amp; &gt;()))</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l01558">functional_adapters.hpp:1558</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1ChainAdapter_html_a32c2c7be3b12012fede6081d3de0d917"><div class="ttname"><a href="classhelios_1_1utils_1_1ChainAdapter.html#a32c2c7be3b12012fede6081d3de0d917">helios::utils::ChainAdapter::operator=</a></div><div class="ttdeci">constexpr ChainAdapter &amp; operator=(const ChainAdapter &amp;) noexcept(std::is_nothrow_copy_assignable_v&lt; Iter1 &gt; &amp;&amp;std::is_nothrow_copy_assignable_v&lt; Iter2 &gt;)=default</div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1ChainAdapter_html_a3a8275d11f139d46ccc715db0bb3dcbe"><div class="ttname"><a href="classhelios_1_1utils_1_1ChainAdapter.html#a3a8275d11f139d46ccc715db0bb3dcbe">helios::utils::ChainAdapter::operator++</a></div><div class="ttdeci">constexpr ChainAdapter &amp; operator++() noexcept(noexcept(++std::declval&lt; Iter1 &amp; &gt;()) &amp;&amp;noexcept(++std::declval&lt; Iter2 &amp; &gt;()) &amp;&amp;noexcept(std::declval&lt; Iter1 &amp; &gt;()==std::declval&lt; Iter1 &amp; &gt;()) &amp;&amp;noexcept(std::declval&lt; Iter2 &amp; &gt;() !=std::declval&lt; Iter2 &amp; &gt;()))</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l01530">functional_adapters.hpp:1530</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1ChainAdapter_html_a450b3956aaefa50deb0bf40d06ca1c23"><div class="ttname"><a href="classhelios_1_1utils_1_1ChainAdapter.html#a450b3956aaefa50deb0bf40d06ca1c23">helios::utils::ChainAdapter::operator*</a></div><div class="ttdeci">constexpr value_type operator*() const noexcept(noexcept(*std::declval&lt; const Iter1 &amp; &gt;()) &amp;&amp;noexcept(*std::declval&lt; const Iter2 &amp; &gt;()))</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l01498">functional_adapters.hpp:1498</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1ChainAdapter_html_a721626a9ee24136fac8453764cf94699"><div class="ttname"><a href="classhelios_1_1utils_1_1ChainAdapter.html#a721626a9ee24136fac8453764cf94699">helios::utils::ChainAdapter::~ChainAdapter</a></div><div class="ttdeci">constexpr ~ChainAdapter() noexcept(std::is_nothrow_destructible_v&lt; Iter1 &gt; &amp;&amp;std::is_nothrow_destructible_v&lt; Iter2 &gt;)=default</div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1ChainAdapter_html_a7d78c23fb348e6a613685e3f74d157ae"><div class="ttname"><a href="classhelios_1_1utils_1_1ChainAdapter.html#a7d78c23fb348e6a613685e3f74d157ae">helios::utils::ChainAdapter::operator!=</a></div><div class="ttdeci">constexpr bool operator!=(const ChainAdapter &amp;other) const noexcept(noexcept(std::declval&lt; const ChainAdapter &amp; &gt;()==std::declval&lt; const ChainAdapter &amp; &gt;()))</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l01507">functional_adapters.hpp:1507</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1ChainAdapter_html_a8e2b8edb8500a1b0c3514185ff6463ec"><div class="ttname"><a href="classhelios_1_1utils_1_1ChainAdapter.html#a8e2b8edb8500a1b0c3514185ff6463ec">helios::utils::ChainAdapter::value_type</a></div><div class="ttdeci">std::iter_value_t&lt; Iter1 &gt; value_type</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l01457">functional_adapters.hpp:1457</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1ChainAdapter_html_aadd5ad34997e979db16c23a3b852d4e2"><div class="ttname"><a href="classhelios_1_1utils_1_1ChainAdapter.html#aadd5ad34997e979db16c23a3b852d4e2">helios::utils::ChainAdapter::reference</a></div><div class="ttdeci">value_type reference</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l01460">functional_adapters.hpp:1460</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1ChainAdapter_html_ab6d6d5adc3b94d6604c1b90da9978223"><div class="ttname"><a href="classhelios_1_1utils_1_1ChainAdapter.html#ab6d6d5adc3b94d6604c1b90da9978223">helios::utils::ChainAdapter::begin</a></div><div class="ttdeci">constexpr ChainAdapter begin() const noexcept(std::is_nothrow_copy_constructible_v&lt; ChainAdapter &gt;)</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l01512">functional_adapters.hpp:1512</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1ChainAdapter_html_ae0da89bb79dfcf55034ec241014f393f"><div class="ttname"><a href="classhelios_1_1utils_1_1ChainAdapter.html#ae0da89bb79dfcf55034ec241014f393f">helios::utils::ChainAdapter::difference_type</a></div><div class="ttdeci">std::common_type_t&lt; std::iter_difference_t&lt; Iter1 &gt;, std::iter_difference_t&lt; Iter2 &gt; &gt; difference_type</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l01458">functional_adapters.hpp:1458</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1EnumerateAdapter_html_a0395dfc987c94bd9f17afc9c538b7d4c"><div class="ttname"><a href="classhelios_1_1utils_1_1EnumerateAdapter.html#a0395dfc987c94bd9f17afc9c538b7d4c">helios::utils::EnumerateAdapter::begin</a></div><div class="ttdeci">constexpr EnumerateAdapter begin() const noexcept(std::is_nothrow_copy_constructible_v&lt; EnumerateAdapter &gt;)</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l01187">functional_adapters.hpp:1187</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1EnumerateAdapter_html_a0839f20fab71eb6fbfb49aac02d0d7f5"><div class="ttname"><a href="classhelios_1_1utils_1_1EnumerateAdapter.html#a0839f20fab71eb6fbfb49aac02d0d7f5">helios::utils::EnumerateAdapter::difference_type</a></div><div class="ttdeci">std::iter_difference_t&lt; Iter &gt; difference_type</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l01151">functional_adapters.hpp:1151</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1EnumerateAdapter_html_a188212a2c22f25e5d91c1f62b81c42d8"><div class="ttname"><a href="classhelios_1_1utils_1_1EnumerateAdapter.html#a188212a2c22f25e5d91c1f62b81c42d8">helios::utils::EnumerateAdapter::operator=</a></div><div class="ttdeci">constexpr EnumerateAdapter &amp; operator=(const EnumerateAdapter &amp;)=default</div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1EnumerateAdapter_html_a2ab6bbf6492bc8f2aaced81830c2f37b"><div class="ttname"><a href="classhelios_1_1utils_1_1EnumerateAdapter.html#a2ab6bbf6492bc8f2aaced81830c2f37b">helios::utils::EnumerateAdapter::reference</a></div><div class="ttdeci">value_type reference</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l01153">functional_adapters.hpp:1153</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1EnumerateAdapter_html_a2d2d637cf9d201de327a275f67def5c8"><div class="ttname"><a href="classhelios_1_1utils_1_1EnumerateAdapter.html#a2d2d637cf9d201de327a275f67def5c8">helios::utils::EnumerateAdapter::operator++</a></div><div class="ttdeci">constexpr EnumerateAdapter &amp; operator++() noexcept(noexcept(++std::declval&lt; Iter &amp; &gt;()))</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l01206">functional_adapters.hpp:1206</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1EnumerateAdapter_html_a543beca8e1f344204da6278557b3fb86"><div class="ttname"><a href="classhelios_1_1utils_1_1EnumerateAdapter.html#a543beca8e1f344204da6278557b3fb86">helios::utils::EnumerateAdapter::~EnumerateAdapter</a></div><div class="ttdeci">constexpr ~EnumerateAdapter()=default</div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1EnumerateAdapter_html_a61abeeef6e4377a14b6589fac9035b7d"><div class="ttname"><a href="classhelios_1_1utils_1_1EnumerateAdapter.html#a61abeeef6e4377a14b6589fac9035b7d">helios::utils::EnumerateAdapter::end</a></div><div class="ttdeci">constexpr EnumerateAdapter end() const noexcept(std::is_nothrow_constructible_v&lt; EnumerateAdapter, const Iter &amp;, const Iter &amp; &gt;)</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l01192">functional_adapters.hpp:1192</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1EnumerateAdapter_html_a6ec8cfe9e477fedc4ad0d2eb121030eb"><div class="ttname"><a href="classhelios_1_1utils_1_1EnumerateAdapter.html#a6ec8cfe9e477fedc4ad0d2eb121030eb">helios::utils::EnumerateAdapter::operator!=</a></div><div class="ttdeci">constexpr bool operator!=(const EnumerateAdapter &amp;other) const noexcept(noexcept(std::declval&lt; const EnumerateAdapter &amp; &gt;()==std::declval&lt; const EnumerateAdapter &amp; &gt;()))</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l01182">functional_adapters.hpp:1182</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1EnumerateAdapter_html_a70c790b447d8547eeb7e7d7b0aa36726"><div class="ttname"><a href="classhelios_1_1utils_1_1EnumerateAdapter.html#a70c790b447d8547eeb7e7d7b0aa36726">helios::utils::EnumerateAdapter::operator==</a></div><div class="ttdeci">constexpr bool operator==(const EnumerateAdapter &amp;other) const noexcept(noexcept(std::declval&lt; const Iter &amp; &gt;()==std::declval&lt; const Iter &amp; &gt;()))</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l01177">functional_adapters.hpp:1177</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1EnumerateAdapter_html_a76558608db80bc080dc109c6f791f7e7"><div class="ttname"><a href="classhelios_1_1utils_1_1EnumerateAdapter.html#a76558608db80bc080dc109c6f791f7e7">helios::utils::EnumerateAdapter::iterator_category</a></div><div class="ttdeci">std::forward_iterator_tag iterator_category</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l01149">functional_adapters.hpp:1149</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1EnumerateAdapter_html_a829b88dcccc7f10af66f7bb6628d88f3"><div class="ttname"><a href="classhelios_1_1utils_1_1EnumerateAdapter.html#a829b88dcccc7f10af66f7bb6628d88f3">helios::utils::EnumerateAdapter::operator*</a></div><div class="ttdeci">constexpr value_type operator*() const</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l01224">functional_adapters.hpp:1224</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1EnumerateAdapter_html_adeef92fda10757c956047fc39133c739"><div class="ttname"><a href="classhelios_1_1utils_1_1EnumerateAdapter.html#adeef92fda10757c956047fc39133c739">helios::utils::EnumerateAdapter::value_type</a></div><div class="ttdeci">typename MakeEnumeratedValue&lt; std::iter_value_t&lt; Iter &gt; &gt;::type value_type</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l01150">functional_adapters.hpp:1150</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1EnumerateAdapter_html_aea933b38b742f334f70c8c4c489ed555"><div class="ttname"><a href="classhelios_1_1utils_1_1EnumerateAdapter.html#aea933b38b742f334f70c8c4c489ed555">helios::utils::EnumerateAdapter::pointer</a></div><div class="ttdeci">value_type * pointer</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l01152">functional_adapters.hpp:1152</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1FilterAdapter_html_a0990c4e2e7e4aefab7ca5c9efef8712c"><div class="ttname"><a href="classhelios_1_1utils_1_1FilterAdapter.html#a0990c4e2e7e4aefab7ca5c9efef8712c">helios::utils::FilterAdapter::value_type</a></div><div class="ttdeci">std::iter_value_t&lt; Iter &gt; value_type</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l00377">functional_adapters.hpp:377</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1FilterAdapter_html_a2b6f115f430bc06636f918349ecafa26"><div class="ttname"><a href="classhelios_1_1utils_1_1FilterAdapter.html#a2b6f115f430bc06636f918349ecafa26">helios::utils::FilterAdapter::end</a></div><div class="ttdeci">constexpr FilterAdapter end() const noexcept(std::is_nothrow_constructible_v&lt; FilterAdapter, const Iter &amp;, const Iter &amp;, const Pred &amp; &gt;)</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l00439">functional_adapters.hpp:439</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1FilterAdapter_html_a3391a88e0643c85d299943070d6833d0"><div class="ttname"><a href="classhelios_1_1utils_1_1FilterAdapter.html#a3391a88e0643c85d299943070d6833d0">helios::utils::FilterAdapter::difference_type</a></div><div class="ttdeci">std::iter_difference_t&lt; Iter &gt; difference_type</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l00378">functional_adapters.hpp:378</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1FilterAdapter_html_a3f546933049a8c8d7b550effcf6a9acc"><div class="ttname"><a href="classhelios_1_1utils_1_1FilterAdapter.html#a3f546933049a8c8d7b550effcf6a9acc">helios::utils::FilterAdapter::operator*</a></div><div class="ttdeci">constexpr value_type operator*() const noexcept(noexcept(*std::declval&lt; const Iter &amp; &gt;()))</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l00412">functional_adapters.hpp:412</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1FilterAdapter_html_a4fa8bccdf13c4a0996f588e5116613ed"><div class="ttname"><a href="classhelios_1_1utils_1_1FilterAdapter.html#a4fa8bccdf13c4a0996f588e5116613ed">helios::utils::FilterAdapter::iterator_category</a></div><div class="ttdeci">std::forward_iterator_tag iterator_category</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l00376">functional_adapters.hpp:376</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1FilterAdapter_html_a50c5b2344ebddb229f57e26502f4c14d"><div class="ttname"><a href="classhelios_1_1utils_1_1FilterAdapter.html#a50c5b2344ebddb229f57e26502f4c14d">helios::utils::FilterAdapter::operator!=</a></div><div class="ttdeci">constexpr bool operator!=(const FilterAdapter &amp;other) const noexcept(noexcept(std::declval&lt; const FilterAdapter &amp; &gt;()==std::declval&lt; const FilterAdapter &amp; &gt;()))</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l00421">functional_adapters.hpp:421</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1FilterAdapter_html_a72d4d330718c70483b2d7e77ff8ad078"><div class="ttname"><a href="classhelios_1_1utils_1_1FilterAdapter.html#a72d4d330718c70483b2d7e77ff8ad078">helios::utils::FilterAdapter::operator==</a></div><div class="ttdeci">constexpr bool operator==(const FilterAdapter &amp;other) const noexcept(noexcept(std::declval&lt; const Iter &amp; &gt;()==std::declval&lt; const Iter &amp; &gt;()))</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l00416">functional_adapters.hpp:416</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1FilterAdapter_html_a84b0b5106aae4d1dea104598fbe0972f"><div class="ttname"><a href="classhelios_1_1utils_1_1FilterAdapter.html#a84b0b5106aae4d1dea104598fbe0972f">helios::utils::FilterAdapter::operator++</a></div><div class="ttdeci">constexpr FilterAdapter &amp; operator++() noexcept(noexcept(++std::declval&lt; Iter &amp; &gt;()) &amp;&amp;noexcept(AdvanceToValid()))</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l00457">functional_adapters.hpp:457</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1FilterAdapter_html_a9387ce1238cd6a70f0e76f5ddeaf1e04"><div class="ttname"><a href="classhelios_1_1utils_1_1FilterAdapter.html#a9387ce1238cd6a70f0e76f5ddeaf1e04">helios::utils::FilterAdapter::pointer</a></div><div class="ttdeci">value_type * pointer</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l00379">functional_adapters.hpp:379</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1FilterAdapter_html_a93d694a2db572479331fb1dbf46ea67c"><div class="ttname"><a href="classhelios_1_1utils_1_1FilterAdapter.html#a93d694a2db572479331fb1dbf46ea67c">helios::utils::FilterAdapter::reference</a></div><div class="ttdeci">value_type reference</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l00380">functional_adapters.hpp:380</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1FilterAdapter_html_ac8a734932c8789de85b5b09f11bb8c46"><div class="ttname"><a href="classhelios_1_1utils_1_1FilterAdapter.html#ac8a734932c8789de85b5b09f11bb8c46">helios::utils::FilterAdapter::operator=</a></div><div class="ttdeci">constexpr FilterAdapter &amp; operator=(const FilterAdapter &amp;) noexcept(std::is_nothrow_copy_assignable_v&lt; Iter &gt; &amp;&amp;std::is_nothrow_copy_assignable_v&lt; Pred &gt;)=default</div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1FilterAdapter_html_ae4f733ecc64b5130a71f8656803fb8f0"><div class="ttname"><a href="classhelios_1_1utils_1_1FilterAdapter.html#ae4f733ecc64b5130a71f8656803fb8f0">helios::utils::FilterAdapter::~FilterAdapter</a></div><div class="ttdeci">constexpr ~FilterAdapter() noexcept(std::is_nothrow_destructible_v&lt; Iter &gt; &amp;&amp;std::is_nothrow_destructible_v&lt; Pred &gt;)=default</div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1FilterAdapter_html_af952a366fad4ddc65e2f7fa613b9bf6d"><div class="ttname"><a href="classhelios_1_1utils_1_1FilterAdapter.html#af952a366fad4ddc65e2f7fa613b9bf6d">helios::utils::FilterAdapter::IsAtEnd</a></div><div class="ttdeci">constexpr bool IsAtEnd() const noexcept(noexcept(std::declval&lt; const Iter &amp; &gt;()==std::declval&lt; const Iter &amp; &gt;()))</div><div class="ttdoc">Checks if the iterator has reached the end.</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l00430">functional_adapters.hpp:430</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1FilterAdapter_html_afe19b8fcd9acb515403302a1ecec4f78"><div class="ttname"><a href="classhelios_1_1utils_1_1FilterAdapter.html#afe19b8fcd9acb515403302a1ecec4f78">helios::utils::FilterAdapter::begin</a></div><div class="ttdeci">constexpr FilterAdapter begin() const noexcept(std::is_nothrow_copy_constructible_v&lt; FilterAdapter &gt;)</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l00435">functional_adapters.hpp:435</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1InspectAdapter_html_a2f3e93dbbcd76e475a22adfcdea89bc6"><div class="ttname"><a href="classhelios_1_1utils_1_1InspectAdapter.html#a2f3e93dbbcd76e475a22adfcdea89bc6">helios::utils::InspectAdapter::operator++</a></div><div class="ttdeci">constexpr InspectAdapter &amp; operator++() noexcept(noexcept(++std::declval&lt; Iter &amp; &gt;()))</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l01314">functional_adapters.hpp:1314</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1InspectAdapter_html_a31aa483c616ef40dd72d4d9d814f0af9"><div class="ttname"><a href="classhelios_1_1utils_1_1InspectAdapter.html#a31aa483c616ef40dd72d4d9d814f0af9">helios::utils::InspectAdapter::reference</a></div><div class="ttdeci">value_type reference</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l01254">functional_adapters.hpp:1254</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1InspectAdapter_html_a33c8ff3a44410abe45118d5c57172c26"><div class="ttname"><a href="classhelios_1_1utils_1_1InspectAdapter.html#a33c8ff3a44410abe45118d5c57172c26">helios::utils::InspectAdapter::operator*</a></div><div class="ttdeci">constexpr value_type operator*() const noexcept(std::is_nothrow_invocable_v&lt; Func, std::iter_value_t&lt; Iter &gt; &gt; &amp;&amp;noexcept(*std::declval&lt; const Iter &amp; &gt;()))</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l01331">functional_adapters.hpp:1331</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1InspectAdapter_html_a48eb41137995a02221e73c672e4035e1"><div class="ttname"><a href="classhelios_1_1utils_1_1InspectAdapter.html#a48eb41137995a02221e73c672e4035e1">helios::utils::InspectAdapter::begin</a></div><div class="ttdeci">constexpr InspectAdapter begin() const noexcept(std::is_nothrow_copy_constructible_v&lt; InspectAdapter &gt;)</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l01296">functional_adapters.hpp:1296</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1InspectAdapter_html_a581d9ae2a40ba2b60d0a3ae658683f88"><div class="ttname"><a href="classhelios_1_1utils_1_1InspectAdapter.html#a581d9ae2a40ba2b60d0a3ae658683f88">helios::utils::InspectAdapter::operator=</a></div><div class="ttdeci">constexpr InspectAdapter &amp; operator=(const InspectAdapter &amp;) noexcept(std::is_nothrow_copy_assignable_v&lt; Iter &gt; &amp;&amp;std::is_nothrow_copy_assignable_v&lt; Func &gt;)=default</div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1InspectAdapter_html_a68ecfdb71f244f33b23dfb9bc9f67068"><div class="ttname"><a href="classhelios_1_1utils_1_1InspectAdapter.html#a68ecfdb71f244f33b23dfb9bc9f67068">helios::utils::InspectAdapter::operator==</a></div><div class="ttdeci">constexpr bool operator==(const InspectAdapter &amp;other) const noexcept(noexcept(std::declval&lt; const Iter &amp; &gt;()==std::declval&lt; const Iter &amp; &gt;()))</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l01286">functional_adapters.hpp:1286</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1InspectAdapter_html_a7087a02ef4b60a11f90b31a1ce92767c"><div class="ttname"><a href="classhelios_1_1utils_1_1InspectAdapter.html#a7087a02ef4b60a11f90b31a1ce92767c">helios::utils::InspectAdapter::end</a></div><div class="ttdeci">constexpr InspectAdapter end() const noexcept(std::is_nothrow_constructible_v&lt; InspectAdapter, const Iter &amp;, const Iter &amp;, const Func &amp; &gt;)</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l01300">functional_adapters.hpp:1300</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1InspectAdapter_html_a77d3e6165593316f165552f4f74354d8"><div class="ttname"><a href="classhelios_1_1utils_1_1InspectAdapter.html#a77d3e6165593316f165552f4f74354d8">helios::utils::InspectAdapter::pointer</a></div><div class="ttdeci">value_type * pointer</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l01253">functional_adapters.hpp:1253</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1InspectAdapter_html_a90f64f4bfd762eb8bdaf94b7a2658a27"><div class="ttname"><a href="classhelios_1_1utils_1_1InspectAdapter.html#a90f64f4bfd762eb8bdaf94b7a2658a27">helios::utils::InspectAdapter::operator!=</a></div><div class="ttdeci">constexpr bool operator!=(const InspectAdapter &amp;other) const noexcept(noexcept(std::declval&lt; const InspectAdapter &amp; &gt;()==std::declval&lt; const InspectAdapter &amp; &gt;()))</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l01291">functional_adapters.hpp:1291</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1InspectAdapter_html_a945525276e52e672cdfc85ee98014f6c"><div class="ttname"><a href="classhelios_1_1utils_1_1InspectAdapter.html#a945525276e52e672cdfc85ee98014f6c">helios::utils::InspectAdapter::~InspectAdapter</a></div><div class="ttdeci">constexpr ~InspectAdapter() noexcept(std::is_nothrow_destructible_v&lt; Iter &gt; &amp;&amp;std::is_nothrow_destructible_v&lt; Func &gt;)=default</div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1InspectAdapter_html_ab9a7262706dad466c518f090440aebc0"><div class="ttname"><a href="classhelios_1_1utils_1_1InspectAdapter.html#ab9a7262706dad466c518f090440aebc0">helios::utils::InspectAdapter::difference_type</a></div><div class="ttdeci">std::iter_difference_t&lt; Iter &gt; difference_type</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l01252">functional_adapters.hpp:1252</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1InspectAdapter_html_ac2e8c5cf50b4402995f52e533e7ccdde"><div class="ttname"><a href="classhelios_1_1utils_1_1InspectAdapter.html#ac2e8c5cf50b4402995f52e533e7ccdde">helios::utils::InspectAdapter::value_type</a></div><div class="ttdeci">std::iter_value_t&lt; Iter &gt; value_type</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l01251">functional_adapters.hpp:1251</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1InspectAdapter_html_afb60b0c286c6374aeeb58c6370984909"><div class="ttname"><a href="classhelios_1_1utils_1_1InspectAdapter.html#afb60b0c286c6374aeeb58c6370984909">helios::utils::InspectAdapter::iterator_category</a></div><div class="ttdeci">std::forward_iterator_tag iterator_category</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l01250">functional_adapters.hpp:1250</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1MapAdapter_html_a138856a68fc6ad3fbcc4948498841033"><div class="ttname"><a href="classhelios_1_1utils_1_1MapAdapter.html#a138856a68fc6ad3fbcc4948498841033">helios::utils::MapAdapter::reference</a></div><div class="ttdeci">value_type reference</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l00537">functional_adapters.hpp:537</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1MapAdapter_html_a14e07d6291a03d265feed573a0e37195"><div class="ttname"><a href="classhelios_1_1utils_1_1MapAdapter.html#a14e07d6291a03d265feed573a0e37195">helios::utils::MapAdapter::operator*</a></div><div class="ttdeci">constexpr value_type operator*() const noexcept(std::is_nothrow_invocable_v&lt; Func, std::iter_value_t&lt; Iter &gt; &gt; &amp;&amp;noexcept(*std::declval&lt; const Iter &amp; &gt;()))</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l00611">functional_adapters.hpp:611</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1MapAdapter_html_a1f5443be56805c1bad325498f1652ca9"><div class="ttname"><a href="classhelios_1_1utils_1_1MapAdapter.html#a1f5443be56805c1bad325498f1652ca9">helios::utils::MapAdapter::end</a></div><div class="ttdeci">constexpr MapAdapter end() const noexcept(std::is_nothrow_constructible_v&lt; MapAdapter, const Iter &amp;, const Iter &amp;, const Func &amp; &gt;)</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l00581">functional_adapters.hpp:581</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1MapAdapter_html_a30fa6004e7156e76a480f1838a64b654"><div class="ttname"><a href="classhelios_1_1utils_1_1MapAdapter.html#a30fa6004e7156e76a480f1838a64b654">helios::utils::MapAdapter::operator++</a></div><div class="ttdeci">constexpr MapAdapter &amp; operator++() noexcept(noexcept(++std::declval&lt; Iter &amp; &gt;()))</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l00595">functional_adapters.hpp:595</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1MapAdapter_html_a3e1690022a688d934207a0621259882b"><div class="ttname"><a href="classhelios_1_1utils_1_1MapAdapter.html#a3e1690022a688d934207a0621259882b">helios::utils::MapAdapter::~MapAdapter</a></div><div class="ttdeci">constexpr ~MapAdapter() noexcept(std::is_nothrow_destructible_v&lt; Iter &gt; &amp;&amp;std::is_nothrow_destructible_v&lt; Func &gt;)=default</div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1MapAdapter_html_a626fe4c1b58cc2482e19a5a2d2b95911"><div class="ttname"><a href="classhelios_1_1utils_1_1MapAdapter.html#a626fe4c1b58cc2482e19a5a2d2b95911">helios::utils::MapAdapter::begin</a></div><div class="ttdeci">constexpr MapAdapter begin() const noexcept(std::is_nothrow_copy_constructible_v&lt; MapAdapter &gt;)</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l00577">functional_adapters.hpp:577</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1MapAdapter_html_a67a6df9cf2b25ec20e8001b103ef34e2"><div class="ttname"><a href="classhelios_1_1utils_1_1MapAdapter.html#a67a6df9cf2b25ec20e8001b103ef34e2">helios::utils::MapAdapter::operator!=</a></div><div class="ttdeci">constexpr bool operator!=(const MapAdapter &amp;other) const noexcept(noexcept(std::declval&lt; const MapAdapter &amp; &gt;()==std::declval&lt; const MapAdapter &amp; &gt;()))</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l00572">functional_adapters.hpp:572</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1MapAdapter_html_a732a2342d90afa1725e96224c0c30cbe"><div class="ttname"><a href="classhelios_1_1utils_1_1MapAdapter.html#a732a2342d90afa1725e96224c0c30cbe">helios::utils::MapAdapter::operator==</a></div><div class="ttdeci">constexpr bool operator==(const MapAdapter &amp;other) const noexcept(noexcept(std::declval&lt; const Iter &amp; &gt;()==std::declval&lt; const Iter &amp; &gt;()))</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l00568">functional_adapters.hpp:568</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1MapAdapter_html_a7cff97a9de96a084130ed24af4409319"><div class="ttname"><a href="classhelios_1_1utils_1_1MapAdapter.html#a7cff97a9de96a084130ed24af4409319">helios::utils::MapAdapter::operator=</a></div><div class="ttdeci">constexpr MapAdapter &amp; operator=(const MapAdapter &amp;) noexcept(std::is_nothrow_copy_assignable_v&lt; Iter &gt; &amp;&amp;std::is_nothrow_copy_assignable_v&lt; Func &gt;)=default</div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1MapAdapter_html_a8b6a697c96b90e78444f46417a64edaa"><div class="ttname"><a href="classhelios_1_1utils_1_1MapAdapter.html#a8b6a697c96b90e78444f46417a64edaa">helios::utils::MapAdapter::difference_type</a></div><div class="ttdeci">std::iter_difference_t&lt; Iter &gt; difference_type</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l00535">functional_adapters.hpp:535</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1MapAdapter_html_a902bc56c6b4352aaee4e9d5ff954b816"><div class="ttname"><a href="classhelios_1_1utils_1_1MapAdapter.html#a902bc56c6b4352aaee4e9d5ff954b816">helios::utils::MapAdapter::iterator_category</a></div><div class="ttdeci">std::forward_iterator_tag iterator_category</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l00533">functional_adapters.hpp:533</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1MapAdapter_html_ab17cd7399d90ea2d3f551daf2b58faac"><div class="ttname"><a href="classhelios_1_1utils_1_1MapAdapter.html#ab17cd7399d90ea2d3f551daf2b58faac">helios::utils::MapAdapter::pointer</a></div><div class="ttdeci">value_type * pointer</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l00536">functional_adapters.hpp:536</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1MapAdapter_html_ac79ca7706b38dbd56f55820f630f1fef"><div class="ttname"><a href="classhelios_1_1utils_1_1MapAdapter.html#ac79ca7706b38dbd56f55820f630f1fef">helios::utils::MapAdapter::value_type</a></div><div class="ttdeci">typename DeduceValueType&lt; std::iter_value_t&lt; Iter &gt; &gt;::Type value_type</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l00534">functional_adapters.hpp:534</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1ReverseAdapter_html_a0016a78e71908e23969dad3bd1cbad35"><div class="ttname"><a href="classhelios_1_1utils_1_1ReverseAdapter.html#a0016a78e71908e23969dad3bd1cbad35">helios::utils::ReverseAdapter::pointer</a></div><div class="ttdeci">value_type * pointer</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l01607">functional_adapters.hpp:1607</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1ReverseAdapter_html_a0069640d5679ee7c4b060958ff4569b9"><div class="ttname"><a href="classhelios_1_1utils_1_1ReverseAdapter.html#a0069640d5679ee7c4b060958ff4569b9">helios::utils::ReverseAdapter::ReverseAdapter</a></div><div class="ttdeci">constexpr ReverseAdapter(Iter begin, Iter end) noexcept(std::is_nothrow_move_constructible_v&lt; Iter &gt; &amp;&amp;std::is_nothrow_copy_constructible_v&lt; Iter &gt; &amp;&amp;noexcept(std::declval&lt; Iter &amp; &gt;()==std::declval&lt; Iter &amp; &gt;()) &amp;&amp;noexcept(--std::declval&lt; Iter &amp; &gt;()))</div><div class="ttdoc">Constructs a reverse adapter.</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l01662">functional_adapters.hpp:1662</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1ReverseAdapter_html_a0a3d06fab6819e6cabed1ab7d12b64d1"><div class="ttname"><a href="classhelios_1_1utils_1_1ReverseAdapter.html#a0a3d06fab6819e6cabed1ab7d12b64d1">helios::utils::ReverseAdapter::iterator_category</a></div><div class="ttdeci">std::bidirectional_iterator_tag iterator_category</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l01604">functional_adapters.hpp:1604</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1ReverseAdapter_html_a1d48b20946337845a42b070e83d5ff9f"><div class="ttname"><a href="classhelios_1_1utils_1_1ReverseAdapter.html#a1d48b20946337845a42b070e83d5ff9f">helios::utils::ReverseAdapter::operator*</a></div><div class="ttdeci">constexpr value_type operator*() const noexcept(noexcept(*std::declval&lt; const Iter &amp; &gt;()))</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l01638">functional_adapters.hpp:1638</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1ReverseAdapter_html_a1d9dbd4e44312d4efe16924b844d8d69"><div class="ttname"><a href="classhelios_1_1utils_1_1ReverseAdapter.html#a1d9dbd4e44312d4efe16924b844d8d69">helios::utils::ReverseAdapter::value_type</a></div><div class="ttdeci">std::iter_value_t&lt; Iter &gt; value_type</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l01605">functional_adapters.hpp:1605</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1ReverseAdapter_html_a1f4898e6dc036cc99f329aa9827ada92"><div class="ttname"><a href="classhelios_1_1utils_1_1ReverseAdapter.html#a1f4898e6dc036cc99f329aa9827ada92">helios::utils::ReverseAdapter::difference_type</a></div><div class="ttdeci">std::iter_difference_t&lt; Iter &gt; difference_type</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l01606">functional_adapters.hpp:1606</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1ReverseAdapter_html_a332259986bc53236f836c8e5a2815895"><div class="ttname"><a href="classhelios_1_1utils_1_1ReverseAdapter.html#a332259986bc53236f836c8e5a2815895">helios::utils::ReverseAdapter::~ReverseAdapter</a></div><div class="ttdeci">constexpr ~ReverseAdapter() noexcept(std::is_nothrow_destructible_v&lt; Iter &gt;)=default</div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1ReverseAdapter_html_a33e10fd7dd3463f8f56d3cc1f5e60b84"><div class="ttname"><a href="classhelios_1_1utils_1_1ReverseAdapter.html#a33e10fd7dd3463f8f56d3cc1f5e60b84">helios::utils::ReverseAdapter::operator=</a></div><div class="ttdeci">constexpr ReverseAdapter &amp; operator=(const ReverseAdapter &amp;) noexcept(std::is_nothrow_copy_assignable_v&lt; Iter &gt;)=default</div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1ReverseAdapter_html_a4d3cbce219d27af71b91791f425a8150"><div class="ttname"><a href="classhelios_1_1utils_1_1ReverseAdapter.html#a4d3cbce219d27af71b91791f425a8150">helios::utils::ReverseAdapter::end</a></div><div class="ttdeci">constexpr ReverseAdapter end() const noexcept(std::is_nothrow_copy_constructible_v&lt; ReverseAdapter &gt;)</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l01734">functional_adapters.hpp:1734</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1ReverseAdapter_html_a4f0c20587413122ef5dc052daffbd951"><div class="ttname"><a href="classhelios_1_1utils_1_1ReverseAdapter.html#a4f0c20587413122ef5dc052daffbd951">helios::utils::ReverseAdapter::operator--</a></div><div class="ttdeci">constexpr ReverseAdapter &amp; operator--() noexcept(std::is_nothrow_copy_constructible_v&lt; Iter &gt; &amp;&amp;noexcept(++std::declval&lt; Iter &amp; &gt;()) &amp;&amp;noexcept(std::declval&lt; Iter &amp; &gt;() !=std::declval&lt; Iter &amp; &gt;()))</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l01697">functional_adapters.hpp:1697</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1ReverseAdapter_html_a5d7c9ff067c6e550836d27aa49ab821b"><div class="ttname"><a href="classhelios_1_1utils_1_1ReverseAdapter.html#a5d7c9ff067c6e550836d27aa49ab821b">helios::utils::ReverseAdapter::operator++</a></div><div class="ttdeci">constexpr ReverseAdapter &amp; operator++() noexcept(noexcept(std::declval&lt; Iter &amp; &gt;()==std::declval&lt; Iter &amp; &gt;()) &amp;&amp;noexcept(--std::declval&lt; Iter &amp; &gt;()))</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l01673">functional_adapters.hpp:1673</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1ReverseAdapter_html_a687dad1f29e1f36aebdf922b3b897d2f"><div class="ttname"><a href="classhelios_1_1utils_1_1ReverseAdapter.html#a687dad1f29e1f36aebdf922b3b897d2f">helios::utils::ReverseAdapter::begin</a></div><div class="ttdeci">constexpr ReverseAdapter begin() const noexcept(std::is_nothrow_copy_constructible_v&lt; ReverseAdapter &gt;)</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l01647">functional_adapters.hpp:1647</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1ReverseAdapter_html_a75016224852787fd29203a5d6254a14d"><div class="ttname"><a href="classhelios_1_1utils_1_1ReverseAdapter.html#a75016224852787fd29203a5d6254a14d">helios::utils::ReverseAdapter::operator==</a></div><div class="ttdeci">constexpr bool operator==(const ReverseAdapter &amp;other) const noexcept(noexcept(std::declval&lt; const Iter &amp; &gt;()==std::declval&lt; const Iter &amp; &gt;()))</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l01724">functional_adapters.hpp:1724</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1ReverseAdapter_html_a964fd09ecfa6872fa8fbc357a0c31b12"><div class="ttname"><a href="classhelios_1_1utils_1_1ReverseAdapter.html#a964fd09ecfa6872fa8fbc357a0c31b12">helios::utils::ReverseAdapter::operator!=</a></div><div class="ttdeci">constexpr bool operator!=(const ReverseAdapter &amp;other) const noexcept(noexcept(std::declval&lt; ReverseAdapter &gt;()==std::declval&lt; ReverseAdapter &gt;()))</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l01642">functional_adapters.hpp:1642</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1ReverseAdapter_html_acb920920722e8f59de1595671ad11c3d"><div class="ttname"><a href="classhelios_1_1utils_1_1ReverseAdapter.html#acb920920722e8f59de1595671ad11c3d">helios::utils::ReverseAdapter::reference</a></div><div class="ttdeci">value_type reference</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l01608">functional_adapters.hpp:1608</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1SkipAdapter_html_a138e1ea5882b9fba027351de4c636f05"><div class="ttname"><a href="classhelios_1_1utils_1_1SkipAdapter.html#a138e1ea5882b9fba027351de4c636f05">helios::utils::SkipAdapter::pointer</a></div><div class="ttdeci">value_type * pointer</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l00766">functional_adapters.hpp:766</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1SkipAdapter_html_a269254f65f371b48cf8d0b56d11624d3"><div class="ttname"><a href="classhelios_1_1utils_1_1SkipAdapter.html#a269254f65f371b48cf8d0b56d11624d3">helios::utils::SkipAdapter::operator++</a></div><div class="ttdeci">constexpr SkipAdapter &amp; operator++() noexcept(noexcept(++std::declval&lt; Iter &amp; &gt;()))</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l00830">functional_adapters.hpp:830</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1SkipAdapter_html_a285c7658b49122aa7ef1aafa9e45c12f"><div class="ttname"><a href="classhelios_1_1utils_1_1SkipAdapter.html#a285c7658b49122aa7ef1aafa9e45c12f">helios::utils::SkipAdapter::operator*</a></div><div class="ttdeci">constexpr value_type operator*() const noexcept(noexcept(*std::declval&lt; const Iter &amp; &gt;()))</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l00789">functional_adapters.hpp:789</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1SkipAdapter_html_a2e87e6ceef39a694bbb2b85220a189b6"><div class="ttname"><a href="classhelios_1_1utils_1_1SkipAdapter.html#a2e87e6ceef39a694bbb2b85220a189b6">helios::utils::SkipAdapter::reference</a></div><div class="ttdeci">value_type reference</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l00767">functional_adapters.hpp:767</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1SkipAdapter_html_a44f2f2d4f79d2bff8ddfb364e45389e9"><div class="ttname"><a href="classhelios_1_1utils_1_1SkipAdapter.html#a44f2f2d4f79d2bff8ddfb364e45389e9">helios::utils::SkipAdapter::value_type</a></div><div class="ttdeci">std::iter_value_t&lt; Iter &gt; value_type</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l00764">functional_adapters.hpp:764</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1SkipAdapter_html_a643008a71385ef5915f973fae16993db"><div class="ttname"><a href="classhelios_1_1utils_1_1SkipAdapter.html#a643008a71385ef5915f973fae16993db">helios::utils::SkipAdapter::~SkipAdapter</a></div><div class="ttdeci">constexpr ~SkipAdapter() noexcept(std::is_nothrow_destructible_v&lt; Iter &gt;)=default</div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1SkipAdapter_html_a73fd6df2a9a8962ec26660faf30cffa5"><div class="ttname"><a href="classhelios_1_1utils_1_1SkipAdapter.html#a73fd6df2a9a8962ec26660faf30cffa5">helios::utils::SkipAdapter::end</a></div><div class="ttdeci">constexpr SkipAdapter end() const noexcept(std::is_nothrow_constructible_v&lt; SkipAdapter, const Iter &amp;, const Iter &amp;, size_t &gt;)</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l00807">functional_adapters.hpp:807</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1SkipAdapter_html_a8ed6a07d0fac605701381ad6bb17a015"><div class="ttname"><a href="classhelios_1_1utils_1_1SkipAdapter.html#a8ed6a07d0fac605701381ad6bb17a015">helios::utils::SkipAdapter::operator=</a></div><div class="ttdeci">constexpr SkipAdapter &amp; operator=(const SkipAdapter &amp;) noexcept(std::is_nothrow_copy_assignable_v&lt; Iter &gt;)=default</div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1SkipAdapter_html_aa058c013be0f7859c9bd222069ff3822"><div class="ttname"><a href="classhelios_1_1utils_1_1SkipAdapter.html#aa058c013be0f7859c9bd222069ff3822">helios::utils::SkipAdapter::SkipAdapter</a></div><div class="ttdeci">constexpr SkipAdapter(Iter begin, Iter end, size_t count) noexcept(std::is_nothrow_move_constructible_v&lt; Iter &gt; &amp;&amp;noexcept(++std::declval&lt; Iter &amp; &gt;()))</div><div class="ttdoc">Constructs a skip adapter with the given iterator range and count.</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l00819">functional_adapters.hpp:819</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1SkipAdapter_html_ab34f9f96cfbcc6a1e7ac8e5afb7c9c28"><div class="ttname"><a href="classhelios_1_1utils_1_1SkipAdapter.html#ab34f9f96cfbcc6a1e7ac8e5afb7c9c28">helios::utils::SkipAdapter::begin</a></div><div class="ttdeci">constexpr SkipAdapter begin() const noexcept(std::is_nothrow_copy_constructible_v&lt; SkipAdapter &gt;)</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l00803">functional_adapters.hpp:803</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1SkipAdapter_html_ac46529f22b76314fff13f085845d935f"><div class="ttname"><a href="classhelios_1_1utils_1_1SkipAdapter.html#ac46529f22b76314fff13f085845d935f">helios::utils::SkipAdapter::difference_type</a></div><div class="ttdeci">std::iter_difference_t&lt; Iter &gt; difference_type</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l00765">functional_adapters.hpp:765</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1SkipAdapter_html_ac87ad9b75c3ebb745664b4c4905ef948"><div class="ttname"><a href="classhelios_1_1utils_1_1SkipAdapter.html#ac87ad9b75c3ebb745664b4c4905ef948">helios::utils::SkipAdapter::operator==</a></div><div class="ttdeci">constexpr bool operator==(const SkipAdapter &amp;other) const noexcept(noexcept(std::declval&lt; const Iter &amp; &gt;()==std::declval&lt; const Iter &amp; &gt;()))</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l00793">functional_adapters.hpp:793</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1SkipAdapter_html_ae172b0dd64fcd7d224d19de0d7cae77e"><div class="ttname"><a href="classhelios_1_1utils_1_1SkipAdapter.html#ae172b0dd64fcd7d224d19de0d7cae77e">helios::utils::SkipAdapter::iterator_category</a></div><div class="ttdeci">std::forward_iterator_tag iterator_category</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l00763">functional_adapters.hpp:763</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1SkipAdapter_html_ae3ce733cca77446589bedd354036ec95"><div class="ttname"><a href="classhelios_1_1utils_1_1SkipAdapter.html#ae3ce733cca77446589bedd354036ec95">helios::utils::SkipAdapter::operator!=</a></div><div class="ttdeci">constexpr bool operator!=(const SkipAdapter &amp;other) const noexcept(noexcept(std::declval&lt; const SkipAdapter &amp; &gt;()==std::declval&lt; const SkipAdapter &amp; &gt;()))</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l00798">functional_adapters.hpp:798</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1SkipWhileAdapter_html_a06a7bafb13a0156164401cae005c4277"><div class="ttname"><a href="classhelios_1_1utils_1_1SkipWhileAdapter.html#a06a7bafb13a0156164401cae005c4277">helios::utils::SkipWhileAdapter::end</a></div><div class="ttdeci">constexpr SkipWhileAdapter end() const noexcept(std::is_nothrow_constructible_v&lt; SkipWhileAdapter, const Iter &amp;, const Iter &amp;, const Pred &amp; &gt;)</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l01066">functional_adapters.hpp:1066</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1SkipWhileAdapter_html_a42aa7d421a494ea414f8d922cee89568"><div class="ttname"><a href="classhelios_1_1utils_1_1SkipWhileAdapter.html#a42aa7d421a494ea414f8d922cee89568">helios::utils::SkipWhileAdapter::operator*</a></div><div class="ttdeci">constexpr value_type operator*() const noexcept(noexcept(*std::declval&lt; const Iter &amp; &gt;()))</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l01047">functional_adapters.hpp:1047</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1SkipWhileAdapter_html_a445c0e1caab67bab56ef610887480c3e"><div class="ttname"><a href="classhelios_1_1utils_1_1SkipWhileAdapter.html#a445c0e1caab67bab56ef610887480c3e">helios::utils::SkipWhileAdapter::operator!=</a></div><div class="ttdeci">constexpr bool operator!=(const SkipWhileAdapter &amp;other) const noexcept(noexcept(std::declval&lt; const SkipWhileAdapter &amp; &gt;()==std::declval&lt; const SkipWhileAdapter &amp; &gt;()))</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l01056">functional_adapters.hpp:1056</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1SkipWhileAdapter_html_a557f57bff7409e2b4415975b6a42d879"><div class="ttname"><a href="classhelios_1_1utils_1_1SkipWhileAdapter.html#a557f57bff7409e2b4415975b6a42d879">helios::utils::SkipWhileAdapter::difference_type</a></div><div class="ttdeci">std::iter_difference_t&lt; Iter &gt; difference_type</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l01013">functional_adapters.hpp:1013</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1SkipWhileAdapter_html_a7884b85eef41352e00f6a42425dfd103"><div class="ttname"><a href="classhelios_1_1utils_1_1SkipWhileAdapter.html#a7884b85eef41352e00f6a42425dfd103">helios::utils::SkipWhileAdapter::operator=</a></div><div class="ttdeci">constexpr SkipWhileAdapter &amp; operator=(const SkipWhileAdapter &amp;) noexcept(std::is_nothrow_copy_assignable_v&lt; Iter &gt; &amp;&amp;std::is_nothrow_copy_assignable_v&lt; Pred &gt;)=default</div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1SkipWhileAdapter_html_a91021023f5ee3478bd677178b96da470"><div class="ttname"><a href="classhelios_1_1utils_1_1SkipWhileAdapter.html#a91021023f5ee3478bd677178b96da470">helios::utils::SkipWhileAdapter::pointer</a></div><div class="ttdeci">value_type * pointer</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l01014">functional_adapters.hpp:1014</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1SkipWhileAdapter_html_a96d7d4196af334af0cdbf1f5796b72fa"><div class="ttname"><a href="classhelios_1_1utils_1_1SkipWhileAdapter.html#a96d7d4196af334af0cdbf1f5796b72fa">helios::utils::SkipWhileAdapter::reference</a></div><div class="ttdeci">value_type reference</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l01015">functional_adapters.hpp:1015</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1SkipWhileAdapter_html_a9c2e3071137f7aa9e7d066bcf137b5b1"><div class="ttname"><a href="classhelios_1_1utils_1_1SkipWhileAdapter.html#a9c2e3071137f7aa9e7d066bcf137b5b1">helios::utils::SkipWhileAdapter::value_type</a></div><div class="ttdeci">std::iter_value_t&lt; Iter &gt; value_type</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l01012">functional_adapters.hpp:1012</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1SkipWhileAdapter_html_aa7af918bc5a68eabb94bb11abe3417d7"><div class="ttname"><a href="classhelios_1_1utils_1_1SkipWhileAdapter.html#aa7af918bc5a68eabb94bb11abe3417d7">helios::utils::SkipWhileAdapter::~SkipWhileAdapter</a></div><div class="ttdeci">constexpr ~SkipWhileAdapter() noexcept(std::is_nothrow_destructible_v&lt; Iter &gt; &amp;&amp;std::is_nothrow_destructible_v&lt; Pred &gt;)=default</div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1SkipWhileAdapter_html_aa9575367326e9995ad8301848ed94393"><div class="ttname"><a href="classhelios_1_1utils_1_1SkipWhileAdapter.html#aa9575367326e9995ad8301848ed94393">helios::utils::SkipWhileAdapter::operator==</a></div><div class="ttdeci">constexpr bool operator==(const SkipWhileAdapter &amp;other) const noexcept(noexcept(std::declval&lt; const Iter &amp; &gt;()==std::declval&lt; const Iter &amp; &gt;()))</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l01051">functional_adapters.hpp:1051</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1SkipWhileAdapter_html_ac9075f0e4679f71f7619b6fa0c198b8b"><div class="ttname"><a href="classhelios_1_1utils_1_1SkipWhileAdapter.html#ac9075f0e4679f71f7619b6fa0c198b8b">helios::utils::SkipWhileAdapter::iterator_category</a></div><div class="ttdeci">std::forward_iterator_tag iterator_category</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l01011">functional_adapters.hpp:1011</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1SkipWhileAdapter_html_ad72117049eb13a741ff009deebf677bc"><div class="ttname"><a href="classhelios_1_1utils_1_1SkipWhileAdapter.html#ad72117049eb13a741ff009deebf677bc">helios::utils::SkipWhileAdapter::begin</a></div><div class="ttdeci">constexpr SkipWhileAdapter begin() const noexcept(std::is_nothrow_copy_constructible_v&lt; SkipWhileAdapter &gt;)</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l01061">functional_adapters.hpp:1061</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1SkipWhileAdapter_html_afe975de8f99b2c83faa882204baaa284"><div class="ttname"><a href="classhelios_1_1utils_1_1SkipWhileAdapter.html#afe975de8f99b2c83faa882204baaa284">helios::utils::SkipWhileAdapter::operator++</a></div><div class="ttdeci">constexpr SkipWhileAdapter &amp; operator++() noexcept(noexcept(++std::declval&lt; Iter &amp; &gt;()))</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l01083">functional_adapters.hpp:1083</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1StepByAdapter_html_a0c35edb3fca6216c08eeb99b1a068876"><div class="ttname"><a href="classhelios_1_1utils_1_1StepByAdapter.html#a0c35edb3fca6216c08eeb99b1a068876">helios::utils::StepByAdapter::value_type</a></div><div class="ttdeci">std::iter_value_t&lt; Iter &gt; value_type</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l01359">functional_adapters.hpp:1359</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1StepByAdapter_html_a0d5260abeef230695f5c6a5f7a8f2523"><div class="ttname"><a href="classhelios_1_1utils_1_1StepByAdapter.html#a0d5260abeef230695f5c6a5f7a8f2523">helios::utils::StepByAdapter::operator=</a></div><div class="ttdeci">constexpr StepByAdapter &amp; operator=(const StepByAdapter &amp;)=default</div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1StepByAdapter_html_a280022b7a9f029976141cc621e631e09"><div class="ttname"><a href="classhelios_1_1utils_1_1StepByAdapter.html#a280022b7a9f029976141cc621e631e09">helios::utils::StepByAdapter::end</a></div><div class="ttdeci">constexpr StepByAdapter end() const noexcept(std::is_nothrow_constructible_v&lt; StepByAdapter, const Iter &amp;, const Iter &amp;, size_t &gt;)</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l01404">functional_adapters.hpp:1404</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1StepByAdapter_html_a2c57a44b9580db53d8781e80b29cf140"><div class="ttname"><a href="classhelios_1_1utils_1_1StepByAdapter.html#a2c57a44b9580db53d8781e80b29cf140">helios::utils::StepByAdapter::iterator_category</a></div><div class="ttdeci">std::forward_iterator_tag iterator_category</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l01358">functional_adapters.hpp:1358</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1StepByAdapter_html_a5d1e1da59bbbe151d45583014a8a5daf"><div class="ttname"><a href="classhelios_1_1utils_1_1StepByAdapter.html#a5d1e1da59bbbe151d45583014a8a5daf">helios::utils::StepByAdapter::begin</a></div><div class="ttdeci">constexpr StepByAdapter begin() const noexcept(std::is_nothrow_copy_constructible_v&lt; StepByAdapter &gt;)</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l01400">functional_adapters.hpp:1400</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1StepByAdapter_html_a7584283d36578b8585e43185952022e8"><div class="ttname"><a href="classhelios_1_1utils_1_1StepByAdapter.html#a7584283d36578b8585e43185952022e8">helios::utils::StepByAdapter::reference</a></div><div class="ttdeci">value_type reference</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l01362">functional_adapters.hpp:1362</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1StepByAdapter_html_a7ad930037fb9e06f61f0d11a61f55af2"><div class="ttname"><a href="classhelios_1_1utils_1_1StepByAdapter.html#a7ad930037fb9e06f61f0d11a61f55af2">helios::utils::StepByAdapter::difference_type</a></div><div class="ttdeci">std::iter_difference_t&lt; Iter &gt; difference_type</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l01360">functional_adapters.hpp:1360</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1StepByAdapter_html_a94f07ac09560a41f3a02be114656dc7d"><div class="ttname"><a href="classhelios_1_1utils_1_1StepByAdapter.html#a94f07ac09560a41f3a02be114656dc7d">helios::utils::StepByAdapter::operator*</a></div><div class="ttdeci">constexpr value_type operator*() const noexcept(noexcept(*std::declval&lt; const Iter &amp; &gt;()))</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l01386">functional_adapters.hpp:1386</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1StepByAdapter_html_ab460ec5dbf307afa7eb3e852d0875c07"><div class="ttname"><a href="classhelios_1_1utils_1_1StepByAdapter.html#ab460ec5dbf307afa7eb3e852d0875c07">helios::utils::StepByAdapter::operator++</a></div><div class="ttdeci">constexpr StepByAdapter &amp; operator++() noexcept(noexcept(++std::declval&lt; Iter &amp; &gt;()) &amp;&amp;noexcept(std::declval&lt; Iter &amp; &gt;() !=std::declval&lt; Iter &amp; &gt;()))</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l01418">functional_adapters.hpp:1418</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1StepByAdapter_html_aca44769bb25741b6315391b752ec3fb7"><div class="ttname"><a href="classhelios_1_1utils_1_1StepByAdapter.html#aca44769bb25741b6315391b752ec3fb7">helios::utils::StepByAdapter::operator!=</a></div><div class="ttdeci">constexpr bool operator!=(const StepByAdapter &amp;other) const noexcept(noexcept(std::declval&lt; const StepByAdapter &amp; &gt;()==std::declval&lt; const StepByAdapter &amp; &gt;()))</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l01395">functional_adapters.hpp:1395</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1StepByAdapter_html_af85d16a5d072663b7942c9c3337abbfd"><div class="ttname"><a href="classhelios_1_1utils_1_1StepByAdapter.html#af85d16a5d072663b7942c9c3337abbfd">helios::utils::StepByAdapter::~StepByAdapter</a></div><div class="ttdeci">constexpr ~StepByAdapter()=default</div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1StepByAdapter_html_afa99cb6da3a1af2bd1dd5781ced00553"><div class="ttname"><a href="classhelios_1_1utils_1_1StepByAdapter.html#afa99cb6da3a1af2bd1dd5781ced00553">helios::utils::StepByAdapter::operator==</a></div><div class="ttdeci">constexpr bool operator==(const StepByAdapter &amp;other) const noexcept(noexcept(std::declval&lt; const Iter &amp; &gt;()==std::declval&lt; const Iter &amp; &gt;()))</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l01390">functional_adapters.hpp:1390</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1StepByAdapter_html_afe462dbe164cb85bfcb7181b31c2b3f1"><div class="ttname"><a href="classhelios_1_1utils_1_1StepByAdapter.html#afe462dbe164cb85bfcb7181b31c2b3f1">helios::utils::StepByAdapter::pointer</a></div><div class="ttdeci">value_type * pointer</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l01361">functional_adapters.hpp:1361</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1TakeAdapter_html_a10bdc858f5fbed1bfdc6155e2ed5717d"><div class="ttname"><a href="classhelios_1_1utils_1_1TakeAdapter.html#a10bdc858f5fbed1bfdc6155e2ed5717d">helios::utils::TakeAdapter::operator!=</a></div><div class="ttdeci">constexpr bool operator!=(const TakeAdapter &amp;other) const noexcept(noexcept(std::declval&lt; const TakeAdapter &amp; &gt;()==std::declval&lt; const TakeAdapter &amp; &gt;()))</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l00674">functional_adapters.hpp:674</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1TakeAdapter_html_a21eb39cf813e5380baffc34d95a68f24"><div class="ttname"><a href="classhelios_1_1utils_1_1TakeAdapter.html#a21eb39cf813e5380baffc34d95a68f24">helios::utils::TakeAdapter::operator++</a></div><div class="ttdeci">constexpr TakeAdapter &amp; operator++() noexcept(noexcept(++std::declval&lt; Iter &amp; &gt;()))</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l00704">functional_adapters.hpp:704</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1TakeAdapter_html_a259b7d121fa995c6a1ce54fadd39c488"><div class="ttname"><a href="classhelios_1_1utils_1_1TakeAdapter.html#a259b7d121fa995c6a1ce54fadd39c488">helios::utils::TakeAdapter::difference_type</a></div><div class="ttdeci">std::iter_difference_t&lt; Iter &gt; difference_type</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l00642">functional_adapters.hpp:642</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1TakeAdapter_html_a2def5bf84c73cb4fe6ff910ef393f20f"><div class="ttname"><a href="classhelios_1_1utils_1_1TakeAdapter.html#a2def5bf84c73cb4fe6ff910ef393f20f">helios::utils::TakeAdapter::value_type</a></div><div class="ttdeci">std::iter_value_t&lt; Iter &gt; value_type</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l00641">functional_adapters.hpp:641</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1TakeAdapter_html_a471e5397abd6fcb37fb1634475106152"><div class="ttname"><a href="classhelios_1_1utils_1_1TakeAdapter.html#a471e5397abd6fcb37fb1634475106152">helios::utils::TakeAdapter::operator*</a></div><div class="ttdeci">constexpr value_type operator*() const noexcept(noexcept(*std::declval&lt; const Iter &amp; &gt;()))</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l00667">functional_adapters.hpp:667</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1TakeAdapter_html_a7536a20b6a91dfc45c4154f0b82c374b"><div class="ttname"><a href="classhelios_1_1utils_1_1TakeAdapter.html#a7536a20b6a91dfc45c4154f0b82c374b">helios::utils::TakeAdapter::end</a></div><div class="ttdeci">constexpr TakeAdapter end() const noexcept(std::is_nothrow_copy_constructible_v&lt; TakeAdapter &gt;)</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l00738">functional_adapters.hpp:738</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1TakeAdapter_html_a7d8245219a622977cf77fac7923e3f2e"><div class="ttname"><a href="classhelios_1_1utils_1_1TakeAdapter.html#a7d8245219a622977cf77fac7923e3f2e">helios::utils::TakeAdapter::begin</a></div><div class="ttdeci">constexpr TakeAdapter begin() const noexcept(std::is_nothrow_copy_constructible_v&lt; TakeAdapter &gt;)</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l00688">functional_adapters.hpp:688</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1TakeAdapter_html_a98fd7e9836ede878cff095dc020868de"><div class="ttname"><a href="classhelios_1_1utils_1_1TakeAdapter.html#a98fd7e9836ede878cff095dc020868de">helios::utils::TakeAdapter::pointer</a></div><div class="ttdeci">value_type * pointer</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l00643">functional_adapters.hpp:643</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1TakeAdapter_html_aae3e2882dea3f84a3763e6232e582798"><div class="ttname"><a href="classhelios_1_1utils_1_1TakeAdapter.html#aae3e2882dea3f84a3763e6232e582798">helios::utils::TakeAdapter::reference</a></div><div class="ttdeci">value_type reference</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l00644">functional_adapters.hpp:644</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1TakeAdapter_html_ab9f032798cbd1b9eb939c0b9d30e2172"><div class="ttname"><a href="classhelios_1_1utils_1_1TakeAdapter.html#ab9f032798cbd1b9eb939c0b9d30e2172">helios::utils::TakeAdapter::operator==</a></div><div class="ttdeci">constexpr bool operator==(const TakeAdapter &amp;other) const noexcept(noexcept(std::declval&lt; const Iter &amp; &gt;()==std::declval&lt; const Iter &amp; &gt;()))</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l00723">functional_adapters.hpp:723</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1TakeAdapter_html_acda8cc32780d47afc297d2200df065a1"><div class="ttname"><a href="classhelios_1_1utils_1_1TakeAdapter.html#acda8cc32780d47afc297d2200df065a1">helios::utils::TakeAdapter::operator=</a></div><div class="ttdeci">constexpr TakeAdapter &amp; operator=(const TakeAdapter &amp;) noexcept(std::is_nothrow_copy_assignable_v&lt; Iter &gt;)=default</div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1TakeAdapter_html_ad13c1668d279b33bd91ed5f2e97bc32e"><div class="ttname"><a href="classhelios_1_1utils_1_1TakeAdapter.html#ad13c1668d279b33bd91ed5f2e97bc32e">helios::utils::TakeAdapter::iterator_category</a></div><div class="ttdeci">std::forward_iterator_tag iterator_category</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l00640">functional_adapters.hpp:640</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1TakeAdapter_html_af2f8c99e1d8d2f95eccac0a87c583702"><div class="ttname"><a href="classhelios_1_1utils_1_1TakeAdapter.html#af2f8c99e1d8d2f95eccac0a87c583702">helios::utils::TakeAdapter::~TakeAdapter</a></div><div class="ttdeci">constexpr ~TakeAdapter() noexcept(std::is_nothrow_destructible_v&lt; Iter &gt;)=default</div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1TakeAdapter_html_af5bca984b4a9d4380d6e9181b1e5ea39"><div class="ttname"><a href="classhelios_1_1utils_1_1TakeAdapter.html#af5bca984b4a9d4380d6e9181b1e5ea39">helios::utils::TakeAdapter::IsAtEnd</a></div><div class="ttdeci">constexpr bool IsAtEnd() const noexcept(noexcept(std::declval&lt; const Iter &amp; &gt;()==std::declval&lt; const Iter &amp; &gt;()))</div><div class="ttdoc">Checks if the iterator has reached the end.</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l00683">functional_adapters.hpp:683</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1TakeWhileAdapter_html_a0c0a65ae9b0920654fa77cd4bc11418f"><div class="ttname"><a href="classhelios_1_1utils_1_1TakeWhileAdapter.html#a0c0a65ae9b0920654fa77cd4bc11418f">helios::utils::TakeWhileAdapter::end</a></div><div class="ttdeci">constexpr TakeWhileAdapter end() const noexcept(std::is_nothrow_copy_constructible_v&lt; TakeWhileAdapter &gt;)</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l00967">functional_adapters.hpp:967</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1TakeWhileAdapter_html_a4536d72a493b8274958a7133f61d0c50"><div class="ttname"><a href="classhelios_1_1utils_1_1TakeWhileAdapter.html#a4536d72a493b8274958a7133f61d0c50">helios::utils::TakeWhileAdapter::operator==</a></div><div class="ttdeci">constexpr bool operator==(const TakeWhileAdapter &amp;other) const noexcept(noexcept(std::declval&lt; const Iter &amp; &gt;()==std::declval&lt; const Iter &amp; &gt;()))</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l00904">functional_adapters.hpp:904</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1TakeWhileAdapter_html_a4c3be5c86183e2f8a9261be882df4ab5"><div class="ttname"><a href="classhelios_1_1utils_1_1TakeWhileAdapter.html#a4c3be5c86183e2f8a9261be882df4ab5">helios::utils::TakeWhileAdapter::pointer</a></div><div class="ttdeci">value_type * pointer</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l00864">functional_adapters.hpp:864</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1TakeWhileAdapter_html_a516a1779b05742927fa3071a7dad9a21"><div class="ttname"><a href="classhelios_1_1utils_1_1TakeWhileAdapter.html#a516a1779b05742927fa3071a7dad9a21">helios::utils::TakeWhileAdapter::~TakeWhileAdapter</a></div><div class="ttdeci">constexpr ~TakeWhileAdapter() noexcept(std::is_nothrow_destructible_v&lt; Iter &gt; &amp;&amp;std::is_nothrow_destructible_v&lt; Pred &gt;)=default</div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1TakeWhileAdapter_html_a59749300ed13ca803c21b28ee8c10d57"><div class="ttname"><a href="classhelios_1_1utils_1_1TakeWhileAdapter.html#a59749300ed13ca803c21b28ee8c10d57">helios::utils::TakeWhileAdapter::operator*</a></div><div class="ttdeci">constexpr value_type operator*() const noexcept(noexcept(*std::declval&lt; const Iter &amp; &gt;()))</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l00900">functional_adapters.hpp:900</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1TakeWhileAdapter_html_a5e1923f3d0347b83fe115fe16f7098b0"><div class="ttname"><a href="classhelios_1_1utils_1_1TakeWhileAdapter.html#a5e1923f3d0347b83fe115fe16f7098b0">helios::utils::TakeWhileAdapter::IsAtEnd</a></div><div class="ttdeci">constexpr bool IsAtEnd() const noexcept(noexcept(std::declval&lt; const Iter &amp; &gt;()==std::declval&lt; const Iter &amp; &gt;()))</div><div class="ttdoc">Checks if the iterator has reached the end.</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l00918">functional_adapters.hpp:918</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1TakeWhileAdapter_html_a72bb354d27dd31d4838667afb174b50c"><div class="ttname"><a href="classhelios_1_1utils_1_1TakeWhileAdapter.html#a72bb354d27dd31d4838667afb174b50c">helios::utils::TakeWhileAdapter::begin</a></div><div class="ttdeci">constexpr TakeWhileAdapter begin() const noexcept(std::is_nothrow_copy_constructible_v&lt; TakeWhileAdapter &gt;)</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l00923">functional_adapters.hpp:923</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1TakeWhileAdapter_html_a836ca84d59c9078ce9b4fb770ea6b359"><div class="ttname"><a href="classhelios_1_1utils_1_1TakeWhileAdapter.html#a836ca84d59c9078ce9b4fb770ea6b359">helios::utils::TakeWhileAdapter::operator=</a></div><div class="ttdeci">constexpr TakeWhileAdapter &amp; operator=(const TakeWhileAdapter &amp;) noexcept(std::is_nothrow_copy_assignable_v&lt; Iter &gt; &amp;&amp;std::is_nothrow_copy_assignable_v&lt; Pred &gt;)=default</div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1TakeWhileAdapter_html_a8e1e8b1972638942a84eb4cdaa707f75"><div class="ttname"><a href="classhelios_1_1utils_1_1TakeWhileAdapter.html#a8e1e8b1972638942a84eb4cdaa707f75">helios::utils::TakeWhileAdapter::operator!=</a></div><div class="ttdeci">constexpr bool operator!=(const TakeWhileAdapter &amp;other) const noexcept(noexcept(std::declval&lt; const TakeWhileAdapter &amp; &gt;()==std::declval&lt; const TakeWhileAdapter &amp; &gt;()))</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l00909">functional_adapters.hpp:909</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1TakeWhileAdapter_html_a9d828eb901cfaed8714aa12b49cdac0a"><div class="ttname"><a href="classhelios_1_1utils_1_1TakeWhileAdapter.html#a9d828eb901cfaed8714aa12b49cdac0a">helios::utils::TakeWhileAdapter::value_type</a></div><div class="ttdeci">std::iter_value_t&lt; Iter &gt; value_type</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l00862">functional_adapters.hpp:862</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1TakeWhileAdapter_html_aae90d9270614a1d71af71d248f4d017d"><div class="ttname"><a href="classhelios_1_1utils_1_1TakeWhileAdapter.html#aae90d9270614a1d71af71d248f4d017d">helios::utils::TakeWhileAdapter::reference</a></div><div class="ttdeci">value_type reference</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l00865">functional_adapters.hpp:865</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1TakeWhileAdapter_html_ab3a0402aa853b20b8487fef5fe29e03d"><div class="ttname"><a href="classhelios_1_1utils_1_1TakeWhileAdapter.html#ab3a0402aa853b20b8487fef5fe29e03d">helios::utils::TakeWhileAdapter::difference_type</a></div><div class="ttdeci">std::iter_difference_t&lt; Iter &gt; difference_type</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l00863">functional_adapters.hpp:863</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1TakeWhileAdapter_html_ade9c798e00b49ed10bccc9d3963912f3"><div class="ttname"><a href="classhelios_1_1utils_1_1TakeWhileAdapter.html#ade9c798e00b49ed10bccc9d3963912f3">helios::utils::TakeWhileAdapter::operator++</a></div><div class="ttdeci">constexpr TakeWhileAdapter &amp; operator++() noexcept(noexcept(++std::declval&lt; Iter &amp; &gt;()) &amp;&amp;noexcept(std::declval&lt; Iter &amp; &gt;() !=std::declval&lt; Iter &amp; &gt;()) &amp;&amp;noexcept(CheckPredicate()))</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l00944">functional_adapters.hpp:944</a></div></div>
<div class="ttc" id="aclasshelios_1_1utils_1_1TakeWhileAdapter_html_af15d177631313af48b105eda93a0a647"><div class="ttname"><a href="classhelios_1_1utils_1_1TakeWhileAdapter.html#af15d177631313af48b105eda93a0a647">helios::utils::TakeWhileAdapter::iterator_category</a></div><div class="ttdeci">std::forward_iterator_tag iterator_category</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l00861">functional_adapters.hpp:861</a></div></div>
<div class="ttc" id="acore__pch_8hpp_html"><div class="ttname"><a href="core__pch_8hpp.html">core_pch.hpp</a></div></div>
<div class="ttc" id="afunctional__adapters_8hpp_html_a1f22bfef6bdc6c9e48c264f1ab73b94c"><div class="ttname"><a href="functional__adapters_8hpp.html#a1f22bfef6bdc6c9e48c264f1ab73b94c">ReverseAdapterFromRange</a></div><div class="ttdeci">constexpr auto ReverseAdapterFromRange(R &amp;range) noexcept(noexcept(ReverseAdapter&lt; std::ranges::iterator_t&lt; R &gt; &gt;(std::ranges::begin(range), std::ranges::end(range)))) -&gt; ReverseAdapter&lt; std::ranges::iterator_t&lt; R &gt; &gt;</div><div class="ttdoc">Helper function to create a ReverseAdapter from a range.</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l03240">functional_adapters.hpp:3240</a></div></div>
<div class="ttc" id="afunctional__adapters_8hpp_html_a22e05a1859c49e16d93d42691c556664"><div class="ttname"><a href="functional__adapters_8hpp.html#a22e05a1859c49e16d93d42691c556664">ZipAdapterFromRange</a></div><div class="ttdeci">constexpr auto ZipAdapterFromRange(R1 &amp;range1, R2 &amp;range2) noexcept(noexcept(ZipAdapter&lt; std::ranges::iterator_t&lt; R1 &gt;, std::ranges::iterator_t&lt; R2 &gt; &gt;(std::ranges::begin(range1), std::ranges::end(range1), std::ranges::begin(range2), std::ranges::end(range2)))) -&gt; ZipAdapter&lt; std::ranges::iterator_t&lt; R1 &gt;, std::ranges::iterator_t&lt; R2 &gt; &gt;</div><div class="ttdoc">Helper function to create a ZipAdapter from two ranges.</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l03359">functional_adapters.hpp:3359</a></div></div>
<div class="ttc" id="afunctional__adapters_8hpp_html_a24be1e723416c19e6b3f500653076dd9"><div class="ttname"><a href="functional__adapters_8hpp.html#a24be1e723416c19e6b3f500653076dd9">JoinAdapterFromRange</a></div><div class="ttdeci">constexpr auto JoinAdapterFromRange(R &amp;range) noexcept(noexcept(JoinAdapter&lt; std::ranges::iterator_t&lt; R &gt; &gt;(std::ranges::begin(range), std::ranges::end(range)))) -&gt; JoinAdapter&lt; std::ranges::iterator_t&lt; R &gt; &gt;</div><div class="ttdoc">Helper function to create a JoinAdapter from a range.</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l03268">functional_adapters.hpp:3268</a></div></div>
<div class="ttc" id="afunctional__adapters_8hpp_html_a26c8c7da02f4a54443fbb24411500ba2"><div class="ttname"><a href="functional__adapters_8hpp.html#a26c8c7da02f4a54443fbb24411500ba2">EnumerateAdapterFromRange</a></div><div class="ttdeci">constexpr auto EnumerateAdapterFromRange(R &amp;range) noexcept(noexcept(EnumerateAdapter&lt; std::ranges::iterator_t&lt; R &gt; &gt;(std::ranges::begin(range), std::ranges::end(range)))) -&gt; EnumerateAdapter&lt; std::ranges::iterator_t&lt; R &gt; &gt;</div><div class="ttdoc">Helper function to create an EnumerateAdapter from a non-const range.</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l03075">functional_adapters.hpp:3075</a></div></div>
<div class="ttc" id="afunctional__adapters_8hpp_html_a3f7766fbd29295bb0e1464dace44c679"><div class="ttname"><a href="functional__adapters_8hpp.html#a3f7766fbd29295bb0e1464dace44c679">SkipWhileAdapterFromRange</a></div><div class="ttdeci">constexpr auto SkipWhileAdapterFromRange(R &amp;range, Pred predicate) noexcept(noexcept(SkipWhileAdapter&lt; std::ranges::iterator_t&lt; R &gt;, Pred &gt;(std::ranges::begin(range), std::ranges::end(range), std::move(predicate)))) -&gt; SkipWhileAdapter&lt; std::ranges::iterator_t&lt; R &gt;, Pred &gt;</div><div class="ttdoc">Helper function to create a SkipWhileAdapter from a non-const range.</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l03043">functional_adapters.hpp:3043</a></div></div>
<div class="ttc" id="afunctional__adapters_8hpp_html_a6a5fe42a5d6a908d4890d22cdd1ac0b5"><div class="ttname"><a href="functional__adapters_8hpp.html#a6a5fe42a5d6a908d4890d22cdd1ac0b5">TakeAdapterFromRange</a></div><div class="ttdeci">constexpr auto TakeAdapterFromRange(R &amp;range, size_t count) noexcept(noexcept(TakeAdapter&lt; std::ranges::iterator_t&lt; R &gt; &gt;(std::ranges::begin(range), std::ranges::end(range), count))) -&gt; TakeAdapter&lt; std::ranges::iterator_t&lt; R &gt; &gt;</div><div class="ttdoc">Helper function to create a TakeAdapter from a non-const range.</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l02948">functional_adapters.hpp:2948</a></div></div>
<div class="ttc" id="afunctional__adapters_8hpp_html_a865e738990cd1d760c9a395d24646704"><div class="ttname"><a href="functional__adapters_8hpp.html#a865e738990cd1d760c9a395d24646704">SkipAdapterFromRange</a></div><div class="ttdeci">constexpr auto SkipAdapterFromRange(R &amp;range, size_t count) noexcept(noexcept(SkipAdapter&lt; std::ranges::iterator_t&lt; R &gt; &gt;(std::ranges::begin(range), std::ranges::end(range), count))) -&gt; SkipAdapter&lt; std::ranges::iterator_t&lt; R &gt; &gt;</div><div class="ttdoc">Helper function to create a SkipAdapter from a non-const range.</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l02978">functional_adapters.hpp:2978</a></div></div>
<div class="ttc" id="afunctional__adapters_8hpp_html_aadcef6f6e0d096f987d0f75a5aac3abf"><div class="ttname"><a href="functional__adapters_8hpp.html#aadcef6f6e0d096f987d0f75a5aac3abf">ChainAdapterFromRange</a></div><div class="ttdeci">constexpr auto ChainAdapterFromRange(R1 &amp;range1, R2 &amp;range2) noexcept(noexcept(ChainAdapter&lt; std::ranges::iterator_t&lt; R1 &gt;, std::ranges::iterator_t&lt; R2 &gt; &gt;(std::ranges::begin(range1), std::ranges::end(range1), std::ranges::begin(range2), std::ranges::end(range2)))) -&gt; ChainAdapter&lt; std::ranges::iterator_t&lt; R1 &gt;, std::ranges::iterator_t&lt; R2 &gt; &gt;</div><div class="ttdoc">Helper function to create a ChainAdapter from two non-const ranges.</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l03169">functional_adapters.hpp:3169</a></div></div>
<div class="ttc" id="afunctional__adapters_8hpp_html_abf8910c7748dc4db0ce7534c2ee6c941"><div class="ttname"><a href="functional__adapters_8hpp.html#abf8910c7748dc4db0ce7534c2ee6c941">StepByAdapterFromRange</a></div><div class="ttdeci">constexpr auto StepByAdapterFromRange(R &amp;range, size_t step) noexcept(noexcept(StepByAdapter&lt; std::ranges::iterator_t&lt; R &gt; &gt;(std::ranges::begin(range), std::ranges::end(range), step))) -&gt; StepByAdapter&lt; std::ranges::iterator_t&lt; R &gt; &gt;</div><div class="ttdoc">Helper function to create a StepByAdapter from a non-const range.</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l03138">functional_adapters.hpp:3138</a></div></div>
<div class="ttc" id="afunctional__adapters_8hpp_html_ad246f1f7640da69f162cf174105bde02"><div class="ttname"><a href="functional__adapters_8hpp.html#ad246f1f7640da69f162cf174105bde02">InspectAdapterFromRange</a></div><div class="ttdeci">constexpr auto InspectAdapterFromRange(R &amp;range, Func inspector) noexcept(noexcept(InspectAdapter&lt; std::ranges::iterator_t&lt; R &gt;, Func &gt;(std::ranges::begin(range), std::ranges::end(range), std::move(inspector)))) -&gt; InspectAdapter&lt; std::ranges::iterator_t&lt; R &gt;, Func &gt;</div><div class="ttdoc">Helper function to create an InspectAdapter from a non-const range.</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l03105">functional_adapters.hpp:3105</a></div></div>
<div class="ttc" id="afunctional__adapters_8hpp_html_add0bba7ad8887393d4a80827e4d1331c"><div class="ttname"><a href="functional__adapters_8hpp.html#add0bba7ad8887393d4a80827e4d1331c">FilterAdapterFromRange</a></div><div class="ttdeci">constexpr auto FilterAdapterFromRange(R &amp;range, Pred predicate) noexcept(noexcept(FilterAdapter&lt; std::ranges::iterator_t&lt; R &gt;, Pred &gt;(std::ranges::begin(range), std::ranges::end(range), std::move(predicate)))) -&gt; FilterAdapter&lt; std::ranges::iterator_t&lt; R &gt;, Pred &gt;</div><div class="ttdoc">Helper function to create a FilterAdapter from a non-const range.</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l02881">functional_adapters.hpp:2881</a></div></div>
<div class="ttc" id="afunctional__adapters_8hpp_html_ae395ae0aba4682d48ff4e235a326fbf0"><div class="ttname"><a href="functional__adapters_8hpp.html#ae395ae0aba4682d48ff4e235a326fbf0">TakeWhileAdapterFromRange</a></div><div class="ttdeci">constexpr auto TakeWhileAdapterFromRange(R &amp;range, Pred predicate) noexcept(noexcept(TakeWhileAdapter&lt; std::ranges::iterator_t&lt; R &gt;, Pred &gt;(std::ranges::begin(range), std::ranges::end(range), std::move(predicate)))) -&gt; TakeWhileAdapter&lt; std::ranges::iterator_t&lt; R &gt;, Pred &gt;</div><div class="ttdoc">Helper function to create a TakeWhileAdapter from a non-const range.</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l03009">functional_adapters.hpp:3009</a></div></div>
<div class="ttc" id="afunctional__adapters_8hpp_html_ae484a9df0df45155f7f4b1bc3c82a926"><div class="ttname"><a href="functional__adapters_8hpp.html#ae484a9df0df45155f7f4b1bc3c82a926">MapAdapterFromRange</a></div><div class="ttdeci">constexpr auto MapAdapterFromRange(R &amp;range, Func transform) noexcept(noexcept(MapAdapter&lt; std::ranges::iterator_t&lt; R &gt;, Func &gt;(std::ranges::begin(range), std::ranges::end(range), std::move(transform)))) -&gt; MapAdapter&lt; std::ranges::iterator_t&lt; R &gt;, Func &gt;</div><div class="ttdoc">Helper function to create a MapAdapter from a range.</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l02915">functional_adapters.hpp:2915</a></div></div>
<div class="ttc" id="afunctional__adapters_8hpp_html_aea9c1e9b8d0d8913b14a2c348aa0c2a4"><div class="ttname"><a href="functional__adapters_8hpp.html#aea9c1e9b8d0d8913b14a2c348aa0c2a4">SlideAdapterFromRange</a></div><div class="ttdeci">constexpr auto SlideAdapterFromRange(R &amp;range, size_t window_size) noexcept(noexcept(SlideAdapter&lt; std::ranges::iterator_t&lt; R &gt; &gt;(std::ranges::begin(range), std::ranges::end(range), window_size))) -&gt; SlideAdapter&lt; std::ranges::iterator_t&lt; R &gt; &gt;</div><div class="ttdoc">Helper function to create a SlideAdapter from a range.</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l03297">functional_adapters.hpp:3297</a></div></div>
<div class="ttc" id="afunctional__adapters_8hpp_html_af4298b8b0abb2ebfe46dccfd80362d61"><div class="ttname"><a href="functional__adapters_8hpp.html#af4298b8b0abb2ebfe46dccfd80362d61">StrideAdapterFromRange</a></div><div class="ttdeci">constexpr auto StrideAdapterFromRange(R &amp;range, size_t stride) noexcept(noexcept(StrideAdapter&lt; std::ranges::iterator_t&lt; R &gt; &gt;(std::ranges::begin(range), std::ranges::end(range), stride))) -&gt; StrideAdapter&lt; std::ranges::iterator_t&lt; R &gt; &gt;</div><div class="ttdoc">Helper function to create a StrideAdapter from a range.</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l03328">functional_adapters.hpp:3328</a></div></div>
<div class="ttc" id="anamespacehelios_1_1utils_1_1details_html_a1bbd3cf95b591c66c67c6b8a5f3de936"><div class="ttname"><a href="namespacehelios_1_1utils_1_1details.html#a1bbd3cf95b591c66c67c6b8a5f3de936">helios::utils::details::get_call_or_apply_result_type</a></div><div class="ttdeci">consteval auto get_call_or_apply_result_type() noexcept</div><div class="ttdoc">Helper to get the result type of either invoke or apply.</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l00051">functional_adapters.hpp:51</a></div></div>
<div class="ttc" id="anamespacehelios_1_1utils_1_1details_html_a783a48bbae4b9deac0e6086616ddef31"><div class="ttname"><a href="namespacehelios_1_1utils_1_1details.html#a783a48bbae4b9deac0e6086616ddef31">helios::utils::details::folder_apply_result_t</a></div><div class="ttdeci">typename folder_apply_result&lt; Folder, Accumulator, Tuple &gt;::type folder_apply_result_t</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l00045">functional_adapters.hpp:45</a></div></div>
<div class="ttc" id="anamespacehelios_1_1utils_1_1details_html_a8382073153ee459213c49f4cc31f1883"><div class="ttname"><a href="namespacehelios_1_1utils_1_1details.html#a8382073153ee459213c49f4cc31f1883">helios::utils::details::is_folder_applicable_v</a></div><div class="ttdeci">constexpr bool is_folder_applicable_v</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l00031">functional_adapters.hpp:31</a></div></div>
<div class="ttc" id="anamespacehelios_1_1utils_1_1details_html_ab522c5f9db7a41104883d0d96f43f8da"><div class="ttname"><a href="namespacehelios_1_1utils_1_1details.html#ab522c5f9db7a41104883d0d96f43f8da">helios::utils::details::call_or_apply_result_t</a></div><div class="ttdeci">typename decltype(get_call_or_apply_result_type&lt; Func, Args... &gt;())::type call_or_apply_result_t</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l00063">functional_adapters.hpp:63</a></div></div>
<div class="ttc" id="anamespacehelios_1_1utils_html"><div class="ttname"><a href="namespacehelios_1_1utils.html">helios::utils</a></div><div class="ttdef"><b>Definition</b> <a href="common__traits_8hpp_source.html#l00008">common_traits.hpp:8</a></div></div>
<div class="ttc" id="anamespacehelios_1_1utils_html_ab0f9ee0135bae7b098c5f83d04a272bb"><div class="ttname"><a href="namespacehelios_1_1utils.html#ab0f9ee0135bae7b098c5f83d04a272bb">helios::utils::GetDerived</a></div><div class="ttdeci">constexpr Derived &amp; GetDerived() noexcept</div><div class="ttdoc">Gets reference to derived class instance.</div><div class="ttdef"><b>Definition</b> <a href="functional__adapters_8hpp_source.html#l02625">functional_adapters.hpp:2625</a></div></div>
<div class="ttc" id="anamespacehelios_1_1utils_html_afc9a7a7bb1cbdcdf23e717f41fa763be"><div class="ttname"><a href="namespacehelios_1_1utils.html#afc9a7a7bb1cbdcdf23e717f41fa763be">helios::utils::Into</a></div><div class="ttdeci">constexpr void Into(OutIt out) const</div></div>
</div><!-- fragment --> </div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1+ with doxygen-awesome-css -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
      <div style="text-align: center; padding: 1em 0; font-size: 0.9em;">
        <div style="margin-bottom: 0.5em;">
          &copy; 2025 <strong>Helios Engine</strong> - A modular ECS based data-oriented C++23 game engine framework
        </div>
        <div style="color: var(--text-color-secondary, #888);">
          Generated by
          <a href="https://www.doxygen.org/index.html" target="_blank" rel="noopener noreferrer">
            <img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/>
          </a> 1.9.8
        </div>
        <div style="margin-top: 0.5em; color: var(--text-color-secondary, #888);">
          Styled with <a href="https://github.com/jothepro/doxygen-awesome-css" target="_blank" rel="noopener noreferrer" style="color: var(--primary-color, #1779c4); text-decoration: none;">doxygen-awesome-css</a>
        </div>
      </div>
    </li>
  </ul>
</div>
</body>
</html>
